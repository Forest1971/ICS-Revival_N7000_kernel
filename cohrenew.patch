diff -urNp Kernel/arch/arm/configs/q1_speedmod_defconfig HelloWorld-Renew-v1.0-n7000-jb/arch/arm/configs/q1_speedmod_defconfig
--- Kernel/arch/arm/configs/q1_speedmod_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/arch/arm/configs/q1_speedmod_defconfig	2013-04-29 16:41:35.122587461 +0200
@@ -0,0 +1,3146 @@
+#
+# Automatically generated make config: don't edit
+# Linux/arm 3.0.31 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_HAVE_PWM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+# CONFIG_ARCH_USES_GETTIMEOFFSET is not set
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_NO_IOPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_LOCKBREAK=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPUFREQ=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_ARM_PATCH_PHYS_VIRT=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_HAVE_IRQ_WORK=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE="/usr/local/arm/arm-eabi-4.4.3/bin/arm-eabi-"
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_FHANDLE is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_HAVE_SPARSE_IRQ=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_IRQ_CHIP=y
+# CONFIG_SPARSE_IRQ is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_PREEMPT_RCU=y
+CONFIG_PREEMPT_RCU=y
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_BOOST is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=18
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_DEBUG=y
+CONFIG_CGROUP_FREEZER=y
+# CONFIG_CGROUP_DEVICE is not set
+# CONFIG_CPUSETS is not set
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+# CONFIG_CGROUP_MEM_RES_CTLR is not set
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_RT_GROUP_SCHED=y
+# CONFIG_BLK_CGROUP is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="/home/kernel/initramfs-n7000/out"
+CONFIG_INITRAMFS_ROOT_UID=0
+CONFIG_INITRAMFS_ROOT_GID=0
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_INITRAMFS_COMPRESSION_NONE is not set
+CONFIG_INITRAMFS_COMPRESSION_GZIP=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+# CONFIG_CC_CHECK_WARNING_STRICTLY is not set
+CONFIG_LTO_MENU=y
+# CONFIG_LTO_DISABLE is not set
+CONFIG_LTO=y
+# CONFIG_LTO_DEBUG is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_PANIC_TIMEOUT=1
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_HOTPLUG=y
+# CONFIG_PRINTK is not set
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_ASHMEM=y
+# CONFIG_AIO is not set
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+# CONFIG_PERF_EVENTS is not set
+# CONFIG_PERF_COUNTERS is not set
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_SLUB_DEBUG is not set
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_STOP_MACHINE=y
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_SPIN_UNLOCK is not set
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_READ_UNLOCK is not set
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQ is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_WRITE_UNLOCK is not set
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CNS3XXX is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_MXS is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_NUC93X is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P64X0 is not set
+# CONFIG_ARCH_S5PC100 is not set
+# CONFIG_ARCH_S5PV210 is not set
+CONFIG_ARCH_EXYNOS=y
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_TCC_926 is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_VT8500 is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+CONFIG_PLAT_SAMSUNG=y
+
+#
+# Base Address for SFR mapping
+#
+CONFIG_S3C_ADDR_BASE=0xFB000000
+
+#
+# Boot options
+#
+# CONFIG_S3C_BOOT_ERROR_RESET is not set
+CONFIG_S3C_BOOT_UART_FORCE_FIFO=y
+CONFIG_S3C_LOWLEVEL_UART_PORT=2
+CONFIG_SAMSUNG_CLKSRC=y
+CONFIG_SAMSUNG_IRQ_VIC_TIMER=y
+CONFIG_SAMSUNG_IRQ_UART=y
+CONFIG_SAMSUNG_GPIOLIB_4BIT=y
+CONFIG_S3C_GPIO_CFG_S3C24XX=y
+CONFIG_S3C_GPIO_CFG_S3C64XX=y
+CONFIG_S3C_GPIO_PULL_UPDOWN=y
+CONFIG_S5P_GPIO_DRVSTR=y
+CONFIG_SAMSUNG_GPIO_EXTRA=0
+CONFIG_S3C_GPIO_SPACE=0
+CONFIG_S3C_GPIO_TRACK=y
+CONFIG_S3C_ADC=y
+CONFIG_S3C_DEV_ADC=y
+# CONFIG_S3C_DEV_ADC1 is not set
+CONFIG_S3C_DEV_HSMMC2=y
+CONFIG_S3C_DEV_HSMMC3=y
+CONFIG_EXYNOS4_DEV_MSHC=y
+CONFIG_S3C_DEV_I2C1=y
+CONFIG_S3C_DEV_I2C3=y
+CONFIG_S3C_DEV_I2C5=y
+CONFIG_S3C_DEV_I2C6=y
+CONFIG_S3C_DEV_I2C7=y
+CONFIG_S3C_DEV_I2C8_EMUL=y
+CONFIG_S3C_DEV_I2C9_EMUL=y
+CONFIG_S3C_DEV_I2C11_EMUL=y
+CONFIG_S3C_DEV_I2C14_EMUL=y
+CONFIG_S3C_DEV_I2C16_EMUL=y
+# CONFIG_S3C_DEV_I2C17_EMUL is not set
+CONFIG_S3C_DEV_WDT=y
+CONFIG_S3C_DEV_RTC=y
+CONFIG_SAMSUNG_DEV_ADC=y
+CONFIG_SAMSUNG_DEV_TS=y
+CONFIG_SAMSUNG_DEV_TS1=y
+CONFIG_S3C24XX_PWM=y
+CONFIG_S3C_PL330_DMA=y
+# CONFIG_DMA_M2M_TEST is not set
+
+#
+# Power management
+#
+# CONFIG_SAMSUNG_PM_DEBUG is not set
+# CONFIG_SAMSUNG_PM_CHECK is not set
+
+#
+# Power Domain
+#
+CONFIG_SAMSUNG_PD=y
+CONFIG_PLAT_S5P=y
+CONFIG_S5P_GPIO_INT=y
+CONFIG_S5P_SYSTEM_MMU=y
+# CONFIG_S5P_SYSTEM_MMU_REFCOUNT is not set
+# CONFIG_S5P_SYSTEM_MMU_DEBUG is not set
+CONFIG_IOVMM=y
+CONFIG_IOMMU_EXYNOS4_API=y
+CONFIG_S3C_DEV_FIMC=y
+CONFIG_S5P_DEV_MFC=y
+CONFIG_S5P_DEV_FIMD0=y
+CONFIG_S5P_DEV_TVOUT=y
+CONFIG_S5P_DEV_FIMG2D=y
+CONFIG_S5P_DEV_CSIS=y
+CONFIG_S5P_DEV_JPEG=y
+CONFIG_S5P_DEV_USB_EHCI=y
+CONFIG_S5P_DEV_FIMD_S5P=y
+CONFIG_S5P_DEV_USBGADGET=y
+CONFIG_S5P_MEM_CMA=y
+CONFIG_S5P_DEV_MIPI_DSI=y
+# CONFIG_S5P_BTS is not set
+# CONFIG_S3C_DEV_TSI is not set
+CONFIG_ARCH_EXYNOS4=y
+# CONFIG_ARCH_EXYNOS5 is not set
+CONFIG_CPU_EXYNOS4210=y
+CONFIG_S5PV310_HI_ARMCLK_THAN_1_2GHZ=y
+CONFIG_EXYNOS4_PM=y
+CONFIG_EXYNOS4_CPUIDLE=y
+CONFIG_EXYNOS4_LOWPWR_IDLE=y
+CONFIG_EXYNOS_MCT=y
+CONFIG_EXYNOS4_SETUP_FIMD0=y
+CONFIG_EXYNOS_DEV_PD=y
+CONFIG_EXYNOS4_SETUP_I2C1=y
+CONFIG_EXYNOS4_SETUP_I2C3=y
+CONFIG_EXYNOS4_SETUP_I2C5=y
+CONFIG_EXYNOS4_SETUP_I2C6=y
+CONFIG_EXYNOS4_SETUP_I2C7=y
+CONFIG_EXYNOS4_SETUP_MFC=y
+CONFIG_EXYNOS4_SETUP_SDHCI=y
+CONFIG_EXYNOS4_SETUP_SDHCI_GPIO=y
+CONFIG_EXYNOS4_SETUP_MSHCI=y
+CONFIG_EXYNOS4_SETUP_MSHCI_GPIO=y
+CONFIG_EXYNOS4_SETUP_FIMC0=y
+CONFIG_EXYNOS4_SETUP_FIMC1=y
+CONFIG_EXYNOS4_SETUP_FIMC2=y
+CONFIG_EXYNOS4_SETUP_FIMC3=y
+CONFIG_EXYNOS4_SETUP_USB_PHY=y
+CONFIG_EXYNOS4_SETUP_CSIS=y
+CONFIG_EXYNOS4_SETUP_FB_S5P=y
+CONFIG_EXYNOS4_SETUP_TVOUT=y
+CONFIG_EXYNOS4_SETUP_THERMAL=y
+# CONFIG_EXYNOS_SETUP_THERMAL is not set
+CONFIG_EXYNOS4_SETUP_MIPI_DSI=y
+# CONFIG_EXYNOS4_ENABLE_CLOCK_DOWN is not set
+CONFIG_EXYNOS4_CPUFREQ=y
+# CONFIG_EXYNOS4210_1200MHZ_SUPPORT is not set
+CONFIG_EXYNOS4210_1400MHZ_SUPPORT=y
+
+#
+# Support dynamic CPU Hotplug
+#
+CONFIG_EXYNOS_PM_HOTPLUG=y
+# CONFIG_STAND_ALONE_POLICY is not set
+# CONFIG_LEGACY_HOTPLUG_POLICY is not set
+CONFIG_WITH_DVFS_POLICY=y
+# CONFIG_DVFS_NR_RUNNING_POLICY is not set
+# CONFIG_NR_RUNNING_POLICY is not set
+
+#
+# Busfreq Model
+#
+CONFIG_BUSFREQ=y
+CONFIG_BUSFREQ_QOS=y
+# CONFIG_BUSFREQ_OPP is not set
+# CONFIG_DISPFREQ_OPP is not set
+# CONFIG_DEVFREQ_BUS is not set
+# CONFIG_BUSFREQ_QOS_NONE is not set
+# CONFIG_BUSFREQ_QOS_1024X600 is not set
+# CONFIG_BUSFREQ_QOS_1280X720 is not set
+CONFIG_BUSFREQ_QOS_1280X800=y
+# CONFIG_BUSFREQ_DEBUG is not set
+CONFIG_BUSFREQ_L2_160M=y
+CONFIG_SEC_THERMISTOR=y
+# CONFIG_SEC_SUBTHERMISTOR is not set
+# CONFIG_EXYNOS_SYSREG_PM is not set
+# CONFIG_ANDROID_WIP is not set
+# CONFIG_COMPACTION_RETRY is not set
+
+#
+# EXYNOS4 Machines
+#
+# CONFIG_MACH_SMDKC210 is not set
+# CONFIG_MACH_SMDKV310 is not set
+# CONFIG_MACH_ARMLEX4210 is not set
+# CONFIG_MACH_UNIVERSAL_C210 is not set
+# CONFIG_MACH_NURI is not set
+# CONFIG_MACH_U1_NA_SPR is not set
+# CONFIG_MACH_U1_NA_USCC is not set
+CONFIG_MACH_U1=y
+# CONFIG_MACH_U1_BD is not set
+CONFIG_MACH_Q1_BD=y
+# CONFIG_TARGET_LOCALE_NAATT_TEMP is not set
+# CONFIG_MACH_PX is not set
+CONFIG_PANEL_U1=y
+# CONFIG_PANEL_U1_NA_SPR is not set
+CONFIG_TARGET_LOCALE_EUR=y
+# CONFIG_TARGET_LOCALE_LTN is not set
+# CONFIG_TARGET_LOCALE_KOR is not set
+# CONFIG_TARGET_LOCALE_P2EUR_TEMP is not set
+# CONFIG_TARGET_LOCALE_P2TMO_TEMP is not set
+# CONFIG_TARGET_LOCALE_NA is not set
+# CONFIG_TARGET_LOCALE_EUR_U1_NFC is not set
+# CONFIG_TARGET_LOCALE_NTT is not set
+# CONFIG_TARGET_LOCALE_JPN is not set
+# CONFIG_TARGET_LOCALE_CHN is not set
+# CONFIG_TARGET_LOCALE_USA is not set
+# CONFIG_MACH_SMDK4X12 is not set
+# CONFIG_MACH_MIDAS is not set
+# CONFIG_MIDAS_COMMON_BD is not set
+# CONFIG_P4NOTE_00_BD is not set
+# CONFIG_GC1_00_BD is not set
+# CONFIG_T0_00_BD is not set
+# CONFIG_KONA_00_BD is not set
+# CONFIG_T0_04_BD is not set
+# CONFIG_MACH_T0_GODIVA_LTE is not set
+# CONFIG_MACH_T0_VOLTE_Q is not set
+# CONFIG_IRON_BD is not set
+# CONFIG_GRANDE_BD is not set
+# CONFIG_WRITEBACK_ENABLED is not set
+# CONFIG_EXYNOS_SOUND_PLATFORM_DATA is not set
+# CONFIG_JACK_FET is not set
+# CONFIG_JACK_GROUND_DET is not set
+CONFIG_SAMSUNG_ANALOG_UART_SWITCH=1
+# CONFIG_EXYNOS5_DEV_BTS is not set
+
+#
+# MMC/SD slot setup
+#
+
+#
+# SELECT SYNOPSYS CONTROLLER INTERFACE DRIVER
+#
+CONFIG_EXYNOS4_MSHC_MPLL_40MHZ=y
+# CONFIG_EXYNOS4_MSHC_VPLL_46MHZ is not set
+# CONFIG_EXYNOS4_MSHC_EPLL_45MHZ is not set
+# CONFIG_EXYNOS4_MSHC_SUPPORT_PQPRIME_EPLL is not set
+
+#
+# Use 8-bit bus width
+#
+CONFIG_EXYNOS4_MSHC_8BIT=y
+# CONFIG_EXYNOS4_SDHCI_CH2_8BIT is not set
+
+#
+# Use DDR
+#
+CONFIG_EXYNOS4_MSHC_DDR=y
+
+#
+# Miscellaneous drivers
+#
+# CONFIG_WAKEUP_ASSIST is not set
+
+#
+# Debugging Feature
+#
+# CONFIG_SEC_DEBUG is not set
+CONFIG_EHCI_IRQ_DISTRIBUTION=y
+
+#
+# Samsung Modem Feature
+#
+# CONFIG_LTE_VIA_SWITCH is not set
+# CONFIG_SEC_DUAL_MODEM_MODE is not set
+# CONFIG_SEC_MODEM_M0_C2C is not set
+# CONFIG_SEC_MODEM_M0 is not set
+# CONFIG_SEC_MODEM_M0_CTC is not set
+# CONFIG_SEC_MODEM_T0_CU_DUOS is not set
+# CONFIG_SEC_MODEM_T0_OPEN_DUOS is not set
+# CONFIG_SEC_MODEM_M0_GRANDECTC is not set
+# CONFIG_SEC_MODEM_M1 is not set
+# CONFIG_SEC_MODEM_C1 is not set
+# CONFIG_SEC_MODEM_C1_LGT is not set
+# CONFIG_SEC_MODEM_M2 is not set
+CONFIG_SEC_MODEM_U1=y
+# CONFIG_SEC_MODEM_Q1_TD is not set
+# CONFIG_SEC_MODEM_U1_LGT is not set
+# CONFIG_SEC_MODEM_GAIA is not set
+# CONFIG_SEC_MODEM_IRON is not set
+# CONFIG_SEC_MODEM_P8LTE is not set
+# CONFIG_SEC_MODEM_T0_TD_DUAL is not set
+# CONFIG_SEC_MODEM_U1_SPR is not set
+# CONFIG_SEC_MODEM_GODIVA2 is not set
+
+#
+# Connectivity Feature
+#
+# CONFIG_GPS_BRCM_475X is not set
+# CONFIG_BT_CSR8811 is not set
+CONFIG_BT_BCM4330=y
+# CONFIG_BT_BCM4334 is not set
+# CONFIG_BT_BCM43241 is not set
+CONFIG_BT_MGMT=y
+
+#
+# Qualcomm Modem Feature
+#
+# CONFIG_QC_MODEM is not set
+# CONFIG_MSM_SUBSYSTEM_RESTART is not set
+# CONFIG_QC_MODEM_MDM9X15 is not set
+# CONFIG_MDM_HSIC_PM is not set
+# CONFIG_EMI_ERROR_RECOVERY is not set
+# CONFIG_SIM_DETECT is not set
+CONFIG_USB_CDFS_SUPPORT=y
+CONFIG_SAMSUNG_PRODUCT_SHIP=y
+# CONFIG_CORESIGHT_ETM is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_V7=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_V7=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_TRUSTZONE is not set
+CONFIG_ARM_THUMB=y
+# CONFIG_ARM_THUMBEE is not set
+CONFIG_SWP_EMULATE=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_OUTER_CACHE=y
+CONFIG_OUTER_CACHE_SYNC=y
+CONFIG_CACHE_L2X0=y
+CONFIG_CACHE_PL310=y
+CONFIG_ARM_L1_CACHE_SHIFT=5
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+CONFIG_ARM_PLD_SIZE=32
+CONFIG_CPU_HAS_PMU=y
+# CONFIG_ARM_ERRATA_430973 is not set
+# CONFIG_ARM_ERRATA_458693 is not set
+# CONFIG_ARM_ERRATA_460075 is not set
+# CONFIG_ARM_ERRATA_742230 is not set
+# CONFIG_ARM_ERRATA_742231 is not set
+# CONFIG_PL310_ERRATA_588369 is not set
+# CONFIG_ARM_ERRATA_720789 is not set
+# CONFIG_ARM_ERRATA_720791 is not set
+CONFIG_PL310_ERRATA_727915=y
+CONFIG_ARM_ERRATA_743622=y
+CONFIG_ARM_ERRATA_751472=y
+CONFIG_ARM_ERRATA_753970=y
+CONFIG_ARM_ERRATA_754322=y
+# CONFIG_ARM_ERRATA_754327 is not set
+# CONFIG_ARM_ERRATA_761320 is not set
+# CONFIG_ARM_ERRATA_761171 is not set
+# CONFIG_ARM_ERRATA_762974 is not set
+# CONFIG_ARM_ERRATA_763722 is not set
+CONFIG_ARM_GIC=y
+CONFIG_PL330=y
+# CONFIG_FIQ_DEBUGGER is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+CONFIG_ARM_ERRATA_764369=y
+# CONFIG_PL310_ERRATA_769419 is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_SMP=y
+CONFIG_SMP_ON_UP=y
+CONFIG_ARM_CPU_TOPOLOGY=y
+CONFIG_SCHED_MC=y
+# CONFIG_SCHED_SMT is not set
+CONFIG_HAVE_ARM_SCU=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_NR_CPUS=2
+CONFIG_HOTPLUG_CPU=y
+CONFIG_LOCAL_TIMERS=y
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_HZ=200
+# CONFIG_THUMB2_KERNEL is not set
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_ARCH_SKIP_SECONDARY_CALIBRATE=y
+CONFIG_HIGHMEM=y
+# CONFIG_HIGHPTE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+# CONFIG_CLEANCACHE is not set
+CONFIG_CMA=y
+# CONFIG_CMA_DEVELOPEMENT is not set
+CONFIG_CMA_BEST_FIT=y
+# CONFIG_DEBUG_VMALLOC is not set
+# CONFIG_LOWMEM_CHECK is not set
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_CC_STACKPROTECTOR is not set
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+# CONFIG_ARM_FLUSH_CONSOLE_ON_RESTART is not set
+# CONFIG_VMWARE_MVP is not set
+
+#
+# Boot options
+#
+# CONFIG_USE_OF is not set
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_CMDLINE="console=ttySAC2,115200 consoleblank=0"
+CONFIG_CMDLINE_FROM_BOOTLOADER=y
+# CONFIG_CMDLINE_EXTEND is not set
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_AUTO_ZRELADDR is not set
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ADAPTIVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PEGASUSQ is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+# CONFIG_CPU_FREQ_GOV_USERSPACE is not set
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+# CONFIG_CPU_FREQ_GOV_ONDEMAND_FLEXRATE is not set
+# CONFIG_CPU_FREQ_GOV_INTERACTIVE is not set
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+# CONFIG_CPU_FREQ_GOV_ADAPTIVE is not set
+# CONFIG_CPU_FREQ_GOV_PEGASUSQ is not set
+# CONFIG_CPU_FREQ_GOV_SLP is not set
+# CONFIG_CPU_FREQ_DVFS_MONITOR is not set
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_MISC=y
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_PM_WATCHDOG_TIMEOUT=y
+# CONFIG_FAST_BOOT is not set
+CONFIG_HAS_WAKELOCK=y
+CONFIG_HAS_EARLYSUSPEND=y
+CONFIG_WAKELOCK=y
+CONFIG_WAKELOCK_STAT=y
+CONFIG_USER_WAKELOCK=y
+CONFIG_EARLYSUSPEND=y
+# CONFIG_NO_USER_SPACE_SCREEN_ACCESS_CONTROL is not set
+# CONFIG_CONSOLE_EARLYSUSPEND is not set
+CONFIG_FB_EARLYSUSPEND=y
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+CONFIG_PM_RUNTIME=y
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
+CONFIG_ARCH_HAS_OPP=y
+CONFIG_PM_OPP=y
+CONFIG_PM_RUNTIME_CLK=y
+# CONFIG_SUSPEND_TIME is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_XFRM_IPCOMP=y
+CONFIG_NET_KEY=y
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+# CONFIG_IP_FIB_TRIE_STATS is not set
+CONFIG_IP_MULTIPLE_TABLES=y
+# CONFIG_IP_ROUTE_MULTIPATH is not set
+# CONFIG_IP_ROUTE_VERBOSE is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+CONFIG_INET_ESP=y
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+CONFIG_IPV6_PRIVACY=y
+CONFIG_IPV6_ROUTER_PREF=y
+# CONFIG_IPV6_ROUTE_INFO is not set
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_IPV6_MIP6=y
+CONFIG_INET6_XFRM_TUNNEL=y
+CONFIG_INET6_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=y
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+CONFIG_IPV6_TUNNEL=y
+CONFIG_IPV6_MULTIPLE_TABLES=y
+# CONFIG_IPV6_SUBTREES is not set
+# CONFIG_IPV6_MROUTE is not set
+CONFIG_ANDROID_PARANOID_NETWORK=y
+CONFIG_NET_ACTIVITY_STATS=y
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_NETFILTER_NETLINK_QUEUE=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
+CONFIG_NF_CT_PROTO_DCCP=y
+CONFIG_NF_CT_PROTO_GRE=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_BROADCAST=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+# CONFIG_NF_CONNTRACK_SNMP is not set
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_NF_CONNTRACK_SANE=y
+# CONFIG_NF_CONNTRACK_SIP is not set
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_TPROXY=y
+CONFIG_NETFILTER_XTABLES=y
+
+#
+# Xtables combined modules
+#
+CONFIG_NETFILTER_XT_MARK=y
+CONFIG_NETFILTER_XT_CONNMARK=y
+
+#
+# Xtables targets
+#
+# CONFIG_NETFILTER_XT_TARGET_CHECKSUM is not set
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+# CONFIG_NETFILTER_XT_TARGET_CT is not set
+# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
+# CONFIG_NETFILTER_XT_TARGET_HL is not set
+# CONFIG_NETFILTER_XT_TARGET_IDLETIMER is not set
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+# CONFIG_NETFILTER_XT_TARGET_NOTRACK is not set
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+# CONFIG_NETFILTER_XT_TARGET_TEE is not set
+CONFIG_NETFILTER_XT_TARGET_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_TRACE=y
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+
+#
+# Xtables matches
+#
+# CONFIG_NETFILTER_XT_MATCH_ADDRTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+# CONFIG_NETFILTER_XT_MATCH_CPU is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
+# CONFIG_NETFILTER_XT_MATCH_ESP is not set
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_HL=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+# CONFIG_NETFILTER_XT_MATCH_MULTIPORT is not set
+# CONFIG_NETFILTER_XT_MATCH_OSF is not set
+# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+# CONFIG_NETFILTER_XT_MATCH_RECENT is not set
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+# CONFIG_IP_SET is not set
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+# CONFIG_IP_NF_QUEUE is not set
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_REJECT_SKERR=y
+CONFIG_IP_NF_TARGET_LOG=y
+# CONFIG_IP_NF_TARGET_ULOG is not set
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_NF_NAT_PROTO_DCCP=y
+CONFIG_NF_NAT_PROTO_GRE=y
+CONFIG_NF_NAT_PROTO_UDPLITE=y
+CONFIG_NF_NAT_PROTO_SCTP=y
+CONFIG_NF_NAT_FTP=y
+CONFIG_NF_NAT_IRC=y
+CONFIG_NF_NAT_TFTP=y
+CONFIG_NF_NAT_AMANDA=y
+CONFIG_NF_NAT_PPTP=y
+CONFIG_NF_NAT_H323=y
+# CONFIG_NF_NAT_SIP is not set
+CONFIG_IP_NF_MANGLE=y
+# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
+# CONFIG_IP_NF_TARGET_ECN is not set
+# CONFIG_IP_NF_TARGET_TTL is not set
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IP_NF_ARP_MANGLE=y
+
+#
+# IPv6: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV6=y
+CONFIG_NF_CONNTRACK_IPV6=y
+# CONFIG_IP6_NF_QUEUE is not set
+CONFIG_IP6_NF_IPTABLES=y
+# CONFIG_IP6_NF_MATCH_AH is not set
+# CONFIG_IP6_NF_MATCH_EUI64 is not set
+# CONFIG_IP6_NF_MATCH_FRAG is not set
+# CONFIG_IP6_NF_MATCH_OPTS is not set
+# CONFIG_IP6_NF_MATCH_HL is not set
+# CONFIG_IP6_NF_MATCH_IPV6HEADER is not set
+# CONFIG_IP6_NF_MATCH_MH is not set
+# CONFIG_IP6_NF_MATCH_RT is not set
+# CONFIG_IP6_NF_TARGET_HL is not set
+CONFIG_IP6_NF_TARGET_LOG=y
+CONFIG_IP6_NF_FILTER=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+CONFIG_IP6_NF_TARGET_REJECT_SKERR=y
+CONFIG_IP6_NF_MANGLE=y
+CONFIG_IP6_NF_RAW=y
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+CONFIG_PHONET=y
+# CONFIG_IEEE802154 is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+# CONFIG_NET_SCH_CBQ is not set
+CONFIG_NET_SCH_HTB=y
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFB is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_DRR is not set
+# CONFIG_NET_SCH_MQPRIO is not set
+# CONFIG_NET_SCH_CHOKE is not set
+# CONFIG_NET_SCH_QFQ is not set
+CONFIG_NET_SCH_INGRESS=y
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+# CONFIG_NET_CLS_FW is not set
+CONFIG_NET_CLS_U32=y
+# CONFIG_CLS_U32_PERF is not set
+# CONFIG_CLS_U32_MARK is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_CLS_FLOW is not set
+# CONFIG_NET_CLS_CGROUP is not set
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_STACK=32
+# CONFIG_NET_EMATCH_CMP is not set
+# CONFIG_NET_EMATCH_NBYTE is not set
+CONFIG_NET_EMATCH_U32=y
+# CONFIG_NET_EMATCH_META is not set
+# CONFIG_NET_EMATCH_TEXT is not set
+CONFIG_NET_CLS_ACT=y
+CONFIG_NET_ACT_POLICE=y
+CONFIG_NET_ACT_GACT=y
+# CONFIG_GACT_PROB is not set
+CONFIG_NET_ACT_MIRRED=y
+# CONFIG_NET_ACT_IPT is not set
+# CONFIG_NET_ACT_NAT is not set
+# CONFIG_NET_ACT_PEDIT is not set
+# CONFIG_NET_ACT_SIMP is not set
+# CONFIG_NET_ACT_SKBEDIT is not set
+# CONFIG_NET_ACT_CSUM is not set
+# CONFIG_NET_CLS_IND is not set
+CONFIG_NET_SCH_FIFO=y
+# CONFIG_DCB is not set
+# CONFIG_DNS_RESOLVER is not set
+# CONFIG_BATMAN_ADV is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+CONFIG_BT=y
+CONFIG_BT_L2CAP=y
+CONFIG_BT_SCO=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+# CONFIG_BT_BNEP_MC_FILTER is not set
+# CONFIG_BT_BNEP_PROTO_FILTER is not set
+CONFIG_BT_HIDP=y
+
+#
+# Bluetooth device drivers
+#
+# CONFIG_BT_HCIBTUSB is not set
+# CONFIG_BT_HCIBTSDIO is not set
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_H4=y
+# CONFIG_BT_HCIUART_BCSP is not set
+# CONFIG_BT_HCIUART_ATH3K is not set
+# CONFIG_BT_HCIUART_LL is not set
+# CONFIG_BT_HCIBCM203X is not set
+# CONFIG_BT_HCIBPA10X is not set
+# CONFIG_BT_HCIBFUSB is not set
+# CONFIG_BT_HCIVHCI is not set
+# CONFIG_BT_MRVL is not set
+
+#
+# Bluetooth device drivers
+#
+
+#
+# Bluetooth device drivers
+#
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_CFG80211=y
+# CONFIG_NL80211_TESTMODE is not set
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+# CONFIG_CFG80211_REG_DEBUG is not set
+CONFIG_CFG80211_DEFAULT_PS=y
+# CONFIG_CFG80211_DEBUGFS is not set
+# CONFIG_CFG80211_INTERNAL_REGDB is not set
+CONFIG_CFG80211_WEXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+# CONFIG_LIB80211 is not set
+# CONFIG_CFG80211_ALLOW_RECONNECT is not set
+# CONFIG_MAC80211 is not set
+# CONFIG_WIMAX is not set
+CONFIG_RFKILL=y
+CONFIG_RFKILL_PM=y
+# CONFIG_RFKILL_INPUT is not set
+# CONFIG_RFKILL_REGULATOR is not set
+# CONFIG_RFKILL_GPIO is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+# CONFIG_DEVTMPFS is not set
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_DMA_SHARED_BUFFER is not set
+CONFIG_SYNC=y
+CONFIG_SW_SYNC=y
+CONFIG_SW_SYNC_USER=y
+CONFIG_DMA_CMA=y
+
+#
+# Default contiguous memory area size:
+#
+CONFIG_CMA_SIZE_MBYTES=16
+CONFIG_CMA_SIZE_SEL_MBYTES=y
+# CONFIG_CMA_SIZE_SEL_PERCENTAGE is not set
+# CONFIG_CMA_SIZE_SEL_MIN is not set
+# CONFIG_CMA_SIZE_SEL_MAX is not set
+CONFIG_CMA_ALIGNMENT=8
+CONFIG_CMA_AREAS=7
+# CONFIG_CONNECTOR is not set
+# CONFIG_MTD is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+
+#
+# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
+#
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=8192
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_SENSORS_LIS3LV02D is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_AD525X_DPOT is not set
+CONFIG_ANDROID_PMEM=y
+
+#
+# Reserved memory configurations
+#
+CONFIG_ANDROID_PMEM_MEMSIZE_PMEM=4096
+CONFIG_ANDROID_PMEM_MEMSIZE_PMEM_GPU1=4
+CONFIG_ANDROID_PMEM_MEMSIZE_PMEM_CAM=0
+# CONFIG_INTEL_MID_PTI is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_SENSORS_AK8975 is not set
+# CONFIG_SENSORS_AK8963 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_TI_DAC7512 is not set
+CONFIG_UID_STAT=y
+# CONFIG_BMP085 is not set
+# CONFIG_WL127X_RFKILL is not set
+# CONFIG_APANIC is not set
+# CONFIG_JACK_MON is not set
+# CONFIG_UART_SELECT is not set
+# CONFIG_SWITCH_DUAL_MODEM is not set
+# CONFIG_SWITCH_USB_PATH_AUTO is not set
+# CONFIG_WIMAX_CMC is not set
+CONFIG_SEC_DEV_JACK=y
+CONFIG_JACK_RESELECTOR_SUPPORT=y
+# CONFIG_MUIC_DET_JACK is not set
+# CONFIG_FM34_WE395 is not set
+# CONFIG_AUDIENCE_ES305 is not set
+# CONFIG_2MIC_FM34_WE395 is not set
+CONFIG_MUIC_MAX8997=y
+# CONFIG_MUIC_MAX8997_OVPUI is not set
+# CONFIG_USBHUB_USB3503 is not set
+# CONFIG_USBHUB_USB3503_OTG_CONN is not set
+# CONFIG_USBHUB_USB3803 is not set
+CONFIG_PN544=y
+# CONFIG_STMPE811_ADC is not set
+# CONFIG_MPU_SENSORS_MPU3050 is not set
+# CONFIG_MPU_SENSORS_MPU6050 is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_IWMC3200TOP is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+CONFIG_SEC_MODEM=y
+CONFIG_UMTS_MODEM_XMM6260=y
+# CONFIG_UMTS_MODEM_XMM6262 is not set
+# CONFIG_CDMA_MODEM_CBP71 is not set
+# CONFIG_CDMA_MODEM_CBP72 is not set
+# CONFIG_LTE_MODEM_CMC221 is not set
+# CONFIG_CDMA_MODEM_MDM6600 is not set
+# CONFIG_TDSCDMA_MODEM_SPRD8803 is not set
+# CONFIG_GSM_MODEM_ESC6270 is not set
+# CONFIG_CDMA_MODEM_QSC6085 is not set
+# CONFIG_LINK_DEVICE_MIPI is not set
+# CONFIG_LINK_DEVICE_DPRAM is not set
+# CONFIG_LINK_DEVICE_PLD is not set
+# CONFIG_LINK_DEVICE_USB is not set
+CONFIG_LINK_DEVICE_HSIC=y
+# CONFIG_LINK_DEVICE_C2C is not set
+# CONFIG_LINK_DEVICE_SPI is not set
+# CONFIG_WORKQUEUE_FRONT is not set
+# CONFIG_SIM_SLOT_SWITCH is not set
+# CONFIG_LTE_MODEM_CMC220 is not set
+# CONFIG_INTERNAL_MODEM_IF is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+CONFIG_CHR_DEV_SG=y
+# CONFIG_CHR_DEV_SCH is not set
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+CONFIG_MD=y
+# CONFIG_BLK_DEV_MD is not set
+CONFIG_BLK_DEV_DM=y
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_CRYPT=y
+# CONFIG_DM_SNAPSHOT is not set
+# CONFIG_DM_MIRROR is not set
+# CONFIG_DM_RAID is not set
+# CONFIG_DM_ZERO is not set
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_DELAY is not set
+# CONFIG_DM_UEVENT is not set
+# CONFIG_DM_FLAKEY is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_NETDEVICES=y
+# CONFIG_IFB is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=y
+# CONFIG_VETH is not set
+# CONFIG_MII is not set
+# CONFIG_PHYLIB is not set
+# CONFIG_NET_ETHERNET is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+CONFIG_WLAN=y
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_USB_NET_RNDIS_WLAN is not set
+CONFIG_WIFI_CONTROL_FUNC=y
+# CONFIG_ATH_COMMON is not set
+CONFIG_BCM4330=y
+# CONFIG_BCM4334 is not set
+# CONFIG_BCM43241 is not set
+CONFIG_BCMDHD_FW_PATH="/system/etc/firmware/fw_bcmdhd.bin"
+CONFIG_BCMDHD_NVRAM_PATH="/system/etc/wifi/bcmdhd.cal"
+CONFIG_BROADCOM_WIFI_RESERVED_MEM=y
+CONFIG_WLAN_REGION_CODE=100
+# CONFIG_HOSTAP is not set
+# CONFIG_IWM is not set
+# CONFIG_LIBERTAS is not set
+# CONFIG_MWIFIEX is not set
+# CONFIG_LGUIWLAN is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_HSO is not set
+# CONFIG_USB_CDC_PHONET is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_WAN is not set
+
+#
+# CAIF transport drivers
+#
+CONFIG_PPP=y
+# CONFIG_PPP_MULTILINK is not set
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=y
+# CONFIG_PPP_SYNC_TTY is not set
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_MPPE=y
+# CONFIG_PPPOE is not set
+CONFIG_PPPOLAC=y
+CONFIG_PPPOPNS=y
+# CONFIG_SLIP is not set
+CONFIG_SLHC=y
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+# CONFIG_INPUT_SECBRIDGE is not set
+# CONFIG_INPUT_KEYRESET is not set
+# CONFIG_INPUT_FBSUSPEND is not set
+# CONFIG_INPUT_MPU6050 is not set
+# CONFIG_INPUT_MPU6050_POLLING is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+CONFIG_KEYBOARD_GPIO=y
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_KEYBOARD_CYPRESS_TOUCH=y
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_MELFAS_GC is not set
+# CONFIG_TOUCHSCREEN_MELFAS is not set
+# CONFIG_TOUCHSCREEN_MELFAS_MMS is not set
+# CONFIG_TOUCHSCREEN_MMS152 is not set
+# CONFIG_TOUCHSCREEN_MELFAS_NOTE is not set
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT224_U1 is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT224_GRANDE is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT224S_GRANDE is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT224_GC is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT1536E is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT1664S is not set
+CONFIG_TOUCHSCREEN_ATMEL_MXT540E=y
+# CONFIG_TOUCHSCREEN_ATMEL_MXT224 is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_S3C2410 is not set
+# CONFIG_TOUCHSCREEN_EXYNOS4 is not set
+# CONFIG_TOUCHSCREEN_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MAX11801 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MMS114 is not set
+# CONFIG_MELFAS_TOUCHKEY is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+# CONFIG_TOUCHSCREEN_ZINITIX is not set
+# CONFIG_TOUCHSCREEN_MXT1386 is not set
+# CONFIG_TOUCHSCREEN_MXT768E is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_S7301 is not set
+# CONFIG_TOUCHSCREEN_CYPRESS_TMA46X is not set
+# CONFIG_SEC_TOUCHSCREEN_DVFS_LOCK is not set
+# CONFIG_SEC_TOUCHSCREEN_SURFACE_TOUCH is not set
+# CONFIG_KEYPAD_MELFAS_TOUCH is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT540S is not set
+CONFIG_INPUT_WACOM=y
+CONFIG_EPEN_WACOM_G5SP=y
+# CONFIG_EPEN_WACOM_G9PM is not set
+# CONFIG_EPEN_WACOM_G9PL is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_SENSORS_BH1721FVC is not set
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_ATI_REMOTE is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+CONFIG_INPUT_KEYCHORD=y
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+CONFIG_INPUT_UINPUT=y
+CONFIG_INPUT_GPIO=y
+# CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_PWM_BEEPER is not set
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_OPTICAL_GP2A is not set
+# CONFIG_OPTICAL_WAKE_ENABLE is not set
+# CONFIG_INPUT_CMA3000 is not set
+# CONFIG_INPUT_FLIP is not set
+# CONFIG_INPUT_KR3DH is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+# CONFIG_VT_CONSOLE is not set
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_DEVMEM=y
+CONFIG_DEVKMEM=y
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_CONSOLE is not set
+CONFIG_SERIAL_8250_NR_UARTS=4
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_SAMSUNG=y
+CONFIG_SERIAL_SAMSUNG_UARTS_4=y
+CONFIG_SERIAL_SAMSUNG_UARTS=4
+CONFIG_SERIAL_SAMSUNG_CONSOLE=y
+# CONFIG_SERIAL_SAMSUNG_CONSOLE_SWITCH is not set
+CONFIG_SERIAL_S5PV210=y
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX3107 is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_CSR_GSD4T_CDMA is not set
+
+#
+# Diag Support
+#
+# CONFIG_DIAG_CHAR is not set
+
+#
+# DIAG traffic over USB
+#
+
+#
+# SDIO support for DIAG
+#
+
+#
+# HSIC support for DIAG
+#
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_DCC_TTY is not set
+# CONFIG_RAMOOPS is not set
+CONFIG_S3C_MEM=y
+CONFIG_EXYNOS_MEM=y
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_CHARDEV=y
+# CONFIG_I2C_MUX is not set
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_DESIGNWARE is not set
+CONFIG_I2C_GPIO=y
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PXA_PCI is not set
+CONFIG_HAVE_S3C2410_I2C=y
+CONFIG_I2C_S3C2410=y
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+CONFIG_SPI_BITBANG=y
+CONFIG_SPI_GPIO=y
+# CONFIG_SPI_OC_TINY is not set
+# CONFIG_SPI_PXA2XX_PCI is not set
+# CONFIG_SPI_S3C64XX is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+
+#
+# Enable Device Drivers -> PPS to see the PTP clock options.
+#
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_SYSFS=y
+
+#
+# Memory mapped GPIO drivers:
+#
+# CONFIG_GPIO_BASIC_MMIO is not set
+# CONFIG_GPIO_IT8761E is not set
+CONFIG_GPIO_EXYNOS4=y
+CONFIG_GPIO_PLAT_SAMSUNG=y
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_SX150X is not set
+# CONFIG_GPIO_ADP5588 is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_74X164 is not set
+
+#
+# AC97 GPIO expanders:
+#
+
+#
+# MODULbus GPIO expanders:
+#
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_MAX8997_CHARGER is not set
+# CONFIG_BATTERY_MAX17043_FUELGAUGE is not set
+# CONFIG_BATTERY_MAX17042_FUELGAUGE is not set
+# CONFIG_BATTERY_MAX17047_FUELGAUGE is not set
+# CONFIG_BATTERY_SMB136_CHARGER is not set
+# CONFIG_BATTERY_SAMSUNG_P1X is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_BQ20Z75 is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_BATTERY_S3C_ADC is not set
+# CONFIG_CHARGER_GPIO is not set
+# CONFIG_BATTERY_SAMSUNG is not set
+# CONFIG_CHARGER_MAX8997 is not set
+CONFIG_CHARGER_MAX8997_U1=y
+# CONFIG_CHARGER_MAX8997_PX is not set
+CONFIG_BATTERY_SEC_U1=y
+# CONFIG_BATTERY_SEC_PX is not set
+# CONFIG_CHARGER_MAX8922_U1 is not set
+CONFIG_BATTERY_MAX17042_FUELGAUGE_U1=y
+# CONFIG_BATTERY_MAX17042_FUELGAUGE_PX is not set
+# CONFIG_SMB136_CHARGER is not set
+CONFIG_SMB136_CHARGER_Q1=y
+CONFIG_SMB328_CHARGER=y
+# CONFIG_SMB347_CHARGER is not set
+# CONFIG_CHARGER_MANAGER is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_SENSORS_EXYNOS4_TMU is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+CONFIG_MFD_SUPPORT=y
+CONFIG_MFD_CORE=y
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_MAX8925 is not set
+CONFIG_MFD_MAX8997=y
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_MAX8698 is not set
+# CONFIG_MFD_MAX77686 is not set
+# CONFIG_MFD_MAX77693 is not set
+# CONFIG_MFD_S5M_CORE is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_MC13XXX is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_TPS65910 is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_DUMMY is not set
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_BQ24022 is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_MAX8649 is not set
+# CONFIG_REGULATOR_MAX8660 is not set
+# CONFIG_REGULATOR_MAX8952 is not set
+# CONFIG_REGULATOR_MAX8952_GRANDE is not set
+CONFIG_REGULATOR_MAX8997=y
+# CONFIG_REGULATOR_LP3971 is not set
+# CONFIG_REGULATOR_LP3972 is not set
+# CONFIG_REGULATOR_LP8720 is not set
+# CONFIG_REGULATOR_TPS65023 is not set
+# CONFIG_REGULATOR_TPS6507X is not set
+# CONFIG_REGULATOR_ISL6271A is not set
+# CONFIG_REGULATOR_AD5398 is not set
+# CONFIG_REGULATOR_TPS6524X is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+# CONFIG_MEDIA_CONTROLLER is not set
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_COMMON=y
+# CONFIG_DVB_CORE is not set
+CONFIG_VIDEO_MEDIA=y
+
+#
+# Multimedia drivers
+#
+CONFIG_RC_CORE=y
+CONFIG_LIRC=y
+CONFIG_RC_MAP=y
+CONFIG_IR_NEC_DECODER=y
+CONFIG_IR_RC5_DECODER=y
+CONFIG_IR_RC6_DECODER=y
+CONFIG_IR_JVC_DECODER=y
+CONFIG_IR_SONY_DECODER=y
+CONFIG_IR_RC5_SZ_DECODER=y
+CONFIG_IR_LIRC_CODEC=y
+# CONFIG_IR_IMON is not set
+# CONFIG_IR_MCEUSB is not set
+# CONFIG_IR_REDRAT3 is not set
+# CONFIG_IR_STREAMZAP is not set
+# CONFIG_RC_LOOPBACK is not set
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=y
+CONFIG_MEDIA_TUNER_CUSTOMISE=y
+
+#
+# Customize TV tuners
+#
+# CONFIG_MEDIA_TUNER_SIMPLE is not set
+# CONFIG_MEDIA_TUNER_TDA8290 is not set
+# CONFIG_MEDIA_TUNER_TDA827X is not set
+# CONFIG_MEDIA_TUNER_TDA18271 is not set
+# CONFIG_MEDIA_TUNER_TDA9887 is not set
+# CONFIG_MEDIA_TUNER_TEA5761 is not set
+# CONFIG_MEDIA_TUNER_TEA5767 is not set
+# CONFIG_MEDIA_TUNER_MT20XX is not set
+# CONFIG_MEDIA_TUNER_MT2060 is not set
+# CONFIG_MEDIA_TUNER_MT2266 is not set
+# CONFIG_MEDIA_TUNER_MT2131 is not set
+# CONFIG_MEDIA_TUNER_QT1010 is not set
+# CONFIG_MEDIA_TUNER_XC2028 is not set
+# CONFIG_MEDIA_TUNER_XC5000 is not set
+# CONFIG_MEDIA_TUNER_MXL5005S is not set
+# CONFIG_MEDIA_TUNER_MXL5007T is not set
+# CONFIG_MEDIA_TUNER_MC44S803 is not set
+# CONFIG_MEDIA_TUNER_MAX2165 is not set
+# CONFIG_MEDIA_TUNER_TDA18218 is not set
+# CONFIG_MEDIA_TUNER_TDA18212 is not set
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEOBUF2_CORE=y
+CONFIG_VIDEOBUF2_MEMOPS=y
+CONFIG_VIDEOBUF2_CMA_PHYS=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+CONFIG_VIDEO_FIXED_MINOR_RANGES=y
+# CONFIG_VIDEO_HELPER_CHIPS_AUTO is not set
+CONFIG_VIDEO_IR_I2C=y
+
+#
+# Encoders, decoders, sensors and other helper chips
+#
+
+#
+# Audio decoders, processors and mixers
+#
+# CONFIG_VIDEO_TVAUDIO is not set
+# CONFIG_VIDEO_TDA7432 is not set
+# CONFIG_VIDEO_TDA9840 is not set
+# CONFIG_VIDEO_TEA6415C is not set
+# CONFIG_VIDEO_TEA6420 is not set
+# CONFIG_VIDEO_MSP3400 is not set
+# CONFIG_VIDEO_CS5345 is not set
+# CONFIG_VIDEO_CS53L32A is not set
+# CONFIG_VIDEO_TLV320AIC23B is not set
+# CONFIG_VIDEO_WM8775 is not set
+# CONFIG_VIDEO_WM8739 is not set
+# CONFIG_VIDEO_VP27SMPX is not set
+
+#
+# RDS decoders
+#
+# CONFIG_VIDEO_SAA6588 is not set
+
+#
+# Video decoders
+#
+# CONFIG_VIDEO_ADV7180 is not set
+# CONFIG_VIDEO_BT819 is not set
+# CONFIG_VIDEO_BT856 is not set
+# CONFIG_VIDEO_BT866 is not set
+# CONFIG_VIDEO_KS0127 is not set
+# CONFIG_VIDEO_SAA7110 is not set
+# CONFIG_VIDEO_SAA711X is not set
+# CONFIG_VIDEO_SAA7191 is not set
+# CONFIG_VIDEO_TVP514X is not set
+# CONFIG_VIDEO_TVP5150 is not set
+# CONFIG_VIDEO_TVP7002 is not set
+# CONFIG_VIDEO_VPX3220 is not set
+CONFIG_VIDEO_M5MO=y
+# CONFIG_VIDEO_M9MO is not set
+CONFIG_VIDEO_S5K5BAFX=y
+# CONFIG_VIDEO_S5K5CCGX_COMMON is not set
+# CONFIG_VIDEO_SR200PC20 is not set
+# CONFIG_VIDEO_SR200PC20M is not set
+# CONFIG_VIDEO_ISX012 is not set
+# CONFIG_VIDEO_SLP_S5K4ECGX is not set
+# CONFIG_VIDEO_SLP_DB8131M is not set
+# CONFIG_VIDEO_S5K4EA is not set
+# CONFIG_VIDEO_S5C73M3 is not set
+# CONFIG_VIDEO_SLP_S5C73M3 is not set
+# CONFIG_VIDEO_SR130PC20 is not set
+CONFIG_VIDEO_IMPROVE_STREAMOFF=y
+CONFIG_CSI_C=y
+# CONFIG_CSI_D is not set
+
+#
+# Video and audio decoders
+#
+# CONFIG_VIDEO_SAA717X is not set
+# CONFIG_VIDEO_CX25840 is not set
+
+#
+# MPEG video encoders
+#
+# CONFIG_VIDEO_CX2341X is not set
+
+#
+# Video encoders
+#
+# CONFIG_VIDEO_SAA7127 is not set
+# CONFIG_VIDEO_SAA7185 is not set
+# CONFIG_VIDEO_ADV7170 is not set
+# CONFIG_VIDEO_ADV7175 is not set
+# CONFIG_VIDEO_ADV7343 is not set
+# CONFIG_VIDEO_AK881X is not set
+
+#
+# Camera sensor devices
+#
+# CONFIG_VIDEO_OV7670 is not set
+# CONFIG_VIDEO_MT9V011 is not set
+# CONFIG_VIDEO_TCM825X is not set
+
+#
+# Video improvement chips
+#
+# CONFIG_VIDEO_UPD64031A is not set
+# CONFIG_VIDEO_UPD64083 is not set
+
+#
+# Miscelaneous helper chips
+#
+# CONFIG_VIDEO_THS7303 is not set
+# CONFIG_VIDEO_M52790 is not set
+# CONFIG_VIDEO_CPIA2 is not set
+# CONFIG_VIDEO_SR030PC30 is not set
+# CONFIG_VIDEO_NOON010PC30 is not set
+# CONFIG_SOC_CAMERA is not set
+# CONFIG_VIDEO_SAMSUNG_S5P_FIMC is not set
+CONFIG_SAMSUNG_MFC_DRIVERS=y
+CONFIG_USE_LEGACY_MFC=y
+# CONFIG_USE_V4L2_MFC is not set
+CONFIG_V4L_USB_DRIVERS=y
+# CONFIG_USB_VIDEO_CLASS is not set
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+# CONFIG_USB_GSPCA is not set
+# CONFIG_VIDEO_PVRUSB2 is not set
+# CONFIG_VIDEO_HDPVR is not set
+# CONFIG_VIDEO_EM28XX is not set
+# CONFIG_VIDEO_CX231XX is not set
+# CONFIG_VIDEO_USBVISION is not set
+# CONFIG_USB_ET61X251 is not set
+# CONFIG_USB_SN9C102 is not set
+# CONFIG_USB_PWC is not set
+# CONFIG_USB_ZR364XX is not set
+# CONFIG_USB_STKWEBCAM is not set
+# CONFIG_USB_S2255 is not set
+CONFIG_VIDEO_SAMSUNG=y
+CONFIG_VIDEO_SAMSUNG_V4L2=y
+CONFIG_VIDEO_FIMC=y
+# CONFIG_USE_FIMC_CMA is not set
+CONFIG_VIDEO_FIMC_RANGE_NARROW=y
+# CONFIG_VIDEO_FIMC_RANGE_WIDE is not set
+# CONFIG_VIDEO_FIMC_DEBUG is not set
+CONFIG_VIDEO_FIMC_MIPI=y
+# CONFIG_VIDEO_FIMC_MIPI_IRQ_DEBUG is not set
+CONFIG_VIDEO_FIMC_DMA_AUTO=y
+# CONFIG_VIDEO_FIMC_FIFO is not set
+CONFIG_VIDEO_TVOUT=y
+CONFIG_VIDEO_TVOUT_2CH_AUDIO=y
+# CONFIG_VIDEO_TVOUT_5_1CH_AUDIO is not set
+# CONFIG_HDMI_CEC is not set
+CONFIG_HDMI_EARJACK_MUTE=y
+CONFIG_HDMI_HPD=y
+# CONFIG_HDMI_CONTROLLED_BY_EXT_IC is not set
+# CONFIG_HDMI_TX_STRENGTH is not set
+CONFIG_HDMI_SWITCH_HPD=y
+# CONFIG_ANALOG_TVENC is not set
+CONFIG_TV_FB=y
+CONFIG_USER_ALLOC_TVOUT=y
+CONFIG_USE_TVOUT_CMA=y
+# CONFIG_LSI_HDMI_AUDIO_CH_EVENT is not set
+# CONFIG_TV_DEBUG is not set
+CONFIG_VIDEO_MFC5X=y
+CONFIG_VIDEO_MFC_MAX_INSTANCE=4
+CONFIG_VIDEO_MFC_MEM_PORT_COUNT=2
+# CONFIG_VIDEO_MFC5X_DEBUG is not set
+CONFIG_USE_MFC_CMA=y
+CONFIG_VIDEO_MALI400MP_UMP=y
+# CONFIG_MALI_DED_ONLY is not set
+# CONFIG_MALI_DED_MMU is not set
+CONFIG_MALI_OSMEM_ONLY=y
+# CONFIG_MALI_DED_OSMEM is not set
+# CONFIG_UMP_DED_ONLY is not set
+CONFIG_UMP_OSMEM_ONLY=y
+# CONFIG_UMP_VCM_ONLY is not set
+CONFIG_UMP_MEM_SIZE=1024
+CONFIG_MALI_UMP_R2P4_LSI=y
+# CONFIG_MALI_UMP_R3P1_LSI is not set
+# CONFIG_VIDEO_MALI400MP_UMP_DEBUG is not set
+# CONFIG_VIDEO_MALI400MP_STREAMLINE_PROFILING is not set
+CONFIG_VIDEO_MALI400MP_DVFS=y
+CONFIG_VIDEO_FIMG2D=y
+# CONFIG_VIDEO_FIMG2D_DEBUG is not set
+CONFIG_VIDEO_FIMG2D3X=y
+# CONFIG_VIDEO_FIMG2D3X_DEBUG is not set
+CONFIG_VIDEO_JPEG=y
+# CONFIG_VIDEO_JPEG_DEBUG is not set
+
+#
+# Reserved memory configurations
+#
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMC0=12288
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMC1=32768
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMC2=25600
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMC3=7168
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_MFC0=18432
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_MFC1=28672
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_JPEG=20480
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_TVOUT=16384
+# CONFIG_VIDEO_EXYNOS is not set
+# CONFIG_V4L_MEM2MEM_DRIVERS is not set
+
+#
+# Mhl(sii9244) device support
+#
+CONFIG_SAMSUNG_MHL=y
+# CONFIG_SAMSUNG_USE_11PIN_CONNECTOR is not set
+# CONFIG_SAMSUNG_SMARTDOCK is not set
+CONFIG_SAMSUNG_WORKAROUND_HPD_GLANCE=y
+# CONFIG_SAMSUNG_MHL_UNPOWERED is not set
+# CONFIG_RADIO_ADAPTERS is not set
+# CONFIG_TDMB is not set
+# CONFIG_ISDBT is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+# CONFIG_ION is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_WMT_GE_ROPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_S5P=y
+# CONFIG_FB_S5P_SYSMMU is not set
+CONFIG_FB_S5P_SPLASH_SCREEN=y
+# CONFIG_FB_S5P_LCD_INIT is not set
+# CONFIG_FB_S5P_DEBUG is not set
+CONFIG_FB_S5P_VSYNC_THREAD=y
+# CONFIG_FB_S5P_TRACE_UNDERRUN is not set
+CONFIG_FB_S5P_DEFAULT_WINDOW=2
+CONFIG_FB_S5P_NR_BUFFERS=2
+# CONFIG_FB_S5P_VIRTUAL is not set
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMD=32000
+CONFIG_FB_S5P_MDNIE=y
+# CONFIG_FB_MDNIE_PWM is not set
+CONFIG_FB_S5P_MIPI_DSIM=y
+CONFIG_FB_BGRA_ORDER=y
+# CONFIG_FB_RGBA_ORDER is not set
+# CONFIG_FB_S5P_LD9040 is not set
+# CONFIG_FB_S5P_LMS501XX is not set
+# CONFIG_FB_S5P_DUMMY_MIPI_LCD is not set
+CONFIG_FB_S5P_S6E8AA0=y
+# CONFIG_FB_S5P_EA8061 is not set
+# CONFIG_FB_S5P_S6EVR02 is not set
+# CONFIG_FB_S5P_S6D6AA1 is not set
+# CONFIG_FB_S5P_NT71391 is not set
+CONFIG_S6E8AA0_AMS529HA01=y
+# CONFIG_S6E8AA0_AMS480GYXX is not set
+# CONFIG_S6E8AA0_AMS465XX is not set
+# CONFIG_AID_DIMMING is not set
+# CONFIG_LCD_REVERSE is not set
+# CONFIG_FB_S5P_EXTDSP is not set
+# CONFIG_S5P_DSIM_SWITCHABLE_DUAL_LCD is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_TMIO is not set
+# CONFIG_FB_S3C is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+# CONFIG_LCD_L4F00242T03 is not set
+# CONFIG_LCD_LMS283GF05 is not set
+# CONFIG_LCD_LTV350QV is not set
+# CONFIG_LCD_TDO24M is not set
+# CONFIG_LCD_VGG2432A4 is not set
+# CONFIG_LCD_PLATFORM is not set
+# CONFIG_LCD_S6E63M0 is not set
+# CONFIG_LCD_MIPI_S6E63M0 is not set
+# CONFIG_LCD_MIPI_S6E8AB0 is not set
+# CONFIG_LCD_MIPI_TC358764 is not set
+# CONFIG_LCD_LD9040 is not set
+# CONFIG_LCD_WA101S is not set
+# CONFIG_LCD_LTE480WV is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_GENERIC is not set
+# CONFIG_BACKLIGHT_PWM is not set
+# CONFIG_BACKLIGHT_ADP8860 is not set
+# CONFIG_BACKLIGHT_ADP8870 is not set
+# CONFIG_BACKLIGHT_LP855X is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+# CONFIG_LOGO is not set
+CONFIG_SOUND=y
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_HWDEP=y
+CONFIG_SND_JACK=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_HRTIMER is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+# CONFIG_SND_SUPPORT_OLD_API is not set
+# CONFIG_SND_VERBOSE_PROCFS is not set
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_ARM is not set
+# CONFIG_SND_SPI is not set
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_6FIRE is not set
+CONFIG_SND_SOC=y
+# CONFIG_SND_SOC_CACHE_LZO is not set
+CONFIG_SND_SOC_SAMSUNG=y
+CONFIG_SND_SAMSUNG_I2S=y
+CONFIG_SND_SOC_U1_MC1N2=y
+# CONFIG_SND_SOC_SAMSUNG_USE_DMA_WRAPPER is not set
+CONFIG_SND_SOC_SAMSUNG_I2S_SEC=y
+# CONFIG_SND_SAMSUNG_NORMAL is not set
+# CONFIG_SND_SAMSUNG_LP is not set
+CONFIG_SND_SAMSUNG_ALP=y
+# CONFIG_SND_SAMSUNG_RP is not set
+CONFIG_AUDIO_SAMSUNG_MEMSIZE_SRP=1024
+# CONFIG_SND_SAMSUNG_RP_DEBUG is not set
+# CONFIG_SND_SAMSUNG_I2S_MASTER is not set
+# CONFIG_SND_DUOS_MODEM_SWITCH is not set
+# CONFIG_SND_USE_SUB_MIC is not set
+# CONFIG_SND_USE_THIRD_MIC is not set
+# CONFIG_SND_USE_STEREO_SPEAKER is not set
+# CONFIG_SND_USE_LINEOUT_SWITCH is not set
+# CONFIG_SND_USE_MUIC_SWITCH is not set
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_MC1N2=y
+CONFIG_SND_SOC_USE_EXTERNAL_MIC_BIAS=y
+# CONFIG_SND_SOC_MC1N2_DEBUG is not set
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=y
+# CONFIG_HID_ACRUX is not set
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+# CONFIG_HID_PRODIKEYS is not set
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DRAGONRISE=y
+# CONFIG_DRAGONRISE_FF is not set
+# CONFIG_HID_EMS_FF is not set
+CONFIG_HID_ELECOM=y
+CONFIG_HID_EZKEY=y
+# CONFIG_HID_KEYTOUCH is not set
+CONFIG_HID_KYE=y
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+CONFIG_HID_GYRATION=y
+# CONFIG_HID_TWINHAN is not set
+CONFIG_HID_KENSINGTON=y
+# CONFIG_HID_LCPOWER is not set
+CONFIG_HID_LOGITECH=y
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+# CONFIG_LOGIG940_FF is not set
+# CONFIG_LOGIWII_FF is not set
+CONFIG_HID_MAGICMOUSE=y
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+# CONFIG_HID_MULTITOUCH is not set
+CONFIG_HID_NTRIG=y
+CONFIG_HID_ORTEK=y
+CONFIG_HID_PANTHERLORD=y
+# CONFIG_PANTHERLORD_FF is not set
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_PICOLCD=y
+# CONFIG_HID_PICOLCD_FB is not set
+# CONFIG_HID_PICOLCD_BACKLIGHT is not set
+# CONFIG_HID_PICOLCD_LCD is not set
+# CONFIG_HID_PICOLCD_LEDS is not set
+CONFIG_HID_QUANTA=y
+CONFIG_HID_ROCCAT=y
+CONFIG_HID_ROCCAT_COMMON=y
+# CONFIG_HID_ROCCAT_ARVO is not set
+CONFIG_HID_ROCCAT_KONE=y
+# CONFIG_HID_ROCCAT_KONEPLUS is not set
+# CONFIG_HID_ROCCAT_KOVAPLUS is not set
+# CONFIG_HID_ROCCAT_PYRA is not set
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SUNPLUS=y
+CONFIG_HID_GREENASIA=y
+# CONFIG_GREENASIA_FF is not set
+CONFIG_HID_SMARTJOYPLUS=y
+# CONFIG_SMARTJOYPLUS_FF is not set
+CONFIG_HID_TOPSEED=y
+CONFIG_HID_THRUSTMASTER=y
+# CONFIG_THRUSTMASTER_FF is not set
+CONFIG_HID_WACOM=y
+# CONFIG_HID_WACOM_POWER_SUPPLY is not set
+CONFIG_HID_ZEROPLUS=y
+# CONFIG_ZEROPLUS_FF is not set
+CONFIG_HID_ZYDACRON=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB_ARCH_HAS_XHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_SUSPEND=y
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_HOST_COMPLIANT_TEST is not set
+CONFIG_USB_HOST_NOTIFY=y
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_XHCI_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+CONFIG_USB_EHCI_S5P=y
+CONFIG_USB_S5P_HSIC0=y
+CONFIG_USB_S5P_HSIC1=y
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+CONFIG_USB_S3C_OTG_HOST=y
+# CONFIG_USB_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+CONFIG_USB_PRINTER=y
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+# CONFIG_USB_UAS is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_QCOM_DIAG_BRIDGE is not set
+# CONFIG_USB_QCOM_MDM_BRIDGE is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_FUSB300 is not set
+# CONFIG_USB_GADGET_R8A66597 is not set
+CONFIG_USB_GADGET_S3C_OTGD=y
+# CONFIG_USB_GADGET_PXA_U2O is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+
+#
+# NOTE: S3C OTG device role enables the controller driver below
+#
+CONFIG_USB_S3C_OTGD=y
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_G_NCM is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FUNCTIONFS is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_MASS_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_G_SLP is not set
+CONFIG_USB_G_ANDROID=y
+CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE=y
+CONFIG_USB_ANDROID_SAMSUNG_MTP=y
+CONFIG_USB_DUN_SUPPORT=y
+# CONFIG_USB_ANDROID is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+# CONFIG_USB_G_NOKIA is not set
+# CONFIG_USB_G_MULTI is not set
+# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_DBGP is not set
+# CONFIG_USB_G_WEBCAM is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_OTG_WAKELOCK is not set
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ULPI is not set
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_UNSAFE_RESUME=y
+CONFIG_MMC_CLKGATE=y
+CONFIG_MMC_EMBEDDED_SDIO=y
+# CONFIG_MMC_PARANOID_SD_INIT is not set
+# CONFIG_MMC_NOT_USE_SANITIZE is not set
+# CONFIG_MMC_POLLING_WAIT_CMD23 is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=8
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_MMC_BLOCK_DEFERRED_RESUME is not set
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+# CONFIG_MMC_SELECTIVE_PACKED_CMD_POLICY is not set
+# CONFIG_MMC_CPRM is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+CONFIG_MMC_MSHCI=y
+# CONFIG_MMC_MSHCI_S3C_DMA_MAP is not set
+# CONFIG_MMC_MSHCI_ASYNC_OPS is not set
+# CONFIG_MMC_MSHCI_ENABLE_CACHE is not set
+CONFIG_MMC_SDHCI=y
+# CONFIG_MMC_SDHCI_PLTFM is not set
+CONFIG_MMC_SDHCI_S3C=y
+CONFIG_MMC_SDHCI_S3C_DMA=y
+# CONFIG_MMC_DW is not set
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_LEDS_SPFCW043 is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_LM3530 is not set
+# CONFIG_LEDS_PCA9532 is not set
+# CONFIG_LEDS_GPIO is not set
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_AN30259A is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_PWM is not set
+# CONFIG_LEDS_REGULATOR is not set
+CONFIG_LEDS_MAX8997=y
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_LT3593 is not set
+# CONFIG_LEDS_SWITCH is not set
+# CONFIG_LEDS_AAT1290A is not set
+# CONFIG_LEDS_TRIGGERS is not set
+
+#
+# LED Triggers
+#
+# CONFIG_NFC_DEVICES is not set
+CONFIG_SWITCH=y
+CONFIG_SWITCH_GPIO=y
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+CONFIG_RTC_INTF_ALARM=y
+CONFIG_RTC_INTF_ALARM_DEV=y
+# CONFIG_RTC_ALARM_BOOT is not set
+# CONFIG_RTC_POWER_OFF is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+CONFIG_RTC_DRV_MAX8997=y
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_HAVE_S3C_RTC=y
+CONFIG_RTC_DRV_S3C=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+CONFIG_STAGING=y
+# CONFIG_VIDEO_TM6000 is not set
+# CONFIG_USBIP_CORE is not set
+# CONFIG_PRISM2_USB is not set
+# CONFIG_ECHO is not set
+# CONFIG_BRCMUTIL is not set
+# CONFIG_ASUS_OLED is not set
+# CONFIG_R8712U is not set
+# CONFIG_TRANZPORT is not set
+
+#
+# Android
+#
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ANDROID_LOGGER=m
+# CONFIG_ANDROID_RAM_CONSOLE is not set
+CONFIG_ANDROID_TIMED_OUTPUT=y
+CONFIG_ANDROID_TIMED_GPIO=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+# CONFIG_POHMELFS is not set
+# CONFIG_LINE6_USB is not set
+# CONFIG_VT6656 is not set
+# CONFIG_IIO is not set
+# CONFIG_XVMALLOC is not set
+# CONFIG_ZRAM is not set
+# CONFIG_FB_SM7XX is not set
+# CONFIG_LIRC_STAGING is not set
+# CONFIG_EASYCAP is not set
+# CONFIG_MACH_C110_WESTBRIDGE_AST_PNAND_HAL is not set
+CONFIG_MACH_NO_WESTBRIDGE=y
+# CONFIG_ATH6K_LEGACY is not set
+# CONFIG_USB_ENESTORAGE is not set
+# CONFIG_BCM_WIMAX is not set
+# CONFIG_FT1000 is not set
+
+#
+# Speakup console speech
+#
+# CONFIG_SPEAKUP is not set
+# CONFIG_TOUCHSCREEN_CLEARPAD_TM1217 is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4 is not set
+
+#
+# Altera FPGA firmware download module
+#
+# CONFIG_ALTERA_STAPL is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_VIBETONZ=y
+CONFIG_MOTOR_DRV_MAX8997=y
+# CONFIG_MOTOR_DRV_ISA1200 is not set
+# CONFIG_MOTOR_DRV_DRV2603 is not set
+CONFIG_FM_RADIO=y
+CONFIG_J4FS=m
+CONFIG_FM_SI4709=m
+# CONFIG_FM_SI4705 is not set
+CONFIG_SENSORS_CORE=y
+CONFIG_SENSORS_AK8975C=y
+# CONFIG_SENSORS_AK8963C is not set
+CONFIG_SENSORS_BMP180=y
+# CONFIG_SENSORS_CM3663 is not set
+# CONFIG_SENSORS_PAS2M110 is not set
+# CONFIG_SENSORS_BMA254 is not set
+# CONFIG_SENSORS_TAOS is not set
+# CONFIG_SENSORS_GP2A is not set
+CONFIG_SENSORS_GP2A_ANALOG=y
+# CONFIG_SENSORS_CM36651 is not set
+# CONFIG_SENSORS_BH1721 is not set
+# CONFIG_SENSORS_AL3201 is not set
+CONFIG_SENSORS_K3DH=y
+CONFIG_SENSORS_K3G=y
+# CONFIG_SENSORS_LSM330DLC is not set
+# CONFIG_SENSORS_LPS331 is not set
+# CONFIG_SENSORS_SYSFS is not set
+# CONFIG_SENSORS_SSP is not set
+# CONFIG_SENSORS_SSP_LSM330 is not set
+# CONFIG_SENSORS_SSP_AK8963C is not set
+# CONFIG_SENSORS_SSP_CM36651 is not set
+# CONFIG_SENSORS_SSP_BMP182 is not set
+# CONFIG_SENSORS_SSP_AT32UC3L0128 is not set
+# CONFIG_SENSORS_SSP_SENSORHUB is not set
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_SAMSUNG_PHONE_SVNET is not set
+CONFIG_ACCESSORY=y
+# CONFIG_30PIN_CONN is not set
+# CONFIG_MHL_SII9234 is not set
+# CONFIG_SEC_KEYBOARD_DOCK is not set
+# CONFIG_HPD_PULL is not set
+# CONFIG_SAMSUNG_MHL_9290 is not set
+# CONFIG_IR_REMOCON is not set
+# CONFIG_EXTCON is not set
+# CONFIG_BARCODE_EMUL is not set
+CONFIG_IOMMU_SUPPORT=y
+# CONFIG_FELICA is not set
+# CONFIG_AUTHENTEC_VPNCLIENT_INTERCEPTOR is not set
+# CONFIG_J4FS_USE_XSR is not set
+# CONFIG_J4FS_USE_FSR is not set
+CONFIG_J4FS_USE_MOVI=y
+CONFIG_J4FS_DEVNAME="/dev/block/mmcblk0p4"
+CONFIG_J4FS_PAGE_SHIFT=11
+CONFIG_J4FS_BLOCK_COUNT=20
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_USE_FOR_EXT23=y
+# CONFIG_EXT4_FS_XATTR is not set
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+# CONFIG_DNOTIFY is not set
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=y
+# CONFIG_CUSE is not set
+CONFIG_GENERIC_ACL=y
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+# CONFIG_PROC_SEC_MEMINFO is not set
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+CONFIG_ECRYPT_FS=y
+CONFIG_WTL_ENCRYPTION_FILTER=y
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+# CONFIG_NFS_FS is not set
+# CONFIG_NFSD is not set
+# CONFIG_CEPH_FS is not set
+CONFIG_CIFS=y
+# CONFIG_CIFS_STATS is not set
+# CONFIG_CIFS_WEAK_PW_HASH is not set
+# CONFIG_CIFS_UPCALL is not set
+# CONFIG_CIFS_XATTR is not set
+# CONFIG_CIFS_DEBUG2 is not set
+# CONFIG_CIFS_DFS_UPCALL is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+
+#
+# Kernel hacking
+#
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_HARDLOCKUP_DETECTOR is not set
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SLUB_STATS is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_STACKTRACE is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_MEMORY_INIT is not set
+CONFIG_FRAME_POINTER=y
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+CONFIG_RCU_CPU_STALL_VERBOSE=y
+# CONFIG_LKDTM is not set
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_STRICT_DEVMEM is not set
+# CONFIG_ARM_UNWIND is not set
+CONFIG_DEBUG_USER=y
+# CONFIG_OC_ETM is not set
+CONFIG_DEBUG_S3C_UART=1
+# CONFIG_CACHE_PERF is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+CONFIG_KEYS_DEBUG_PROC_KEYS=y
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_FIPS_INTEG_OFFSET=0x20000000
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_CRYPTO_MANAGER_TESTS=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_GHASH is not set
+CONFIG_CRYPTO_MD4=y
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA256=y
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_TWOFISH_COMMON=y
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_S5P_DEV_ACE is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+# CONFIG_XZ_DEC is not set
+# CONFIG_XZ_DEC_BCJ is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=y
+CONFIG_TEXTSEARCH_BM=y
+CONFIG_TEXTSEARCH_FSM=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_DMA=y
+CONFIG_CPU_RMAP=y
+CONFIG_NLATTR=y
+# CONFIG_AVERAGE is not set
diff -urNp Kernel/arch/arm/configs/q1_speedmod_defconfig_c.o.h. HelloWorld-Renew-v1.0-n7000-jb/arch/arm/configs/q1_speedmod_defconfig_c.o.h.
--- Kernel/arch/arm/configs/q1_speedmod_defconfig_c.o.h.	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/arch/arm/configs/q1_speedmod_defconfig_c.o.h.	2013-05-02 08:50:07.237587115 +0200
@@ -0,0 +1,3176 @@
+#
+# Automatically generated make config: don't edit
+# Linux/arm 3.0.31-1103517 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_HAVE_PWM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+# CONFIG_ARCH_USES_GETTIMEOFFSET is not set
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_NO_IOPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_LOCKBREAK=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPUFREQ=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_ARM_PATCH_PHYS_VIRT=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_HAVE_IRQ_WORK=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE="/usr/local/arm/arm-eabi-4.4.3/bin/arm-eabi-"
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_FHANDLE is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_HAVE_SPARSE_IRQ=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_IRQ_CHIP=y
+# CONFIG_SPARSE_IRQ is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_PREEMPT_RCU=y
+CONFIG_PREEMPT_RCU=y
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_BOOST is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=18
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_DEBUG=y
+CONFIG_CGROUP_FREEZER=y
+# CONFIG_CGROUP_DEVICE is not set
+# CONFIG_CPUSETS is not set
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+# CONFIG_CGROUP_MEM_RES_CTLR is not set
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_RT_GROUP_SCHED=y
+# CONFIG_BLK_CGROUP is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_INITRAMFS_ROOT_UID=0
+CONFIG_INITRAMFS_ROOT_GID=0
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_INITRAMFS_COMPRESSION_NONE is not set
+CONFIG_INITRAMFS_COMPRESSION_GZIP=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+# CONFIG_CC_CHECK_WARNING_STRICTLY is not set
+CONFIG_LTO_MENU=y
+# CONFIG_LTO_DISABLE is not set
+CONFIG_LTO=y
+# CONFIG_LTO_DEBUG is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_PANIC_TIMEOUT=1
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_HOTPLUG=y
+# CONFIG_PRINTK is not set
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_ASHMEM=y
+# CONFIG_AIO is not set
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+# CONFIG_PERF_EVENTS is not set
+# CONFIG_PERF_COUNTERS is not set
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_SLUB_DEBUG is not set
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_STOP_MACHINE=y
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_IOSCHED_ROW=y
+CONFIG_IOSCHED_SIO=y
+CONFIG_IOSCHED_VR=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_ROW is not set
+# CONFIG_DEFAULT_SIO is not set
+# CONFIG_DEFAULT_VR is not set
+CONFIG_DEFAULT_NOOP=y
+CONFIG_DEFAULT_IOSCHED="noop"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_SPIN_UNLOCK is not set
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_READ_UNLOCK is not set
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQ is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_WRITE_UNLOCK is not set
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CNS3XXX is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_MXS is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_NUC93X is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P64X0 is not set
+# CONFIG_ARCH_S5PC100 is not set
+# CONFIG_ARCH_S5PV210 is not set
+CONFIG_ARCH_EXYNOS=y
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_TCC_926 is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_VT8500 is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+CONFIG_PLAT_SAMSUNG=y
+
+#
+# Base Address for SFR mapping
+#
+CONFIG_S3C_ADDR_BASE=0xFB000000
+
+#
+# Boot options
+#
+# CONFIG_S3C_BOOT_ERROR_RESET is not set
+CONFIG_S3C_BOOT_UART_FORCE_FIFO=y
+CONFIG_S3C_LOWLEVEL_UART_PORT=2
+CONFIG_SAMSUNG_CLKSRC=y
+CONFIG_SAMSUNG_IRQ_VIC_TIMER=y
+CONFIG_SAMSUNG_IRQ_UART=y
+CONFIG_SAMSUNG_GPIOLIB_4BIT=y
+CONFIG_S3C_GPIO_CFG_S3C24XX=y
+CONFIG_S3C_GPIO_CFG_S3C64XX=y
+CONFIG_S3C_GPIO_PULL_UPDOWN=y
+CONFIG_S5P_GPIO_DRVSTR=y
+CONFIG_SAMSUNG_GPIO_EXTRA=0
+CONFIG_S3C_GPIO_SPACE=0
+CONFIG_S3C_GPIO_TRACK=y
+CONFIG_S3C_ADC=y
+CONFIG_S3C_DEV_ADC=y
+# CONFIG_S3C_DEV_ADC1 is not set
+CONFIG_S3C_DEV_HSMMC2=y
+CONFIG_S3C_DEV_HSMMC3=y
+CONFIG_EXYNOS4_DEV_MSHC=y
+CONFIG_S3C_DEV_I2C1=y
+CONFIG_S3C_DEV_I2C3=y
+CONFIG_S3C_DEV_I2C5=y
+CONFIG_S3C_DEV_I2C6=y
+CONFIG_S3C_DEV_I2C7=y
+CONFIG_S3C_DEV_I2C8_EMUL=y
+CONFIG_S3C_DEV_I2C9_EMUL=y
+CONFIG_S3C_DEV_I2C11_EMUL=y
+CONFIG_S3C_DEV_I2C14_EMUL=y
+CONFIG_S3C_DEV_I2C16_EMUL=y
+# CONFIG_S3C_DEV_I2C17_EMUL is not set
+CONFIG_S3C_DEV_WDT=y
+CONFIG_S3C_DEV_RTC=y
+CONFIG_SAMSUNG_DEV_ADC=y
+CONFIG_SAMSUNG_DEV_TS=y
+CONFIG_SAMSUNG_DEV_TS1=y
+CONFIG_S3C24XX_PWM=y
+CONFIG_S3C_PL330_DMA=y
+# CONFIG_DMA_M2M_TEST is not set
+
+#
+# Power management
+#
+# CONFIG_SAMSUNG_PM_DEBUG is not set
+# CONFIG_SAMSUNG_PM_CHECK is not set
+
+#
+# Power Domain
+#
+CONFIG_SAMSUNG_PD=y
+CONFIG_PLAT_S5P=y
+CONFIG_S5P_GPIO_INT=y
+CONFIG_S5P_SYSTEM_MMU=y
+# CONFIG_S5P_SYSTEM_MMU_REFCOUNT is not set
+# CONFIG_S5P_SYSTEM_MMU_DEBUG is not set
+CONFIG_IOVMM=y
+CONFIG_IOMMU_EXYNOS4_API=y
+CONFIG_S3C_DEV_FIMC=y
+CONFIG_S5P_DEV_MFC=y
+CONFIG_S5P_DEV_FIMD0=y
+CONFIG_S5P_DEV_TVOUT=y
+CONFIG_S5P_DEV_FIMG2D=y
+CONFIG_S5P_DEV_CSIS=y
+CONFIG_S5P_DEV_JPEG=y
+CONFIG_S5P_DEV_USB_EHCI=y
+CONFIG_S5P_DEV_FIMD_S5P=y
+CONFIG_S5P_DEV_USBGADGET=y
+CONFIG_S5P_MEM_CMA=y
+CONFIG_S5P_DEV_MIPI_DSI=y
+# CONFIG_S5P_BTS is not set
+# CONFIG_S3C_DEV_TSI is not set
+CONFIG_ARCH_EXYNOS4=y
+# CONFIG_ARCH_EXYNOS5 is not set
+CONFIG_CPU_EXYNOS4210=y
+CONFIG_S5PV310_HI_ARMCLK_THAN_1_2GHZ=y
+CONFIG_EXYNOS4_PM=y
+CONFIG_EXYNOS4_CPUIDLE=y
+CONFIG_EXYNOS4_LOWPWR_IDLE=y
+CONFIG_EXYNOS_MCT=y
+CONFIG_EXYNOS4_SETUP_FIMD0=y
+CONFIG_EXYNOS_DEV_PD=y
+CONFIG_EXYNOS4_SETUP_I2C1=y
+CONFIG_EXYNOS4_SETUP_I2C3=y
+CONFIG_EXYNOS4_SETUP_I2C5=y
+CONFIG_EXYNOS4_SETUP_I2C6=y
+CONFIG_EXYNOS4_SETUP_I2C7=y
+CONFIG_EXYNOS4_SETUP_MFC=y
+CONFIG_EXYNOS4_SETUP_SDHCI=y
+CONFIG_EXYNOS4_SETUP_SDHCI_GPIO=y
+CONFIG_EXYNOS4_SETUP_MSHCI=y
+CONFIG_EXYNOS4_SETUP_MSHCI_GPIO=y
+CONFIG_EXYNOS4_SETUP_FIMC0=y
+CONFIG_EXYNOS4_SETUP_FIMC1=y
+CONFIG_EXYNOS4_SETUP_FIMC2=y
+CONFIG_EXYNOS4_SETUP_FIMC3=y
+CONFIG_EXYNOS4_SETUP_USB_PHY=y
+CONFIG_EXYNOS4_SETUP_CSIS=y
+CONFIG_EXYNOS4_SETUP_FB_S5P=y
+CONFIG_EXYNOS4_SETUP_TVOUT=y
+CONFIG_EXYNOS4_SETUP_THERMAL=y
+# CONFIG_EXYNOS_SETUP_THERMAL is not set
+CONFIG_EXYNOS4_SETUP_MIPI_DSI=y
+# CONFIG_EXYNOS4_ENABLE_CLOCK_DOWN is not set
+CONFIG_EXYNOS4_CPUFREQ=y
+# CONFIG_EXYNOS4210_1200MHZ_SUPPORT is not set
+CONFIG_EXYNOS4210_1400MHZ_SUPPORT=y
+
+#
+# Support dynamic CPU Hotplug
+#
+CONFIG_EXYNOS_PM_HOTPLUG=y
+# CONFIG_STAND_ALONE_POLICY is not set
+# CONFIG_LEGACY_HOTPLUG_POLICY is not set
+CONFIG_WITH_DVFS_POLICY=y
+# CONFIG_DVFS_NR_RUNNING_POLICY is not set
+# CONFIG_NR_RUNNING_POLICY is not set
+
+#
+# Busfreq Model
+#
+CONFIG_BUSFREQ=y
+CONFIG_BUSFREQ_QOS=y
+# CONFIG_BUSFREQ_OPP is not set
+# CONFIG_DISPFREQ_OPP is not set
+# CONFIG_DEVFREQ_BUS is not set
+# CONFIG_BUSFREQ_QOS_NONE is not set
+# CONFIG_BUSFREQ_QOS_1024X600 is not set
+# CONFIG_BUSFREQ_QOS_1280X720 is not set
+CONFIG_BUSFREQ_QOS_1280X800=y
+# CONFIG_BUSFREQ_DEBUG is not set
+CONFIG_BUSFREQ_L2_160M=y
+CONFIG_SEC_THERMISTOR=y
+# CONFIG_SEC_SUBTHERMISTOR is not set
+# CONFIG_EXYNOS_SYSREG_PM is not set
+# CONFIG_ANDROID_WIP is not set
+# CONFIG_COMPACTION_RETRY is not set
+
+#
+# EXYNOS4 Machines
+#
+# CONFIG_MACH_SMDKC210 is not set
+# CONFIG_MACH_SMDKV310 is not set
+# CONFIG_MACH_ARMLEX4210 is not set
+# CONFIG_MACH_UNIVERSAL_C210 is not set
+# CONFIG_MACH_NURI is not set
+# CONFIG_MACH_U1_NA_SPR is not set
+# CONFIG_MACH_U1_NA_USCC is not set
+CONFIG_MACH_U1=y
+# CONFIG_MACH_U1_BD is not set
+CONFIG_MACH_Q1_BD=y
+# CONFIG_TARGET_LOCALE_NAATT_TEMP is not set
+# CONFIG_MACH_PX is not set
+CONFIG_PANEL_U1=y
+# CONFIG_PANEL_U1_NA_SPR is not set
+CONFIG_TARGET_LOCALE_EUR=y
+# CONFIG_TARGET_LOCALE_LTN is not set
+# CONFIG_TARGET_LOCALE_KOR is not set
+# CONFIG_TARGET_LOCALE_P2EUR_TEMP is not set
+# CONFIG_TARGET_LOCALE_P2TMO_TEMP is not set
+# CONFIG_TARGET_LOCALE_NA is not set
+# CONFIG_TARGET_LOCALE_EUR_U1_NFC is not set
+# CONFIG_TARGET_LOCALE_NTT is not set
+# CONFIG_TARGET_LOCALE_JPN is not set
+# CONFIG_TARGET_LOCALE_CHN is not set
+# CONFIG_TARGET_LOCALE_USA is not set
+# CONFIG_MACH_SMDK4X12 is not set
+# CONFIG_MACH_MIDAS is not set
+# CONFIG_MIDAS_COMMON_BD is not set
+# CONFIG_P4NOTE_00_BD is not set
+# CONFIG_GC1_00_BD is not set
+# CONFIG_T0_00_BD is not set
+# CONFIG_KONA_00_BD is not set
+# CONFIG_T0_04_BD is not set
+# CONFIG_MACH_T0_GODIVA_LTE is not set
+# CONFIG_MACH_T0_VOLTE_Q is not set
+# CONFIG_IRON_BD is not set
+# CONFIG_GRANDE_BD is not set
+# CONFIG_WRITEBACK_ENABLED is not set
+# CONFIG_EXYNOS_SOUND_PLATFORM_DATA is not set
+# CONFIG_JACK_FET is not set
+# CONFIG_JACK_GROUND_DET is not set
+CONFIG_SAMSUNG_ANALOG_UART_SWITCH=1
+# CONFIG_EXYNOS5_DEV_BTS is not set
+
+#
+# MMC/SD slot setup
+#
+
+#
+# SELECT SYNOPSYS CONTROLLER INTERFACE DRIVER
+#
+CONFIG_EXYNOS4_MSHC_MPLL_40MHZ=y
+# CONFIG_EXYNOS4_MSHC_VPLL_46MHZ is not set
+# CONFIG_EXYNOS4_MSHC_EPLL_45MHZ is not set
+# CONFIG_EXYNOS4_MSHC_SUPPORT_PQPRIME_EPLL is not set
+
+#
+# Use 8-bit bus width
+#
+CONFIG_EXYNOS4_MSHC_8BIT=y
+# CONFIG_EXYNOS4_SDHCI_CH2_8BIT is not set
+
+#
+# Use DDR
+#
+CONFIG_EXYNOS4_MSHC_DDR=y
+
+#
+# Miscellaneous drivers
+#
+# CONFIG_WAKEUP_ASSIST is not set
+
+#
+# Debugging Feature
+#
+# CONFIG_SEC_DEBUG is not set
+CONFIG_EHCI_IRQ_DISTRIBUTION=y
+
+#
+# Samsung Modem Feature
+#
+# CONFIG_LTE_VIA_SWITCH is not set
+# CONFIG_SEC_DUAL_MODEM_MODE is not set
+# CONFIG_SEC_MODEM_M0_C2C is not set
+# CONFIG_SEC_MODEM_M0 is not set
+# CONFIG_SEC_MODEM_M0_CTC is not set
+# CONFIG_SEC_MODEM_T0_CU_DUOS is not set
+# CONFIG_SEC_MODEM_T0_OPEN_DUOS is not set
+# CONFIG_SEC_MODEM_M0_GRANDECTC is not set
+# CONFIG_SEC_MODEM_M1 is not set
+# CONFIG_SEC_MODEM_C1 is not set
+# CONFIG_SEC_MODEM_C1_LGT is not set
+# CONFIG_SEC_MODEM_M2 is not set
+CONFIG_SEC_MODEM_U1=y
+# CONFIG_SEC_MODEM_Q1_TD is not set
+# CONFIG_SEC_MODEM_U1_LGT is not set
+# CONFIG_SEC_MODEM_GAIA is not set
+# CONFIG_SEC_MODEM_IRON is not set
+# CONFIG_SEC_MODEM_P8LTE is not set
+# CONFIG_SEC_MODEM_T0_TD_DUAL is not set
+# CONFIG_SEC_MODEM_U1_SPR is not set
+# CONFIG_SEC_MODEM_GODIVA2 is not set
+
+#
+# Connectivity Feature
+#
+# CONFIG_GPS_BRCM_475X is not set
+# CONFIG_BT_CSR8811 is not set
+CONFIG_BT_BCM4330=y
+# CONFIG_BT_BCM4334 is not set
+# CONFIG_BT_BCM43241 is not set
+CONFIG_BT_MGMT=y
+
+#
+# Qualcomm Modem Feature
+#
+# CONFIG_QC_MODEM is not set
+# CONFIG_MSM_SUBSYSTEM_RESTART is not set
+# CONFIG_QC_MODEM_MDM9X15 is not set
+# CONFIG_MDM_HSIC_PM is not set
+# CONFIG_EMI_ERROR_RECOVERY is not set
+# CONFIG_SIM_DETECT is not set
+CONFIG_USB_CDFS_SUPPORT=y
+CONFIG_SAMSUNG_PRODUCT_SHIP=y
+# CONFIG_CORESIGHT_ETM is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_V7=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_V7=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_TRUSTZONE is not set
+CONFIG_ARM_THUMB=y
+# CONFIG_ARM_THUMBEE is not set
+CONFIG_SWP_EMULATE=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_OUTER_CACHE=y
+CONFIG_OUTER_CACHE_SYNC=y
+CONFIG_CACHE_L2X0=y
+CONFIG_CACHE_PL310=y
+CONFIG_ARM_L1_CACHE_SHIFT=5
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+CONFIG_ARM_PLD_SIZE=32
+CONFIG_CPU_HAS_PMU=y
+# CONFIG_ARM_ERRATA_430973 is not set
+# CONFIG_ARM_ERRATA_458693 is not set
+# CONFIG_ARM_ERRATA_460075 is not set
+# CONFIG_ARM_ERRATA_742230 is not set
+# CONFIG_ARM_ERRATA_742231 is not set
+# CONFIG_PL310_ERRATA_588369 is not set
+# CONFIG_ARM_ERRATA_720789 is not set
+# CONFIG_ARM_ERRATA_720791 is not set
+CONFIG_PL310_ERRATA_727915=y
+CONFIG_ARM_ERRATA_743622=y
+CONFIG_ARM_ERRATA_751472=y
+CONFIG_ARM_ERRATA_753970=y
+CONFIG_ARM_ERRATA_754322=y
+# CONFIG_ARM_ERRATA_754327 is not set
+# CONFIG_ARM_ERRATA_761320 is not set
+# CONFIG_ARM_ERRATA_761171 is not set
+# CONFIG_ARM_ERRATA_762974 is not set
+# CONFIG_ARM_ERRATA_763722 is not set
+CONFIG_ARM_GIC=y
+CONFIG_PL330=y
+# CONFIG_FIQ_DEBUGGER is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+CONFIG_ARM_ERRATA_764369=y
+# CONFIG_PL310_ERRATA_769419 is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_SMP=y
+CONFIG_SMP_ON_UP=y
+CONFIG_ARM_CPU_TOPOLOGY=y
+CONFIG_SCHED_MC=y
+# CONFIG_SCHED_SMT is not set
+CONFIG_HAVE_ARM_SCU=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_NR_CPUS=2
+CONFIG_HOTPLUG_CPU=y
+CONFIG_LOCAL_TIMERS=y
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_HZ=200
+# CONFIG_THUMB2_KERNEL is not set
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_ARCH_SKIP_SECONDARY_CALIBRATE=y
+CONFIG_HIGHMEM=y
+# CONFIG_HIGHPTE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+# CONFIG_CLEANCACHE is not set
+CONFIG_CMA=y
+# CONFIG_CMA_DEVELOPEMENT is not set
+CONFIG_CMA_BEST_FIT=y
+# CONFIG_DEBUG_VMALLOC is not set
+# CONFIG_LOWMEM_CHECK is not set
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_CC_STACKPROTECTOR is not set
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+# CONFIG_ARM_FLUSH_CONSOLE_ON_RESTART is not set
+# CONFIG_VMWARE_MVP is not set
+
+#
+# Boot options
+#
+# CONFIG_USE_OF is not set
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_CMDLINE="console=ttySAC2,115200 consoleblank=0"
+CONFIG_CMDLINE_FROM_BOOTLOADER=y
+# CONFIG_CMDLINE_EXTEND is not set
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_AUTO_ZRELADDR is not set
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ADAPTIVE is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_PEGASUSQ=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_HYPER is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_LULZACTIVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_SMARTASS is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_SMARTASS2 is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_LAGFREE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+# CONFIG_CPU_FREQ_GOV_USERSPACE is not set
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+# CONFIG_CPU_FREQ_GOV_ONDEMAND_FLEXRATE is not set
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_GOV_INTERACTIVE=y
+# CONFIG_CPU_FREQ_GOV_ADAPTIVE is not set
+CONFIG_CPU_FREQ_GOV_PEGASUSQ=y
+CONFIG_CPU_FREQ_GOV_HYPER=y
+CONFIG_CPU_FREQ_GOV_LULZACTIVE=y
+CONFIG_CPU_FREQ_GOV_SMARTASS=y
+CONFIG_CPU_FREQ_GOV_SMARTASS2=y
+CONFIG_CPU_FREQ_GOV_LAGFREE=y
+# CONFIG_CPU_FREQ_GOV_SLP is not set
+# CONFIG_CPU_FREQ_DVFS_MONITOR is not set
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_MISC=y
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_PM_WATCHDOG_TIMEOUT=y
+# CONFIG_FAST_BOOT is not set
+CONFIG_HAS_WAKELOCK=y
+CONFIG_HAS_EARLYSUSPEND=y
+CONFIG_WAKELOCK=y
+CONFIG_WAKELOCK_STAT=y
+CONFIG_USER_WAKELOCK=y
+CONFIG_EARLYSUSPEND=y
+# CONFIG_NO_USER_SPACE_SCREEN_ACCESS_CONTROL is not set
+# CONFIG_CONSOLE_EARLYSUSPEND is not set
+CONFIG_FB_EARLYSUSPEND=y
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+CONFIG_PM_RUNTIME=y
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
+CONFIG_ARCH_HAS_OPP=y
+CONFIG_PM_OPP=y
+CONFIG_PM_RUNTIME_CLK=y
+# CONFIG_SUSPEND_TIME is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_XFRM_IPCOMP=y
+CONFIG_NET_KEY=y
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+# CONFIG_IP_FIB_TRIE_STATS is not set
+CONFIG_IP_MULTIPLE_TABLES=y
+# CONFIG_IP_ROUTE_MULTIPATH is not set
+# CONFIG_IP_ROUTE_VERBOSE is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+CONFIG_INET_ESP=y
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+CONFIG_IPV6_PRIVACY=y
+CONFIG_IPV6_ROUTER_PREF=y
+# CONFIG_IPV6_ROUTE_INFO is not set
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_IPV6_MIP6=y
+CONFIG_INET6_XFRM_TUNNEL=y
+CONFIG_INET6_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=y
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+CONFIG_IPV6_TUNNEL=y
+CONFIG_IPV6_MULTIPLE_TABLES=y
+# CONFIG_IPV6_SUBTREES is not set
+# CONFIG_IPV6_MROUTE is not set
+CONFIG_ANDROID_PARANOID_NETWORK=y
+CONFIG_NET_ACTIVITY_STATS=y
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_NETFILTER_NETLINK_QUEUE=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
+CONFIG_NF_CT_PROTO_DCCP=y
+CONFIG_NF_CT_PROTO_GRE=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_BROADCAST=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+# CONFIG_NF_CONNTRACK_SNMP is not set
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_NF_CONNTRACK_SANE=y
+# CONFIG_NF_CONNTRACK_SIP is not set
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_TPROXY=y
+CONFIG_NETFILTER_XTABLES=y
+
+#
+# Xtables combined modules
+#
+CONFIG_NETFILTER_XT_MARK=y
+CONFIG_NETFILTER_XT_CONNMARK=y
+
+#
+# Xtables targets
+#
+# CONFIG_NETFILTER_XT_TARGET_CHECKSUM is not set
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+# CONFIG_NETFILTER_XT_TARGET_CT is not set
+# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
+# CONFIG_NETFILTER_XT_TARGET_HL is not set
+# CONFIG_NETFILTER_XT_TARGET_IDLETIMER is not set
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+# CONFIG_NETFILTER_XT_TARGET_NOTRACK is not set
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+# CONFIG_NETFILTER_XT_TARGET_TEE is not set
+CONFIG_NETFILTER_XT_TARGET_TPROXY=y
+CONFIG_NETFILTER_XT_TARGET_TRACE=y
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+
+#
+# Xtables matches
+#
+# CONFIG_NETFILTER_XT_MATCH_ADDRTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+# CONFIG_NETFILTER_XT_MATCH_CPU is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
+# CONFIG_NETFILTER_XT_MATCH_ESP is not set
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_NETFILTER_XT_MATCH_HL=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+# CONFIG_NETFILTER_XT_MATCH_MULTIPORT is not set
+# CONFIG_NETFILTER_XT_MATCH_OSF is not set
+# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+# CONFIG_NETFILTER_XT_MATCH_RECENT is not set
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+# CONFIG_IP_SET is not set
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+# CONFIG_IP_NF_QUEUE is not set
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_REJECT_SKERR=y
+CONFIG_IP_NF_TARGET_LOG=y
+# CONFIG_IP_NF_TARGET_ULOG is not set
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_NF_NAT_PROTO_DCCP=y
+CONFIG_NF_NAT_PROTO_GRE=y
+CONFIG_NF_NAT_PROTO_UDPLITE=y
+CONFIG_NF_NAT_PROTO_SCTP=y
+CONFIG_NF_NAT_FTP=y
+CONFIG_NF_NAT_IRC=y
+CONFIG_NF_NAT_TFTP=y
+CONFIG_NF_NAT_AMANDA=y
+CONFIG_NF_NAT_PPTP=y
+CONFIG_NF_NAT_H323=y
+# CONFIG_NF_NAT_SIP is not set
+CONFIG_IP_NF_MANGLE=y
+# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
+# CONFIG_IP_NF_TARGET_ECN is not set
+# CONFIG_IP_NF_TARGET_TTL is not set
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IP_NF_ARP_MANGLE=y
+
+#
+# IPv6: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV6=y
+CONFIG_NF_CONNTRACK_IPV6=y
+# CONFIG_IP6_NF_QUEUE is not set
+CONFIG_IP6_NF_IPTABLES=y
+# CONFIG_IP6_NF_MATCH_AH is not set
+# CONFIG_IP6_NF_MATCH_EUI64 is not set
+# CONFIG_IP6_NF_MATCH_FRAG is not set
+# CONFIG_IP6_NF_MATCH_OPTS is not set
+# CONFIG_IP6_NF_MATCH_HL is not set
+# CONFIG_IP6_NF_MATCH_IPV6HEADER is not set
+# CONFIG_IP6_NF_MATCH_MH is not set
+# CONFIG_IP6_NF_MATCH_RT is not set
+# CONFIG_IP6_NF_TARGET_HL is not set
+CONFIG_IP6_NF_TARGET_LOG=y
+CONFIG_IP6_NF_FILTER=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+CONFIG_IP6_NF_TARGET_REJECT_SKERR=y
+CONFIG_IP6_NF_MANGLE=y
+CONFIG_IP6_NF_RAW=y
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+CONFIG_PHONET=y
+# CONFIG_IEEE802154 is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+# CONFIG_NET_SCH_CBQ is not set
+CONFIG_NET_SCH_HTB=y
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFB is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_DRR is not set
+# CONFIG_NET_SCH_MQPRIO is not set
+# CONFIG_NET_SCH_CHOKE is not set
+# CONFIG_NET_SCH_QFQ is not set
+CONFIG_NET_SCH_INGRESS=y
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+# CONFIG_NET_CLS_FW is not set
+CONFIG_NET_CLS_U32=y
+# CONFIG_CLS_U32_PERF is not set
+# CONFIG_CLS_U32_MARK is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_CLS_FLOW is not set
+# CONFIG_NET_CLS_CGROUP is not set
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_STACK=32
+# CONFIG_NET_EMATCH_CMP is not set
+# CONFIG_NET_EMATCH_NBYTE is not set
+CONFIG_NET_EMATCH_U32=y
+# CONFIG_NET_EMATCH_META is not set
+# CONFIG_NET_EMATCH_TEXT is not set
+CONFIG_NET_CLS_ACT=y
+CONFIG_NET_ACT_POLICE=y
+CONFIG_NET_ACT_GACT=y
+# CONFIG_GACT_PROB is not set
+CONFIG_NET_ACT_MIRRED=y
+# CONFIG_NET_ACT_IPT is not set
+# CONFIG_NET_ACT_NAT is not set
+# CONFIG_NET_ACT_PEDIT is not set
+# CONFIG_NET_ACT_SIMP is not set
+# CONFIG_NET_ACT_SKBEDIT is not set
+# CONFIG_NET_ACT_CSUM is not set
+# CONFIG_NET_CLS_IND is not set
+CONFIG_NET_SCH_FIFO=y
+# CONFIG_DCB is not set
+# CONFIG_DNS_RESOLVER is not set
+# CONFIG_BATMAN_ADV is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+CONFIG_BT=y
+CONFIG_BT_L2CAP=y
+CONFIG_BT_SCO=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+# CONFIG_BT_BNEP_MC_FILTER is not set
+# CONFIG_BT_BNEP_PROTO_FILTER is not set
+CONFIG_BT_HIDP=y
+
+#
+# Bluetooth device drivers
+#
+# CONFIG_BT_HCIBTUSB is not set
+# CONFIG_BT_HCIBTSDIO is not set
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_H4=y
+# CONFIG_BT_HCIUART_BCSP is not set
+# CONFIG_BT_HCIUART_ATH3K is not set
+# CONFIG_BT_HCIUART_LL is not set
+# CONFIG_BT_HCIBCM203X is not set
+# CONFIG_BT_HCIBPA10X is not set
+# CONFIG_BT_HCIBFUSB is not set
+# CONFIG_BT_HCIVHCI is not set
+# CONFIG_BT_MRVL is not set
+
+#
+# Bluetooth device drivers
+#
+
+#
+# Bluetooth device drivers
+#
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_CFG80211=y
+# CONFIG_NL80211_TESTMODE is not set
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+# CONFIG_CFG80211_REG_DEBUG is not set
+CONFIG_CFG80211_DEFAULT_PS=y
+# CONFIG_CFG80211_DEBUGFS is not set
+# CONFIG_CFG80211_INTERNAL_REGDB is not set
+CONFIG_CFG80211_WEXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+# CONFIG_LIB80211 is not set
+# CONFIG_CFG80211_ALLOW_RECONNECT is not set
+# CONFIG_MAC80211 is not set
+# CONFIG_WIMAX is not set
+CONFIG_RFKILL=y
+CONFIG_RFKILL_PM=y
+# CONFIG_RFKILL_INPUT is not set
+# CONFIG_RFKILL_REGULATOR is not set
+# CONFIG_RFKILL_GPIO is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+# CONFIG_DEVTMPFS is not set
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_DMA_SHARED_BUFFER is not set
+CONFIG_SYNC=y
+CONFIG_SW_SYNC=y
+CONFIG_SW_SYNC_USER=y
+CONFIG_DMA_CMA=y
+
+#
+# Default contiguous memory area size:
+#
+CONFIG_CMA_SIZE_MBYTES=16
+CONFIG_CMA_SIZE_SEL_MBYTES=y
+# CONFIG_CMA_SIZE_SEL_PERCENTAGE is not set
+# CONFIG_CMA_SIZE_SEL_MIN is not set
+# CONFIG_CMA_SIZE_SEL_MAX is not set
+CONFIG_CMA_ALIGNMENT=8
+CONFIG_CMA_AREAS=7
+# CONFIG_CONNECTOR is not set
+# CONFIG_MTD is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+
+#
+# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
+#
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=8192
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_SENSORS_LIS3LV02D is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_AD525X_DPOT is not set
+CONFIG_ANDROID_PMEM=y
+
+#
+# Reserved memory configurations
+#
+CONFIG_ANDROID_PMEM_MEMSIZE_PMEM=4096
+CONFIG_ANDROID_PMEM_MEMSIZE_PMEM_GPU1=4
+CONFIG_ANDROID_PMEM_MEMSIZE_PMEM_CAM=0
+# CONFIG_INTEL_MID_PTI is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_SENSORS_AK8975 is not set
+# CONFIG_SENSORS_AK8963 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_TI_DAC7512 is not set
+CONFIG_UID_STAT=y
+# CONFIG_BMP085 is not set
+# CONFIG_WL127X_RFKILL is not set
+# CONFIG_APANIC is not set
+# CONFIG_JACK_MON is not set
+# CONFIG_UART_SELECT is not set
+# CONFIG_SWITCH_DUAL_MODEM is not set
+# CONFIG_SWITCH_USB_PATH_AUTO is not set
+# CONFIG_WIMAX_CMC is not set
+CONFIG_SEC_DEV_JACK=y
+CONFIG_JACK_RESELECTOR_SUPPORT=y
+# CONFIG_MUIC_DET_JACK is not set
+# CONFIG_FM34_WE395 is not set
+# CONFIG_AUDIENCE_ES305 is not set
+# CONFIG_2MIC_FM34_WE395 is not set
+CONFIG_MUIC_MAX8997=y
+# CONFIG_MUIC_MAX8997_OVPUI is not set
+# CONFIG_USBHUB_USB3503 is not set
+# CONFIG_USBHUB_USB3503_OTG_CONN is not set
+# CONFIG_USBHUB_USB3803 is not set
+CONFIG_PN544=y
+# CONFIG_STMPE811_ADC is not set
+# CONFIG_MPU_SENSORS_MPU3050 is not set
+# CONFIG_MPU_SENSORS_MPU6050 is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_IWMC3200TOP is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+CONFIG_SEC_MODEM=y
+CONFIG_UMTS_MODEM_XMM6260=y
+# CONFIG_UMTS_MODEM_XMM6262 is not set
+# CONFIG_CDMA_MODEM_CBP71 is not set
+# CONFIG_CDMA_MODEM_CBP72 is not set
+# CONFIG_LTE_MODEM_CMC221 is not set
+# CONFIG_CDMA_MODEM_MDM6600 is not set
+# CONFIG_TDSCDMA_MODEM_SPRD8803 is not set
+# CONFIG_GSM_MODEM_ESC6270 is not set
+# CONFIG_CDMA_MODEM_QSC6085 is not set
+# CONFIG_LINK_DEVICE_MIPI is not set
+# CONFIG_LINK_DEVICE_DPRAM is not set
+# CONFIG_LINK_DEVICE_PLD is not set
+# CONFIG_LINK_DEVICE_USB is not set
+CONFIG_LINK_DEVICE_HSIC=y
+# CONFIG_LINK_DEVICE_C2C is not set
+# CONFIG_LINK_DEVICE_SPI is not set
+# CONFIG_WORKQUEUE_FRONT is not set
+# CONFIG_SIM_SLOT_SWITCH is not set
+# CONFIG_LTE_MODEM_CMC220 is not set
+# CONFIG_INTERNAL_MODEM_IF is not set
+CONFIG_FSYNC_CONTROL=y
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+CONFIG_CHR_DEV_SG=y
+# CONFIG_CHR_DEV_SCH is not set
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+CONFIG_MD=y
+# CONFIG_BLK_DEV_MD is not set
+CONFIG_BLK_DEV_DM=y
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_CRYPT=y
+# CONFIG_DM_SNAPSHOT is not set
+# CONFIG_DM_MIRROR is not set
+# CONFIG_DM_RAID is not set
+# CONFIG_DM_ZERO is not set
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_DELAY is not set
+# CONFIG_DM_UEVENT is not set
+# CONFIG_DM_FLAKEY is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_NETDEVICES=y
+# CONFIG_IFB is not set
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=y
+# CONFIG_VETH is not set
+# CONFIG_MII is not set
+# CONFIG_PHYLIB is not set
+# CONFIG_NET_ETHERNET is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+CONFIG_WLAN=y
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_USB_NET_RNDIS_WLAN is not set
+CONFIG_WIFI_CONTROL_FUNC=y
+# CONFIG_ATH_COMMON is not set
+CONFIG_BCM4330=y
+# CONFIG_BCM4334 is not set
+# CONFIG_BCM43241 is not set
+CONFIG_BCMDHD_FW_PATH="/system/etc/firmware/fw_bcmdhd.bin"
+CONFIG_BCMDHD_NVRAM_PATH="/system/etc/wifi/bcmdhd.cal"
+CONFIG_BROADCOM_WIFI_RESERVED_MEM=y
+CONFIG_WLAN_REGION_CODE=100
+# CONFIG_HOSTAP is not set
+# CONFIG_IWM is not set
+# CONFIG_LIBERTAS is not set
+# CONFIG_MWIFIEX is not set
+# CONFIG_LGUIWLAN is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_HSO is not set
+# CONFIG_USB_CDC_PHONET is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_WAN is not set
+
+#
+# CAIF transport drivers
+#
+CONFIG_PPP=y
+# CONFIG_PPP_MULTILINK is not set
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=y
+# CONFIG_PPP_SYNC_TTY is not set
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_MPPE=y
+# CONFIG_PPPOE is not set
+CONFIG_PPPOLAC=y
+CONFIG_PPPOPNS=y
+# CONFIG_SLIP is not set
+CONFIG_SLHC=y
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+# CONFIG_INPUT_SECBRIDGE is not set
+# CONFIG_INPUT_KEYRESET is not set
+# CONFIG_INPUT_FBSUSPEND is not set
+# CONFIG_INPUT_MPU6050 is not set
+# CONFIG_INPUT_MPU6050_POLLING is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+CONFIG_KEYBOARD_GPIO=y
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_KEYBOARD_CYPRESS_TOUCH=y
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_MELFAS_GC is not set
+# CONFIG_TOUCHSCREEN_MELFAS is not set
+# CONFIG_TOUCHSCREEN_MELFAS_MMS is not set
+# CONFIG_TOUCHSCREEN_MMS152 is not set
+# CONFIG_TOUCHSCREEN_MELFAS_NOTE is not set
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT224_U1 is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT224_GRANDE is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT224S_GRANDE is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT224_GC is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT1536E is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT1664S is not set
+CONFIG_TOUCHSCREEN_ATMEL_MXT540E=y
+# CONFIG_TOUCHSCREEN_ATMEL_MXT224 is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_S3C2410 is not set
+# CONFIG_TOUCHSCREEN_EXYNOS4 is not set
+# CONFIG_TOUCHSCREEN_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MAX11801 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MMS114 is not set
+# CONFIG_MELFAS_TOUCHKEY is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+# CONFIG_TOUCHSCREEN_ZINITIX is not set
+# CONFIG_TOUCHSCREEN_MXT1386 is not set
+# CONFIG_TOUCHSCREEN_MXT768E is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_S7301 is not set
+# CONFIG_TOUCHSCREEN_CYPRESS_TMA46X is not set
+# CONFIG_SEC_TOUCHSCREEN_DVFS_LOCK is not set
+# CONFIG_SEC_TOUCHSCREEN_SURFACE_TOUCH is not set
+# CONFIG_KEYPAD_MELFAS_TOUCH is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT540S is not set
+CONFIG_INPUT_WACOM=y
+CONFIG_EPEN_WACOM_G5SP=y
+# CONFIG_EPEN_WACOM_G9PM is not set
+# CONFIG_EPEN_WACOM_G9PL is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_SENSORS_BH1721FVC is not set
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_ATI_REMOTE is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+CONFIG_INPUT_KEYCHORD=y
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+CONFIG_INPUT_UINPUT=y
+CONFIG_INPUT_GPIO=y
+# CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_PWM_BEEPER is not set
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_OPTICAL_GP2A is not set
+# CONFIG_OPTICAL_WAKE_ENABLE is not set
+# CONFIG_INPUT_CMA3000 is not set
+# CONFIG_INPUT_FLIP is not set
+# CONFIG_INPUT_KR3DH is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+# CONFIG_VT_CONSOLE is not set
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_DEVMEM=y
+CONFIG_DEVKMEM=y
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_CONSOLE is not set
+CONFIG_SERIAL_8250_NR_UARTS=4
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_SAMSUNG=y
+CONFIG_SERIAL_SAMSUNG_UARTS_4=y
+CONFIG_SERIAL_SAMSUNG_UARTS=4
+CONFIG_SERIAL_SAMSUNG_CONSOLE=y
+# CONFIG_SERIAL_SAMSUNG_CONSOLE_SWITCH is not set
+CONFIG_SERIAL_S5PV210=y
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX3107 is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_CSR_GSD4T_CDMA is not set
+
+#
+# Diag Support
+#
+# CONFIG_DIAG_CHAR is not set
+
+#
+# DIAG traffic over USB
+#
+
+#
+# SDIO support for DIAG
+#
+
+#
+# HSIC support for DIAG
+#
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_DCC_TTY is not set
+# CONFIG_RAMOOPS is not set
+CONFIG_S3C_MEM=y
+CONFIG_EXYNOS_MEM=y
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_CHARDEV=y
+# CONFIG_I2C_MUX is not set
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_DESIGNWARE is not set
+CONFIG_I2C_GPIO=y
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PXA_PCI is not set
+CONFIG_HAVE_S3C2410_I2C=y
+CONFIG_I2C_S3C2410=y
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+CONFIG_SPI_BITBANG=y
+CONFIG_SPI_GPIO=y
+# CONFIG_SPI_OC_TINY is not set
+# CONFIG_SPI_PXA2XX_PCI is not set
+# CONFIG_SPI_S3C64XX is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+
+#
+# Enable Device Drivers -> PPS to see the PTP clock options.
+#
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_SYSFS=y
+
+#
+# Memory mapped GPIO drivers:
+#
+# CONFIG_GPIO_BASIC_MMIO is not set
+# CONFIG_GPIO_IT8761E is not set
+CONFIG_GPIO_EXYNOS4=y
+CONFIG_GPIO_PLAT_SAMSUNG=y
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_SX150X is not set
+# CONFIG_GPIO_ADP5588 is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_74X164 is not set
+
+#
+# AC97 GPIO expanders:
+#
+
+#
+# MODULbus GPIO expanders:
+#
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_MAX8997_CHARGER is not set
+# CONFIG_BATTERY_MAX17043_FUELGAUGE is not set
+# CONFIG_BATTERY_MAX17042_FUELGAUGE is not set
+# CONFIG_BATTERY_MAX17047_FUELGAUGE is not set
+# CONFIG_BATTERY_SMB136_CHARGER is not set
+# CONFIG_BATTERY_SAMSUNG_P1X is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_BQ20Z75 is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_BATTERY_S3C_ADC is not set
+# CONFIG_CHARGER_GPIO is not set
+# CONFIG_BATTERY_SAMSUNG is not set
+# CONFIG_CHARGER_MAX8997 is not set
+CONFIG_CHARGER_MAX8997_U1=y
+# CONFIG_CHARGER_MAX8997_PX is not set
+CONFIG_BATTERY_SEC_U1=y
+# CONFIG_BATTERY_SEC_PX is not set
+# CONFIG_CHARGER_MAX8922_U1 is not set
+CONFIG_BATTERY_MAX17042_FUELGAUGE_U1=y
+# CONFIG_BATTERY_MAX17042_FUELGAUGE_PX is not set
+# CONFIG_SMB136_CHARGER is not set
+CONFIG_SMB136_CHARGER_Q1=y
+CONFIG_SMB328_CHARGER=y
+# CONFIG_SMB347_CHARGER is not set
+# CONFIG_CHARGER_MANAGER is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_SENSORS_EXYNOS4_TMU is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+CONFIG_MFD_SUPPORT=y
+CONFIG_MFD_CORE=y
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_MAX8925 is not set
+CONFIG_MFD_MAX8997=y
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_MAX8698 is not set
+# CONFIG_MFD_MAX77686 is not set
+# CONFIG_MFD_MAX77693 is not set
+# CONFIG_MFD_S5M_CORE is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_MC13XXX is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_TPS65910 is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_DUMMY is not set
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_BQ24022 is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_MAX8649 is not set
+# CONFIG_REGULATOR_MAX8660 is not set
+# CONFIG_REGULATOR_MAX8952 is not set
+# CONFIG_REGULATOR_MAX8952_GRANDE is not set
+CONFIG_REGULATOR_MAX8997=y
+# CONFIG_REGULATOR_LP3971 is not set
+# CONFIG_REGULATOR_LP3972 is not set
+# CONFIG_REGULATOR_LP8720 is not set
+# CONFIG_REGULATOR_TPS65023 is not set
+# CONFIG_REGULATOR_TPS6507X is not set
+# CONFIG_REGULATOR_ISL6271A is not set
+# CONFIG_REGULATOR_AD5398 is not set
+# CONFIG_REGULATOR_TPS6524X is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+# CONFIG_MEDIA_CONTROLLER is not set
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_COMMON=y
+# CONFIG_DVB_CORE is not set
+CONFIG_VIDEO_MEDIA=y
+
+#
+# Multimedia drivers
+#
+CONFIG_RC_CORE=y
+CONFIG_LIRC=y
+CONFIG_RC_MAP=y
+CONFIG_IR_NEC_DECODER=y
+CONFIG_IR_RC5_DECODER=y
+CONFIG_IR_RC6_DECODER=y
+CONFIG_IR_JVC_DECODER=y
+CONFIG_IR_SONY_DECODER=y
+CONFIG_IR_RC5_SZ_DECODER=y
+CONFIG_IR_LIRC_CODEC=y
+# CONFIG_IR_IMON is not set
+# CONFIG_IR_MCEUSB is not set
+# CONFIG_IR_REDRAT3 is not set
+# CONFIG_IR_STREAMZAP is not set
+# CONFIG_RC_LOOPBACK is not set
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=y
+CONFIG_MEDIA_TUNER_CUSTOMISE=y
+
+#
+# Customize TV tuners
+#
+# CONFIG_MEDIA_TUNER_SIMPLE is not set
+# CONFIG_MEDIA_TUNER_TDA8290 is not set
+# CONFIG_MEDIA_TUNER_TDA827X is not set
+# CONFIG_MEDIA_TUNER_TDA18271 is not set
+# CONFIG_MEDIA_TUNER_TDA9887 is not set
+# CONFIG_MEDIA_TUNER_TEA5761 is not set
+# CONFIG_MEDIA_TUNER_TEA5767 is not set
+# CONFIG_MEDIA_TUNER_MT20XX is not set
+# CONFIG_MEDIA_TUNER_MT2060 is not set
+# CONFIG_MEDIA_TUNER_MT2266 is not set
+# CONFIG_MEDIA_TUNER_MT2131 is not set
+# CONFIG_MEDIA_TUNER_QT1010 is not set
+# CONFIG_MEDIA_TUNER_XC2028 is not set
+# CONFIG_MEDIA_TUNER_XC5000 is not set
+# CONFIG_MEDIA_TUNER_MXL5005S is not set
+# CONFIG_MEDIA_TUNER_MXL5007T is not set
+# CONFIG_MEDIA_TUNER_MC44S803 is not set
+# CONFIG_MEDIA_TUNER_MAX2165 is not set
+# CONFIG_MEDIA_TUNER_TDA18218 is not set
+# CONFIG_MEDIA_TUNER_TDA18212 is not set
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEOBUF2_CORE=y
+CONFIG_VIDEOBUF2_MEMOPS=y
+CONFIG_VIDEOBUF2_CMA_PHYS=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+CONFIG_VIDEO_FIXED_MINOR_RANGES=y
+# CONFIG_VIDEO_HELPER_CHIPS_AUTO is not set
+CONFIG_VIDEO_IR_I2C=y
+
+#
+# Encoders, decoders, sensors and other helper chips
+#
+
+#
+# Audio decoders, processors and mixers
+#
+# CONFIG_VIDEO_TVAUDIO is not set
+# CONFIG_VIDEO_TDA7432 is not set
+# CONFIG_VIDEO_TDA9840 is not set
+# CONFIG_VIDEO_TEA6415C is not set
+# CONFIG_VIDEO_TEA6420 is not set
+# CONFIG_VIDEO_MSP3400 is not set
+# CONFIG_VIDEO_CS5345 is not set
+# CONFIG_VIDEO_CS53L32A is not set
+# CONFIG_VIDEO_TLV320AIC23B is not set
+# CONFIG_VIDEO_WM8775 is not set
+# CONFIG_VIDEO_WM8739 is not set
+# CONFIG_VIDEO_VP27SMPX is not set
+
+#
+# RDS decoders
+#
+# CONFIG_VIDEO_SAA6588 is not set
+
+#
+# Video decoders
+#
+# CONFIG_VIDEO_ADV7180 is not set
+# CONFIG_VIDEO_BT819 is not set
+# CONFIG_VIDEO_BT856 is not set
+# CONFIG_VIDEO_BT866 is not set
+# CONFIG_VIDEO_KS0127 is not set
+# CONFIG_VIDEO_SAA7110 is not set
+# CONFIG_VIDEO_SAA711X is not set
+# CONFIG_VIDEO_SAA7191 is not set
+# CONFIG_VIDEO_TVP514X is not set
+# CONFIG_VIDEO_TVP5150 is not set
+# CONFIG_VIDEO_TVP7002 is not set
+# CONFIG_VIDEO_VPX3220 is not set
+CONFIG_VIDEO_M5MO=y
+# CONFIG_VIDEO_M9MO is not set
+CONFIG_VIDEO_S5K5BAFX=y
+# CONFIG_VIDEO_S5K5CCGX_COMMON is not set
+# CONFIG_VIDEO_SR200PC20 is not set
+# CONFIG_VIDEO_SR200PC20M is not set
+# CONFIG_VIDEO_ISX012 is not set
+# CONFIG_VIDEO_SLP_S5K4ECGX is not set
+# CONFIG_VIDEO_SLP_DB8131M is not set
+# CONFIG_VIDEO_S5K4EA is not set
+# CONFIG_VIDEO_S5C73M3 is not set
+# CONFIG_VIDEO_SLP_S5C73M3 is not set
+# CONFIG_VIDEO_SR130PC20 is not set
+CONFIG_VIDEO_IMPROVE_STREAMOFF=y
+CONFIG_CSI_C=y
+# CONFIG_CSI_D is not set
+
+#
+# Video and audio decoders
+#
+# CONFIG_VIDEO_SAA717X is not set
+# CONFIG_VIDEO_CX25840 is not set
+
+#
+# MPEG video encoders
+#
+# CONFIG_VIDEO_CX2341X is not set
+
+#
+# Video encoders
+#
+# CONFIG_VIDEO_SAA7127 is not set
+# CONFIG_VIDEO_SAA7185 is not set
+# CONFIG_VIDEO_ADV7170 is not set
+# CONFIG_VIDEO_ADV7175 is not set
+# CONFIG_VIDEO_ADV7343 is not set
+# CONFIG_VIDEO_AK881X is not set
+
+#
+# Camera sensor devices
+#
+# CONFIG_VIDEO_OV7670 is not set
+# CONFIG_VIDEO_MT9V011 is not set
+# CONFIG_VIDEO_TCM825X is not set
+
+#
+# Video improvement chips
+#
+# CONFIG_VIDEO_UPD64031A is not set
+# CONFIG_VIDEO_UPD64083 is not set
+
+#
+# Miscelaneous helper chips
+#
+# CONFIG_VIDEO_THS7303 is not set
+# CONFIG_VIDEO_M52790 is not set
+# CONFIG_VIDEO_CPIA2 is not set
+# CONFIG_VIDEO_SR030PC30 is not set
+# CONFIG_VIDEO_NOON010PC30 is not set
+# CONFIG_SOC_CAMERA is not set
+# CONFIG_VIDEO_SAMSUNG_S5P_FIMC is not set
+CONFIG_SAMSUNG_MFC_DRIVERS=y
+CONFIG_USE_LEGACY_MFC=y
+# CONFIG_USE_V4L2_MFC is not set
+CONFIG_V4L_USB_DRIVERS=y
+# CONFIG_USB_VIDEO_CLASS is not set
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+# CONFIG_USB_GSPCA is not set
+# CONFIG_VIDEO_PVRUSB2 is not set
+# CONFIG_VIDEO_HDPVR is not set
+# CONFIG_VIDEO_EM28XX is not set
+# CONFIG_VIDEO_CX231XX is not set
+# CONFIG_VIDEO_USBVISION is not set
+# CONFIG_USB_ET61X251 is not set
+# CONFIG_USB_SN9C102 is not set
+# CONFIG_USB_PWC is not set
+# CONFIG_USB_ZR364XX is not set
+# CONFIG_USB_STKWEBCAM is not set
+# CONFIG_USB_S2255 is not set
+CONFIG_VIDEO_SAMSUNG=y
+CONFIG_VIDEO_SAMSUNG_V4L2=y
+CONFIG_VIDEO_FIMC=y
+# CONFIG_USE_FIMC_CMA is not set
+CONFIG_VIDEO_FIMC_RANGE_NARROW=y
+# CONFIG_VIDEO_FIMC_RANGE_WIDE is not set
+# CONFIG_VIDEO_FIMC_DEBUG is not set
+CONFIG_VIDEO_FIMC_MIPI=y
+# CONFIG_VIDEO_FIMC_MIPI_IRQ_DEBUG is not set
+CONFIG_VIDEO_FIMC_DMA_AUTO=y
+# CONFIG_VIDEO_FIMC_FIFO is not set
+CONFIG_VIDEO_TVOUT=y
+CONFIG_VIDEO_TVOUT_2CH_AUDIO=y
+# CONFIG_VIDEO_TVOUT_5_1CH_AUDIO is not set
+# CONFIG_HDMI_CEC is not set
+CONFIG_HDMI_EARJACK_MUTE=y
+CONFIG_HDMI_HPD=y
+# CONFIG_HDMI_CONTROLLED_BY_EXT_IC is not set
+# CONFIG_HDMI_TX_STRENGTH is not set
+CONFIG_HDMI_SWITCH_HPD=y
+# CONFIG_ANALOG_TVENC is not set
+CONFIG_TV_FB=y
+CONFIG_USER_ALLOC_TVOUT=y
+CONFIG_USE_TVOUT_CMA=y
+# CONFIG_LSI_HDMI_AUDIO_CH_EVENT is not set
+# CONFIG_TV_DEBUG is not set
+CONFIG_VIDEO_MFC5X=y
+CONFIG_VIDEO_MFC_MAX_INSTANCE=4
+CONFIG_VIDEO_MFC_MEM_PORT_COUNT=2
+# CONFIG_VIDEO_MFC5X_DEBUG is not set
+CONFIG_USE_MFC_CMA=y
+CONFIG_VIDEO_MALI400MP_UMP=y
+# CONFIG_MALI_DED_ONLY is not set
+# CONFIG_MALI_DED_MMU is not set
+CONFIG_MALI_OSMEM_ONLY=y
+# CONFIG_MALI_DED_OSMEM is not set
+# CONFIG_UMP_DED_ONLY is not set
+CONFIG_UMP_OSMEM_ONLY=y
+# CONFIG_UMP_VCM_ONLY is not set
+CONFIG_UMP_MEM_SIZE=1024
+CONFIG_MALI_UMP_R2P4_LSI=y
+# CONFIG_MALI_UMP_R3P1_LSI is not set
+# CONFIG_VIDEO_MALI400MP_UMP_DEBUG is not set
+# CONFIG_VIDEO_MALI400MP_STREAMLINE_PROFILING is not set
+CONFIG_VIDEO_MALI400MP_DVFS=y
+CONFIG_VIDEO_FIMG2D=y
+# CONFIG_VIDEO_FIMG2D_DEBUG is not set
+CONFIG_VIDEO_FIMG2D3X=y
+# CONFIG_VIDEO_FIMG2D3X_DEBUG is not set
+CONFIG_VIDEO_JPEG=y
+# CONFIG_VIDEO_JPEG_DEBUG is not set
+
+#
+# Reserved memory configurations
+#
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMC0=12288
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMC1=32768
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMC2=25600
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMC3=7168
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_MFC0=18432
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_MFC1=28672
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_JPEG=20480
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_TVOUT=16384
+# CONFIG_VIDEO_EXYNOS is not set
+# CONFIG_V4L_MEM2MEM_DRIVERS is not set
+
+#
+# Mhl(sii9244) device support
+#
+CONFIG_SAMSUNG_MHL=y
+# CONFIG_SAMSUNG_USE_11PIN_CONNECTOR is not set
+# CONFIG_SAMSUNG_SMARTDOCK is not set
+CONFIG_SAMSUNG_WORKAROUND_HPD_GLANCE=y
+# CONFIG_SAMSUNG_MHL_UNPOWERED is not set
+# CONFIG_RADIO_ADAPTERS is not set
+# CONFIG_TDMB is not set
+# CONFIG_ISDBT is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+# CONFIG_ION is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_WMT_GE_ROPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_S5P=y
+# CONFIG_FB_S5P_SYSMMU is not set
+CONFIG_FB_S5P_SPLASH_SCREEN=y
+# CONFIG_FB_S5P_LCD_INIT is not set
+# CONFIG_FB_S5P_DEBUG is not set
+CONFIG_FB_S5P_VSYNC_THREAD=y
+# CONFIG_FB_S5P_TRACE_UNDERRUN is not set
+CONFIG_FB_S5P_DEFAULT_WINDOW=2
+CONFIG_FB_S5P_NR_BUFFERS=2
+# CONFIG_FB_S5P_VIRTUAL is not set
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMD=32000
+CONFIG_FB_S5P_MDNIE=y
+# CONFIG_FB_MDNIE_PWM is not set
+CONFIG_FB_S5P_MIPI_DSIM=y
+CONFIG_FB_BGRA_ORDER=y
+# CONFIG_FB_RGBA_ORDER is not set
+# CONFIG_FB_S5P_LD9040 is not set
+# CONFIG_FB_S5P_LMS501XX is not set
+# CONFIG_FB_S5P_DUMMY_MIPI_LCD is not set
+CONFIG_FB_S5P_S6E8AA0=y
+# CONFIG_FB_S5P_EA8061 is not set
+# CONFIG_FB_S5P_S6EVR02 is not set
+# CONFIG_FB_S5P_S6D6AA1 is not set
+# CONFIG_FB_S5P_NT71391 is not set
+CONFIG_S6E8AA0_AMS529HA01=y
+# CONFIG_S6E8AA0_AMS480GYXX is not set
+# CONFIG_S6E8AA0_AMS465XX is not set
+# CONFIG_AID_DIMMING is not set
+# CONFIG_LCD_REVERSE is not set
+# CONFIG_FB_S5P_EXTDSP is not set
+# CONFIG_S5P_DSIM_SWITCHABLE_DUAL_LCD is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_TMIO is not set
+# CONFIG_FB_S3C is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+# CONFIG_LCD_L4F00242T03 is not set
+# CONFIG_LCD_LMS283GF05 is not set
+# CONFIG_LCD_LTV350QV is not set
+# CONFIG_LCD_TDO24M is not set
+# CONFIG_LCD_VGG2432A4 is not set
+# CONFIG_LCD_PLATFORM is not set
+# CONFIG_LCD_S6E63M0 is not set
+# CONFIG_LCD_MIPI_S6E63M0 is not set
+# CONFIG_LCD_MIPI_S6E8AB0 is not set
+# CONFIG_LCD_MIPI_TC358764 is not set
+# CONFIG_LCD_LD9040 is not set
+# CONFIG_LCD_WA101S is not set
+# CONFIG_LCD_LTE480WV is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_GENERIC is not set
+# CONFIG_BACKLIGHT_PWM is not set
+# CONFIG_BACKLIGHT_ADP8860 is not set
+# CONFIG_BACKLIGHT_ADP8870 is not set
+# CONFIG_BACKLIGHT_LP855X is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+# CONFIG_LOGO is not set
+CONFIG_SOUND=y
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_HWDEP=y
+CONFIG_SND_JACK=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_HRTIMER is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+# CONFIG_SND_SUPPORT_OLD_API is not set
+# CONFIG_SND_VERBOSE_PROCFS is not set
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_ARM is not set
+# CONFIG_SND_SPI is not set
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_6FIRE is not set
+CONFIG_SND_SOC=y
+# CONFIG_SND_SOC_CACHE_LZO is not set
+CONFIG_SND_SOC_SAMSUNG=y
+CONFIG_SND_SAMSUNG_I2S=y
+CONFIG_SND_SOC_U1_MC1N2=y
+# CONFIG_SND_SOC_SAMSUNG_USE_DMA_WRAPPER is not set
+CONFIG_SND_SOC_SAMSUNG_I2S_SEC=y
+# CONFIG_SND_SAMSUNG_NORMAL is not set
+# CONFIG_SND_SAMSUNG_LP is not set
+CONFIG_SND_SAMSUNG_ALP=y
+# CONFIG_SND_SAMSUNG_RP is not set
+CONFIG_AUDIO_SAMSUNG_MEMSIZE_SRP=1024
+# CONFIG_SND_SAMSUNG_RP_DEBUG is not set
+# CONFIG_SND_SAMSUNG_I2S_MASTER is not set
+# CONFIG_SND_DUOS_MODEM_SWITCH is not set
+# CONFIG_SND_USE_SUB_MIC is not set
+# CONFIG_SND_USE_THIRD_MIC is not set
+# CONFIG_SND_USE_STEREO_SPEAKER is not set
+# CONFIG_SND_USE_LINEOUT_SWITCH is not set
+# CONFIG_SND_USE_MUIC_SWITCH is not set
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_MC1N2=y
+CONFIG_SND_SOC_USE_EXTERNAL_MIC_BIAS=y
+# CONFIG_SND_SOC_MC1N2_DEBUG is not set
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=y
+# CONFIG_HID_ACRUX is not set
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+# CONFIG_HID_PRODIKEYS is not set
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DRAGONRISE=y
+# CONFIG_DRAGONRISE_FF is not set
+# CONFIG_HID_EMS_FF is not set
+CONFIG_HID_ELECOM=y
+CONFIG_HID_EZKEY=y
+# CONFIG_HID_KEYTOUCH is not set
+CONFIG_HID_KYE=y
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+CONFIG_HID_GYRATION=y
+# CONFIG_HID_TWINHAN is not set
+CONFIG_HID_KENSINGTON=y
+# CONFIG_HID_LCPOWER is not set
+CONFIG_HID_LOGITECH=y
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+# CONFIG_LOGIG940_FF is not set
+# CONFIG_LOGIWII_FF is not set
+CONFIG_HID_MAGICMOUSE=y
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+# CONFIG_HID_MULTITOUCH is not set
+CONFIG_HID_NTRIG=y
+CONFIG_HID_ORTEK=y
+CONFIG_HID_PANTHERLORD=y
+# CONFIG_PANTHERLORD_FF is not set
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_PICOLCD=y
+# CONFIG_HID_PICOLCD_FB is not set
+# CONFIG_HID_PICOLCD_BACKLIGHT is not set
+# CONFIG_HID_PICOLCD_LCD is not set
+# CONFIG_HID_PICOLCD_LEDS is not set
+CONFIG_HID_QUANTA=y
+CONFIG_HID_ROCCAT=y
+CONFIG_HID_ROCCAT_COMMON=y
+# CONFIG_HID_ROCCAT_ARVO is not set
+CONFIG_HID_ROCCAT_KONE=y
+# CONFIG_HID_ROCCAT_KONEPLUS is not set
+# CONFIG_HID_ROCCAT_KOVAPLUS is not set
+# CONFIG_HID_ROCCAT_PYRA is not set
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SUNPLUS=y
+CONFIG_HID_GREENASIA=y
+# CONFIG_GREENASIA_FF is not set
+CONFIG_HID_SMARTJOYPLUS=y
+# CONFIG_SMARTJOYPLUS_FF is not set
+CONFIG_HID_TOPSEED=y
+CONFIG_HID_THRUSTMASTER=y
+# CONFIG_THRUSTMASTER_FF is not set
+CONFIG_HID_WACOM=y
+# CONFIG_HID_WACOM_POWER_SUPPLY is not set
+CONFIG_HID_ZEROPLUS=y
+# CONFIG_ZEROPLUS_FF is not set
+CONFIG_HID_ZYDACRON=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB_ARCH_HAS_XHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_SUSPEND=y
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_HOST_COMPLIANT_TEST is not set
+CONFIG_USB_HOST_NOTIFY=y
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_XHCI_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+CONFIG_USB_EHCI_S5P=y
+CONFIG_USB_S5P_HSIC0=y
+CONFIG_USB_S5P_HSIC1=y
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+CONFIG_USB_S3C_OTG_HOST=y
+# CONFIG_USB_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+CONFIG_USB_PRINTER=y
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+# CONFIG_USB_UAS is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_QCOM_DIAG_BRIDGE is not set
+# CONFIG_USB_QCOM_MDM_BRIDGE is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_FUSB300 is not set
+# CONFIG_USB_GADGET_R8A66597 is not set
+CONFIG_USB_GADGET_S3C_OTGD=y
+# CONFIG_USB_GADGET_PXA_U2O is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+
+#
+# NOTE: S3C OTG device role enables the controller driver below
+#
+CONFIG_USB_S3C_OTGD=y
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_G_NCM is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FUNCTIONFS is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_MASS_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_G_SLP is not set
+CONFIG_USB_G_ANDROID=y
+CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE=y
+CONFIG_USB_ANDROID_SAMSUNG_MTP=y
+CONFIG_USB_DUN_SUPPORT=y
+# CONFIG_USB_ANDROID is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+# CONFIG_USB_G_NOKIA is not set
+# CONFIG_USB_G_MULTI is not set
+# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_DBGP is not set
+# CONFIG_USB_G_WEBCAM is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_OTG_WAKELOCK is not set
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ULPI is not set
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_UNSAFE_RESUME=y
+CONFIG_MMC_CLKGATE=y
+CONFIG_MMC_EMBEDDED_SDIO=y
+# CONFIG_MMC_PARANOID_SD_INIT is not set
+# CONFIG_MMC_NOT_USE_SANITIZE is not set
+# CONFIG_MMC_POLLING_WAIT_CMD23 is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=8
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_MMC_BLOCK_DEFERRED_RESUME is not set
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+# CONFIG_MMC_SELECTIVE_PACKED_CMD_POLICY is not set
+# CONFIG_MMC_CPRM is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+CONFIG_MMC_MSHCI=y
+# CONFIG_MMC_MSHCI_S3C_DMA_MAP is not set
+# CONFIG_MMC_MSHCI_ASYNC_OPS is not set
+# CONFIG_MMC_MSHCI_ENABLE_CACHE is not set
+CONFIG_MMC_SDHCI=y
+# CONFIG_MMC_SDHCI_PLTFM is not set
+CONFIG_MMC_SDHCI_S3C=y
+CONFIG_MMC_SDHCI_S3C_DMA=y
+# CONFIG_MMC_DW is not set
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_LEDS_SPFCW043 is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_LM3530 is not set
+# CONFIG_LEDS_PCA9532 is not set
+# CONFIG_LEDS_GPIO is not set
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_AN30259A is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_PWM is not set
+# CONFIG_LEDS_REGULATOR is not set
+CONFIG_LEDS_MAX8997=y
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_LT3593 is not set
+# CONFIG_LEDS_SWITCH is not set
+# CONFIG_LEDS_AAT1290A is not set
+# CONFIG_LEDS_TRIGGERS is not set
+
+#
+# LED Triggers
+#
+# CONFIG_NFC_DEVICES is not set
+CONFIG_SWITCH=y
+CONFIG_SWITCH_GPIO=y
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+CONFIG_RTC_INTF_ALARM=y
+CONFIG_RTC_INTF_ALARM_DEV=y
+# CONFIG_RTC_ALARM_BOOT is not set
+# CONFIG_RTC_POWER_OFF is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+CONFIG_RTC_DRV_MAX8997=y
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_HAVE_S3C_RTC=y
+CONFIG_RTC_DRV_S3C=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+CONFIG_STAGING=y
+# CONFIG_VIDEO_TM6000 is not set
+# CONFIG_USBIP_CORE is not set
+# CONFIG_PRISM2_USB is not set
+# CONFIG_ECHO is not set
+# CONFIG_BRCMUTIL is not set
+# CONFIG_ASUS_OLED is not set
+# CONFIG_R8712U is not set
+# CONFIG_TRANZPORT is not set
+
+#
+# Android
+#
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ANDROID_LOGGER=m
+# CONFIG_ANDROID_RAM_CONSOLE is not set
+CONFIG_ANDROID_TIMED_OUTPUT=y
+CONFIG_ANDROID_TIMED_GPIO=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+# CONFIG_POHMELFS is not set
+# CONFIG_LINE6_USB is not set
+# CONFIG_VT6656 is not set
+# CONFIG_IIO is not set
+# CONFIG_XVMALLOC is not set
+# CONFIG_ZRAM is not set
+# CONFIG_FB_SM7XX is not set
+# CONFIG_LIRC_STAGING is not set
+# CONFIG_EASYCAP is not set
+# CONFIG_MACH_C110_WESTBRIDGE_AST_PNAND_HAL is not set
+CONFIG_MACH_NO_WESTBRIDGE=y
+# CONFIG_ATH6K_LEGACY is not set
+# CONFIG_USB_ENESTORAGE is not set
+# CONFIG_BCM_WIMAX is not set
+# CONFIG_FT1000 is not set
+
+#
+# Speakup console speech
+#
+# CONFIG_SPEAKUP is not set
+# CONFIG_TOUCHSCREEN_CLEARPAD_TM1217 is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4 is not set
+
+#
+# Altera FPGA firmware download module
+#
+# CONFIG_ALTERA_STAPL is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_VIBETONZ=y
+CONFIG_MOTOR_DRV_MAX8997=y
+# CONFIG_MOTOR_DRV_ISA1200 is not set
+# CONFIG_MOTOR_DRV_DRV2603 is not set
+CONFIG_FM_RADIO=y
+CONFIG_J4FS=m
+CONFIG_FM_SI4709=m
+# CONFIG_FM_SI4705 is not set
+CONFIG_SENSORS_CORE=y
+CONFIG_SENSORS_AK8975C=y
+# CONFIG_SENSORS_AK8963C is not set
+CONFIG_SENSORS_BMP180=y
+# CONFIG_SENSORS_CM3663 is not set
+# CONFIG_SENSORS_PAS2M110 is not set
+# CONFIG_SENSORS_BMA254 is not set
+# CONFIG_SENSORS_TAOS is not set
+# CONFIG_SENSORS_GP2A is not set
+CONFIG_SENSORS_GP2A_ANALOG=y
+# CONFIG_SENSORS_CM36651 is not set
+# CONFIG_SENSORS_BH1721 is not set
+# CONFIG_SENSORS_AL3201 is not set
+CONFIG_SENSORS_K3DH=y
+CONFIG_SENSORS_K3G=y
+# CONFIG_SENSORS_LSM330DLC is not set
+# CONFIG_SENSORS_LPS331 is not set
+# CONFIG_SENSORS_SYSFS is not set
+# CONFIG_SENSORS_SSP is not set
+# CONFIG_SENSORS_SSP_LSM330 is not set
+# CONFIG_SENSORS_SSP_AK8963C is not set
+# CONFIG_SENSORS_SSP_CM36651 is not set
+# CONFIG_SENSORS_SSP_BMP182 is not set
+# CONFIG_SENSORS_SSP_AT32UC3L0128 is not set
+# CONFIG_SENSORS_SSP_SENSORHUB is not set
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_SAMSUNG_PHONE_SVNET is not set
+CONFIG_ACCESSORY=y
+# CONFIG_30PIN_CONN is not set
+# CONFIG_MHL_SII9234 is not set
+# CONFIG_SEC_KEYBOARD_DOCK is not set
+# CONFIG_HPD_PULL is not set
+# CONFIG_SAMSUNG_MHL_9290 is not set
+# CONFIG_IR_REMOCON is not set
+# CONFIG_EXTCON is not set
+# CONFIG_BARCODE_EMUL is not set
+CONFIG_IOMMU_SUPPORT=y
+# CONFIG_FELICA is not set
+# CONFIG_AUTHENTEC_VPNCLIENT_INTERCEPTOR is not set
+# CONFIG_J4FS_USE_XSR is not set
+# CONFIG_J4FS_USE_FSR is not set
+CONFIG_J4FS_USE_MOVI=y
+CONFIG_J4FS_DEVNAME="/dev/block/mmcblk0p4"
+CONFIG_J4FS_PAGE_SHIFT=11
+CONFIG_J4FS_BLOCK_COUNT=20
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_USE_FOR_EXT23=y
+# CONFIG_EXT4_FS_XATTR is not set
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+# CONFIG_DNOTIFY is not set
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=y
+# CONFIG_CUSE is not set
+CONFIG_GENERIC_ACL=y
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+CONFIG_NTFS_FS=y
+# CONFIG_NTFS_DEBUG is not set
+CONFIG_NTFS_RW=y
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+# CONFIG_PROC_SEC_MEMINFO is not set
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+CONFIG_ECRYPT_FS=y
+CONFIG_WTL_ENCRYPTION_FILTER=y
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+# CONFIG_NFS_FS is not set
+# CONFIG_NFSD is not set
+# CONFIG_CEPH_FS is not set
+CONFIG_CIFS=y
+# CONFIG_CIFS_STATS is not set
+# CONFIG_CIFS_WEAK_PW_HASH is not set
+# CONFIG_CIFS_UPCALL is not set
+# CONFIG_CIFS_XATTR is not set
+# CONFIG_CIFS_DEBUG2 is not set
+# CONFIG_CIFS_DFS_UPCALL is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+
+#
+# Kernel hacking
+#
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_HARDLOCKUP_DETECTOR is not set
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SLUB_STATS is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_STACKTRACE is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_MEMORY_INIT is not set
+CONFIG_FRAME_POINTER=y
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+CONFIG_RCU_CPU_STALL_VERBOSE=y
+# CONFIG_LKDTM is not set
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_PREEMPT_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_ENABLE_DEFAULT_TRACERS is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_STRICT_DEVMEM is not set
+# CONFIG_ARM_UNWIND is not set
+CONFIG_DEBUG_USER=y
+# CONFIG_OC_ETM is not set
+CONFIG_DEBUG_S3C_UART=1
+# CONFIG_CACHE_PERF is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+CONFIG_KEYS_DEBUG_PROC_KEYS=y
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_FIPS_INTEG_OFFSET=0x20000000
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_CRYPTO_MANAGER_TESTS=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_GHASH is not set
+CONFIG_CRYPTO_MD4=y
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA256=y
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_TWOFISH_COMMON=y
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_S5P_DEV_ACE is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+# CONFIG_XZ_DEC is not set
+# CONFIG_XZ_DEC_BCJ is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=y
+CONFIG_TEXTSEARCH_BM=y
+CONFIG_TEXTSEARCH_FSM=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_DMA=y
+CONFIG_CPU_RMAP=y
+CONFIG_NLATTR=y
+# CONFIG_AVERAGE is not set
diff -urNp Kernel/arch/arm/include/asm/cputype.h HelloWorld-Renew-v1.0-n7000-jb/arch/arm/include/asm/cputype.h
--- Kernel/arch/arm/include/asm/cputype.h	2013-02-20 13:36:09.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/arch/arm/include/asm/cputype.h	2013-04-29 16:41:35.126587461 +0200
@@ -8,6 +8,7 @@
 #define CPUID_CACHETYPE	1
 #define CPUID_TCM	2
 #define CPUID_TLBTYPE	3
+#define CPUID_MPIDR	5
 
 #define CPUID_EXT_PFR0	"c1, 0"
 #define CPUID_EXT_PFR1	"c1, 1"
@@ -70,6 +71,11 @@ static inline unsigned int __attribute_c
 	return read_cpuid(CPUID_TCM);
 }
 
+static inline unsigned int __attribute_const__ read_cpuid_mpidr(void)
+{
+	return read_cpuid(CPUID_MPIDR);
+}
+
 /*
  * Intel's XScale3 core supports some v6 features (supersections, L2)
  * but advertises itself as v5 as it does not support the v6 ISA.  For
diff -urNp Kernel/arch/arm/include/asm/idle.h HelloWorld-Renew-v1.0-n7000-jb/arch/arm/include/asm/idle.h
--- Kernel/arch/arm/include/asm/idle.h	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/arch/arm/include/asm/idle.h	2013-04-26 23:38:22.000000000 +0200
@@ -0,0 +1,29 @@
+/* arch/arm/include/asm/idle.h
+*
+* Copyright (c) 2004 Simtec Electronics <linux@simtec.co.uk>
+* http://www.simtec.co.uk/products/SWLINUX/
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*
+* S3C2410 CPU Idle controls
+*
+* Changelog:
+* 28-Oct-2004 BJD Initial version
+*
+*/
+
+#ifndef __ASM_ARCH_IDLE_H
+#define __ASM_ARCH_IDLE_H __FILE__
+
+/* This allows the over-ride of the default idle code, in case there
+* is any other things to be done over idle (like DVS)
+*/
+
+extern void (*s3c24xx_idle)(void);
+
+extern void s3c24xx_default_idle(void);
+
+#endif /* __ASM_ARCH_IDLE_H */
+
diff -urNp Kernel/arch/arm/include/asm/topology.h HelloWorld-Renew-v1.0-n7000-jb/arch/arm/include/asm/topology.h
--- Kernel/arch/arm/include/asm/topology.h	2013-02-20 13:36:09.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/arch/arm/include/asm/topology.h	2013-04-29 16:41:35.126587461 +0200
@@ -1,6 +1,72 @@
 #ifndef _ASM_ARM_TOPOLOGY_H
 #define _ASM_ARM_TOPOLOGY_H
 
+#ifdef CONFIG_ARM_CPU_TOPOLOGY
+
+#include <linux/cpumask.h>
+
+struct cputopo_arm {
+	int thread_id;
+	int core_id;
+	int socket_id;
+	cpumask_t thread_sibling;
+	cpumask_t core_sibling;
+};
+
+extern struct cputopo_arm cpu_topology[NR_CPUS];
+
+#define topology_physical_package_id(cpu)	(cpu_topology[cpu].socket_id)
+#define topology_core_id(cpu)		(cpu_topology[cpu].core_id)
+#define topology_core_cpumask(cpu)	(&cpu_topology[cpu].core_sibling)
+#define topology_thread_cpumask(cpu)	(&cpu_topology[cpu].thread_sibling)
+
+#define mc_capable()	(cpu_topology[0].socket_id != -1)
+#define smt_capable()	(cpu_topology[0].thread_id != -1)
+
+void init_cpu_topology(void);
+void store_cpu_topology(unsigned int cpuid);
+const struct cpumask *cpu_coregroup_mask(unsigned int cpu);
+
+#else
+
+static inline void init_cpu_topology(void) { }
+static inline void store_cpu_topology(unsigned int cpuid) { }
+
+#endif
+
+/* Common values for CPUs */
+#ifndef SD_CPU_INIT
+#define SD_CPU_INIT (struct sched_domain) {				\
+	.min_interval		= 1,					\
+	.max_interval		= 4,					\
+	.busy_factor		= 64,					\
+	.imbalance_pct		= 125,					\
+	.cache_nice_tries	= 1,					\
+	.busy_idx		= 2,					\
+	.idle_idx		= 1,					\
+	.newidle_idx		= 0,					\
+	.wake_idx		= 0,					\
+	.forkexec_idx		= 0,					\
+									\
+	.flags			= 1*SD_LOAD_BALANCE			\
+				| 1*SD_BALANCE_NEWIDLE			\
+				| 1*SD_BALANCE_EXEC			\
+				| 1*SD_BALANCE_FORK			\
+				| 0*SD_BALANCE_WAKE			\
+				| 1*SD_WAKE_AFFINE			\
+				| 0*SD_PREFER_LOCAL			\
+				| 0*SD_SHARE_CPUPOWER			\
+				| 0*SD_SHARE_PKG_RESOURCES		\
+				| 0*SD_SERIALIZE			\
+				| arch_sd_sibling_asym_packing()	\
+				| sd_balance_for_package_power()	\
+				| sd_power_saving_flags()		\
+				,					\
+	.last_balance		= jiffies,				\
+	.balance_interval	= 1,					\
+}
+#endif
+
 #include <asm-generic/topology.h>
 
 #endif /* _ASM_ARM_TOPOLOGY_H */
diff -urNp Kernel/arch/arm/Kconfig HelloWorld-Renew-v1.0-n7000-jb/arch/arm/Kconfig
--- Kernel/arch/arm/Kconfig	2013-02-20 13:36:08.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/arch/arm/Kconfig	2013-04-29 16:41:35.130587461 +0200
@@ -1417,6 +1417,31 @@ config SMP_ON_UP
 
 	  If you don't know what to do here, say Y.
 
+config ARM_CPU_TOPOLOGY
+	bool "Support cpu topology definition"
+	depends on SMP && CPU_V7
+	default y
+	help
+	  Support ARM cpu topology definition. The MPIDR register defines
+	  affinity between processors which is then used to describe the cpu
+	  topology of an ARM System.
+
+config SCHED_MC
+	bool "Multi-core scheduler support"
+	depends on ARM_CPU_TOPOLOGY
+	help
+	  Multi-core scheduler support improves the CPU scheduler's decision
+	  making when dealing with multi-core CPU chips at a cost of slightly
+	  increased overhead in some places. If unsure say N here.
+
+config SCHED_SMT
+	bool "SMT scheduler support"
+	depends on ARM_CPU_TOPOLOGY
+	help
+	  Improves the CPU scheduler's decision making when dealing with
+	  MultiThreading at a cost of slightly increased overhead in some
+	  places. If unsure say N here.
+
 config HAVE_ARM_SCU
 	bool
 	depends on SMP
diff -urNp Kernel/arch/arm/kernel/Makefile HelloWorld-Renew-v1.0-n7000-jb/arch/arm/kernel/Makefile
--- Kernel/arch/arm/kernel/Makefile	2013-02-20 13:36:09.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/arch/arm/kernel/Makefile	2013-04-29 16:41:35.130587461 +0200
@@ -62,6 +62,7 @@ obj-$(CONFIG_IWMMXT)		+= iwmmxt.o
 obj-$(CONFIG_CPU_HAS_PMU)	+= pmu.o
 obj-$(CONFIG_HW_PERF_EVENTS)	+= perf_event.o
 AFLAGS_iwmmxt.o			:= -Wa,-mcpu=iwmmxt
+obj-$(CONFIG_ARM_CPU_TOPOLOGY)  += topology.o
 
 ifneq ($(CONFIG_ARCH_EBSA110),y)
   obj-y		+= io.o
diff -urNp Kernel/arch/arm/kernel/smp.c HelloWorld-Renew-v1.0-n7000-jb/arch/arm/kernel/smp.c
--- Kernel/arch/arm/kernel/smp.c	2013-02-20 13:36:09.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/arch/arm/kernel/smp.c	2013-04-29 16:41:35.130587461 +0200
@@ -31,6 +31,7 @@
 #include <asm/cacheflush.h>
 #include <asm/cpu.h>
 #include <asm/cputype.h>
+#include <asm/topology.h>
 #include <asm/mmu_context.h>
 #include <asm/pgtable.h>
 #include <asm/pgalloc.h>
@@ -281,6 +282,8 @@ static void __cpuinit smp_store_cpu_info
 	struct cpuinfo_arm *cpu_info = &per_cpu(cpu_data, cpuid);
 
 	cpu_info->loops_per_jiffy = loops_per_jiffy;
+
+	store_cpu_topology(cpuid);
 }
 
 /*
@@ -382,6 +385,8 @@ void __init smp_prepare_cpus(unsigned in
 {
 	unsigned int ncores = num_possible_cpus();
 
+	init_cpu_topology();
+
 	smp_store_cpu_info(smp_processor_id());
 
 	/*
diff -urNp Kernel/arch/arm/kernel/topology.c HelloWorld-Renew-v1.0-n7000-jb/arch/arm/kernel/topology.c
--- Kernel/arch/arm/kernel/topology.c	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/arch/arm/kernel/topology.c	2013-04-29 16:41:35.134587461 +0200
@@ -0,0 +1,589 @@
+/*
+ * arch/arm/kernel/topology.c
+ *
+ * Copyright (C) 2011 Linaro Limited.
+ * Written by: Vincent Guittot
+ *
+ * based on arch/sh/kernel/topology.c
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+
+#include <linux/cpu.h>
+#include <linux/cpumask.h>
+#include <linux/init.h>
+#include <linux/percpu.h>
+#include <linux/node.h>
+#include <linux/nodemask.h>
+#include <linux/sched.h>
+#include <linux/cpumask.h>
+#include <linux/cpuset.h>
+
+#ifdef CONFIG_CPU_FREQ
+#include <linux/cpufreq.h>
+#endif
+
+#ifdef CONFIG_DEBUG_FS
+#include <linux/debugfs.h>
+#include <linux/uaccess.h>	/* for copy_from_user */
+#endif
+
+#include <asm/cputype.h>
+#include <asm/topology.h>
+
+#define MPIDR_SMP_BITMASK (0x3 << 30)
+#define MPIDR_SMP_VALUE (0x2 << 30)
+
+#define MPIDR_MT_BITMASK (0x1 << 24)
+
+/*
+ * These masks reflect the current use of the affinity levels.
+ * The affinity level can be up to 16 bits according to ARM ARM
+ */
+
+#define MPIDR_LEVEL0_MASK 0x3
+#define MPIDR_LEVEL0_SHIFT 0
+
+#define MPIDR_LEVEL1_MASK 0xF
+#define MPIDR_LEVEL1_SHIFT 8
+
+#define MPIDR_LEVEL2_MASK 0xFF
+#define MPIDR_LEVEL2_SHIFT 16
+
+struct cputopo_arm cpu_topology[NR_CPUS];
+
+/*
+ * cpu power scale management
+ */
+
+/*
+ * a per cpu data structure should be better because each cpu is mainly
+ * using its own cpu_power even it's not always true because of
+ * no_hz_idle_balance
+ */
+
+static DEFINE_PER_CPU(unsigned int, cpu_scale);
+
+/*
+ * cpu topology mask management
+ */
+
+unsigned int advanced_topology = 1;
+
+static void normal_cpu_topology_mask(void);
+static void (*set_cpu_topology_mask)(void) = normal_cpu_topology_mask;
+
+#ifdef CONFIG_CPU_FREQ
+/*
+ * This struct describes parameters to compute cpu_power
+ */
+struct cputopo_power {
+	int id;
+	int max; /* max idx in the table */
+	unsigned int step; /* frequency step for the table */
+	unsigned int *table; /* table of cpu_power */
+};
+
+/* default table with one default cpu_power value */
+unsigned int table_default_power[1] = {
+	1024
+};
+
+static struct cputopo_power default_cpu_power = {
+	.max  = 1,
+	.step = 1,
+	.table = table_default_power,
+};
+
+/* CA-9 table with cpufreq modifying cpu_power */
+#define CPU_MAX_FREQ 10
+/* we use a 200Mhz step for scaling cpu power */
+#define CPU_TOPO_FREQ_STEP 200000
+/* This table sets the cpu_power scale of a cpu according to 2 inputs which are
+ * the frequency and the sched_mc mode. The content of this table could be SoC
+ * specific so we should add a method to overwrite this default table.
+ * TODO: Study how to use DT for setting this table
+ */
+unsigned int table_ca9_power[CPU_MAX_FREQ] = {
+/* freq< 200   400   600   800  1000  1200  1400  1600  1800  other*/
+	4096, 4096, 4096, 1024, 1024, 1024, 1024, 1024, 1024, 1024, /* Power save mode CA9 MP */
+};
+
+static struct cputopo_power CA9_cpu_power = {
+	.max  = CPU_MAX_FREQ,
+	.step = CPU_TOPO_FREQ_STEP,
+	.table = table_ca9_power,
+};
+
+#define ARM_CORTEX_A9_DEFAULT_SCALE 0
+#define ARM_CORTEX_A9_POWER_SCALE 1
+/* This table list all possible cpu power configuration */
+struct cputopo_power *table_config[2] = {
+	&default_cpu_power,
+	&CA9_cpu_power,
+};
+
+struct cputopo_scale {
+	int id;
+	int freq;
+	struct cputopo_power *power;
+};
+
+/*
+ * The table will be mostly used by one cpu which will update the
+ * configuration for all cpu on a cpufreq notification
+ * or a sched_mc level change
+ */
+static struct cputopo_scale cpu_power[NR_CPUS];
+
+static void set_cpufreq_scale(unsigned int cpuid, unsigned int freq)
+{
+	unsigned int idx;
+
+	cpu_power[cpuid].freq = freq;
+
+	idx = freq / cpu_power[cpuid].power->step;
+	if (idx >= cpu_power[cpuid].power->max)
+		idx = cpu_power[cpuid].power->max - 1;
+
+	per_cpu(cpu_scale, cpuid) = cpu_power[cpuid].power->table[idx];
+	smp_wmb();
+}
+
+static void set_power_scale(unsigned int cpu, unsigned int idx)
+{
+	cpu_power[cpu].id = idx;
+	cpu_power[cpu].power = table_config[idx];
+
+	set_cpufreq_scale(cpu, cpu_power[cpu].freq);
+}
+
+static int topo_cpufreq_transition(struct notifier_block *nb,
+	unsigned long state, void *data)
+{
+	struct cpufreq_freqs *freqs = data;
+
+	if (state == CPUFREQ_POSTCHANGE || state == CPUFREQ_RESUMECHANGE)
+		set_cpufreq_scale(freqs->cpu, freqs->new);
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block topo_cpufreq_nb = {
+	.notifier_call = topo_cpufreq_transition,
+};
+
+static int topo_cpufreq_init(void)
+{
+	unsigned int cpu;
+
+	/* TODO set initial value according to current freq */
+
+	/* init core mask */
+	for_each_possible_cpu(cpu) {
+		cpu_power[cpu].freq = 0;
+		cpu_power[cpu].power = &default_cpu_power;
+	}
+
+	return cpufreq_register_notifier(&topo_cpufreq_nb,
+			CPUFREQ_TRANSITION_NOTIFIER);
+}
+#else
+#define ARM_CORTEX_A9_DEFAULT_SCALE 0
+#define ARM_CORTEX_A9_POWER_SCALE 0
+/* This table list all possible cpu power configuration */
+unsigned int table_config[1] = {
+	1024,
+};
+
+static void set_power_scale(unsigned int cpu, unsigned int idx)
+{
+	per_cpu(cpu_scale, cpu) = table_config[idx];
+}
+
+static inline int topo_cpufreq_init(void) {return 0; }
+#endif
+
+static int init_cpu_power_scale(void)
+{
+	/* register cpufreq notifer */
+	topo_cpufreq_init();
+
+	/* Do we need to change default config */
+	advanced_topology = 1;
+
+	/* Force a cpu topology update */
+	rebuild_sched_domains();
+
+	return 0;
+}
+
+core_initcall(init_cpu_power_scale);
+
+/*
+ * Update the cpu power
+ */
+
+unsigned long arch_scale_freq_power(struct sched_domain *sd, int cpu)
+{
+	return per_cpu(cpu_scale, cpu);
+}
+
+/*
+ * sched_domain flag configuration
+ */
+/* TODO add a config flag for this function */
+int arch_sd_sibling_asym_packing(void)
+{
+	if (sched_smt_power_savings || sched_mc_power_savings)
+		return SD_ASYM_PACKING;
+	return 0;
+}
+
+/*
+ * default topology function
+ */
+
+const struct cpumask *cpu_coregroup_mask(unsigned int cpu)
+{
+	return &cpu_topology[cpu].core_sibling;
+}
+
+/*
+ * clear cpu topology masks
+ */
+static void clear_cpu_topology_mask(void)
+{
+	unsigned int cpuid;
+	for_each_possible_cpu(cpuid) {
+		struct cputopo_arm *cpuid_topo = &(cpu_topology[cpuid]);
+		cpumask_clear(&cpuid_topo->core_sibling);
+		cpumask_clear(&cpuid_topo->thread_sibling);
+	}
+	smp_wmb();
+}
+
+/*
+ * default_cpu_topology_mask set the core and thread mask as described in the
+ * ARM ARM
+ */
+static inline void default_cpu_topology_mask(unsigned int cpuid)
+{
+	struct cputopo_arm *cpuid_topo = &cpu_topology[cpuid];
+	unsigned int cpu;
+
+	for_each_possible_cpu(cpu) {
+		struct cputopo_arm *cpu_topo = &cpu_topology[cpu];
+
+		if (cpuid_topo->socket_id == cpu_topo->socket_id) {
+			cpumask_set_cpu(cpuid, &cpu_topo->core_sibling);
+			if (cpu != cpuid)
+				cpumask_set_cpu(cpu,
+					&cpuid_topo->core_sibling);
+
+			if (cpuid_topo->core_id == cpu_topo->core_id) {
+				cpumask_set_cpu(cpuid,
+					&cpu_topo->thread_sibling);
+				if (cpu != cpuid)
+					cpumask_set_cpu(cpu,
+						&cpuid_topo->thread_sibling);
+			}
+		}
+	}
+	smp_wmb();
+}
+
+static void normal_cpu_topology_mask(void)
+{
+	unsigned int cpuid;
+
+	for_each_possible_cpu(cpuid) {
+		default_cpu_topology_mask(cpuid);
+		set_power_scale(cpuid, ARM_CORTEX_A9_DEFAULT_SCALE);
+	}
+	smp_wmb();
+}
+
+/*
+ * For Cortex-A9 MPcore, we emulate a multi-package topology in power mode.
+ * The goal is to gathers tasks on 1 virtual package
+ */
+static void power_cpu_topology_mask_CA9(void)
+{
+	unsigned int cpuid, cpu;
+
+	for_each_possible_cpu(cpuid) {
+		struct cputopo_arm *cpuid_topo = &cpu_topology[cpuid];
+
+		for_each_possible_cpu(cpu) {
+			struct cputopo_arm *cpu_topo = &cpu_topology[cpu];
+
+			if ((cpuid_topo->socket_id == cpu_topo->socket_id)
+			&& ((cpuid & 0x1) == (cpu & 0x1))) {
+				cpumask_set_cpu(cpuid, &cpu_topo->core_sibling);
+				if (cpu != cpuid)
+					cpumask_set_cpu(cpu,
+						&cpuid_topo->core_sibling);
+
+				if (cpuid_topo->core_id == cpu_topo->core_id) {
+					cpumask_set_cpu(cpuid,
+						&cpu_topo->thread_sibling);
+					if (cpu != cpuid)
+						cpumask_set_cpu(cpu,
+							&cpuid_topo->thread_sibling);
+				}
+			}
+		}
+		set_power_scale(cpuid, ARM_CORTEX_A9_POWER_SCALE);
+	}
+	smp_wmb();
+}
+
+#define ARM_FAMILY_MASK 0xFF0FFFF0
+#define ARM_CORTEX_A9_FAMILY 0x410FC090
+
+/* update_cpu_topology_policy select a cpu topology policy according to the
+ * available cores.
+ * TODO: The current version assumes that all cores are exactly the same which
+ * might not be true. We need to update it to take into account various
+ * configuration among which system with different kind of core.
+ */
+static int update_cpu_topology_policy(void)
+{
+	unsigned long cpuid;
+
+	if (sched_mc_power_savings == POWERSAVINGS_BALANCE_NONE) {
+		set_cpu_topology_mask = normal_cpu_topology_mask;
+		return 0;
+	}
+
+	cpuid = read_cpuid_id();
+	cpuid &= ARM_FAMILY_MASK;
+
+	switch (cpuid) {
+	case ARM_CORTEX_A9_FAMILY:
+		set_cpu_topology_mask = power_cpu_topology_mask_CA9;
+	break;
+	default:
+		set_cpu_topology_mask = normal_cpu_topology_mask;
+	break;
+	}
+
+	return 0;
+}
+
+/*
+ * store_cpu_topology is called at boot when only one cpu is running
+ * and with the mutex cpu_hotplug.lock locked, when several cpus have booted,
+ * which prevents simultaneous write access to cpu_topology array
+ */
+void store_cpu_topology(unsigned int cpuid)
+{
+	struct cputopo_arm *cpuid_topo = &cpu_topology[cpuid];
+	unsigned int mpidr;
+
+	/* If the cpu topology has been already set, just return */
+	if (cpuid_topo->core_id != -1)
+		return;
+
+	mpidr = read_cpuid_mpidr();
+
+	/* create cpu topology mapping */
+	if ((mpidr & MPIDR_SMP_BITMASK) == MPIDR_SMP_VALUE) {
+		/*
+		 * This is a multiprocessor system
+		 * multiprocessor format & multiprocessor mode field are set
+		 */
+
+		if (mpidr & MPIDR_MT_BITMASK) {
+			/* core performance interdependency */
+			cpuid_topo->thread_id = (mpidr >> MPIDR_LEVEL0_SHIFT)
+				& MPIDR_LEVEL0_MASK;
+			cpuid_topo->core_id = (mpidr >> MPIDR_LEVEL1_SHIFT)
+				& MPIDR_LEVEL1_MASK;
+			cpuid_topo->socket_id = (mpidr >> MPIDR_LEVEL2_SHIFT)
+				& MPIDR_LEVEL2_MASK;
+		} else {
+			/* largely independent cores */
+			cpuid_topo->thread_id = -1;
+			cpuid_topo->core_id = (mpidr >> MPIDR_LEVEL0_SHIFT)
+				& MPIDR_LEVEL0_MASK;
+			cpuid_topo->socket_id = (mpidr >> MPIDR_LEVEL1_SHIFT)
+				& MPIDR_LEVEL1_MASK;
+		}
+	} else {
+		/*
+		 * This is an uniprocessor system
+		 * we are in multiprocessor format but uniprocessor system
+		 * or in the old uniprocessor format
+		 */
+		cpuid_topo->thread_id = -1;
+		cpuid_topo->core_id = 0;
+		cpuid_topo->socket_id = -1;
+	}
+
+	/*
+	 * The core and thread sibling masks can also be updated during the
+	 * call of arch_update_cpu_topology
+	 */
+	default_cpu_topology_mask(cpuid);
+
+	printk(KERN_INFO "CPU%u: thread %d, cpu %d, socket %d, mpidr %x\n",
+		cpuid, cpu_topology[cpuid].thread_id,
+		cpu_topology[cpuid].core_id,
+		cpu_topology[cpuid].socket_id, mpidr);
+}
+
+/*
+ * arch_update_cpu_topology is called by the scheduler before building
+ * a new sched_domain hierarchy.
+ */
+int arch_update_cpu_topology(void)
+{
+	if (!advanced_topology)
+		return 0;
+
+	/* clear core threads mask */
+	clear_cpu_topology_mask();
+
+	/* set topology policy */
+	update_cpu_topology_policy();
+
+	/* set topology mask and power */
+	(*set_cpu_topology_mask)();
+
+	return 1;
+}
+
+/*
+ * init_cpu_topology is called at boot when only one cpu is running
+ * which prevent simultaneous write access to cpu_topology array
+ */
+void init_cpu_topology(void)
+{
+	unsigned int cpu;
+
+	/* init core mask */
+	for_each_possible_cpu(cpu) {
+		struct cputopo_arm *cpu_topo = &(cpu_topology[cpu]);
+
+		cpu_topo->thread_id = -1;
+		cpu_topo->core_id =  -1;
+		cpu_topo->socket_id = -1;
+		cpumask_clear(&cpu_topo->core_sibling);
+		cpumask_clear(&cpu_topo->thread_sibling);
+
+		per_cpu(cpu_scale, cpu) = SCHED_POWER_SCALE;
+	}
+	smp_wmb();
+}
+
+/*
+ * debugfs interface for scaling cpu power
+ */
+
+#ifdef CONFIG_DEBUG_FS
+static struct dentry *topo_debugfs_root;
+
+static ssize_t dbg_write(struct file *file, const char __user *buf,
+						size_t size, loff_t *off)
+{
+	unsigned int *value = file->f_dentry->d_inode->i_private;
+	char cdata[128];
+	unsigned long tmp;
+	unsigned int cpu;
+
+	if (size < (sizeof(cdata)-1)) {
+		if (copy_from_user(cdata, buf, size))
+			return -EFAULT;
+		cdata[size] = 0;
+		if (!strict_strtoul(cdata, 10, &tmp)) {
+			*value = tmp;
+
+#ifdef CONFIG_CPU_FREQ
+			for_each_online_cpu(cpu)
+				set_power_scale(cpu, cpu_power[cpu].id);
+#endif
+		}
+		return size;
+	}
+	return -EINVAL;
+}
+
+static ssize_t dbg_read(struct file *file, char __user *buf,
+						size_t size, loff_t *off)
+{
+	unsigned int *value = file->f_dentry->d_inode->i_private;
+	char cdata[128];
+	unsigned int len;
+
+	len = sprintf(cdata, "%u\n", *value);
+	return simple_read_from_buffer(buf, size, off, cdata, len);
+}
+
+static const struct file_operations debugfs_fops = {
+	.read = dbg_read,
+	.write = dbg_write,
+};
+
+static struct dentry *topo_debugfs_register(unsigned int cpu,
+						struct dentry *parent)
+{
+	struct dentry *cpu_d, *d;
+	char cpu_name[16];
+
+	sprintf(cpu_name, "cpu%u", cpu);
+
+	cpu_d = debugfs_create_dir(cpu_name, parent);
+	if (!cpu_d)
+		return NULL;
+
+	d = debugfs_create_file("cpu_power", S_IRUGO  | S_IWUGO,
+				cpu_d, &per_cpu(cpu_scale, cpu), &debugfs_fops);
+	if (!d)
+		goto err_out;
+
+#ifdef CONFIG_CPU_FREQ
+	d = debugfs_create_file("scale", S_IRUGO | S_IWUGO,
+				cpu_d, &cpu_power[cpu].id, &debugfs_fops);
+	if (!d)
+		goto err_out;
+
+	d = debugfs_create_file("freq", S_IRUGO,
+				cpu_d, &cpu_power[cpu].freq, &debugfs_fops);
+	if (!d)
+		goto err_out;
+#endif
+	return cpu_d;
+
+err_out:
+	debugfs_remove_recursive(cpu_d);
+	return NULL;
+}
+
+static int __init topo_debugfs_init(void)
+{
+	struct dentry *d;
+	unsigned int cpu;
+
+	d = debugfs_create_dir("cpu_topo", NULL);
+	if (!d)
+		return -ENOMEM;
+	topo_debugfs_root = d;
+
+	for_each_possible_cpu(cpu) {
+		d = topo_debugfs_register(cpu, topo_debugfs_root);
+		if (d == NULL)
+			goto err_out;
+	}
+	return 0;
+
+err_out:
+	debugfs_remove_recursive(topo_debugfs_root);
+	return -ENOMEM;
+}
+
+late_initcall(topo_debugfs_init);
+#endif
diff -urNp Kernel/arch/arm/mach-exynos/cpufreq.c HelloWorld-Renew-v1.0-n7000-jb/arch/arm/mach-exynos/cpufreq.c
--- Kernel/arch/arm/mach-exynos/cpufreq.c	2013-02-20 13:36:09.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/arch/arm/mach-exynos/cpufreq.c	2013-05-01 08:36:53.649070307 +0200
@@ -836,3 +836,54 @@ err_vdd_arm:
 	return -EINVAL;
 }
 late_initcall(exynos_cpufreq_init);
+
+ssize_t show_UV_mV_table(struct cpufreq_policy *policy, char *buf)
+{
+int i, len = 0;
+if (buf)
+{
+for (i = exynos_info->max_support_idx; i<=exynos_info->min_support_idx; i++)
+{
+if(exynos_info->freq_table[i].frequency==CPUFREQ_ENTRY_INVALID) continue;
+len += sprintf(buf + len, "%dmhz: %d mV\n", exynos_info->freq_table[i].frequency/1000,exynos_info->volt_table[i]/1000);
+}
+}
+return len;
+}
+
+ssize_t store_UV_mV_table(struct cpufreq_policy *policy,
+                                      const char *buf, size_t count)
+{
+unsigned int ret = -EINVAL;
+int i = 0;
+int j = 0;
+int u[6];
+ret = sscanf(buf, "%d %d %d %d %d %d", &u[0], &u[1], &u[2], &u[3], &u[4], &u[5]);
+if(ret != 6) {
+ret = sscanf(buf, "%d %d %d %d %d", &u[0], &u[1], &u[2], &u[3], &u[4]);
+if(ret != 5) {
+ret = sscanf(buf, "%d %d %d %d", &u[0], &u[1], &u[2], &u[3]);
+if( ret != 4) return -EINVAL;
+}
+}
+
+for( i = 0; i < 6; i++ )
+{
+if (u[i] > CPU_UV_MV_MAX / 1000)
+{
+u[i] = CPU_UV_MV_MAX / 1000;
+}
+else if (u[i] < CPU_UV_MV_MIN / 1000)
+{
+u[i] = CPU_UV_MV_MIN / 1000;
+}
+}
+
+for( i = 0; i < ret; i++)
+{
+while(exynos_info->freq_table[i+j].frequency==CPUFREQ_ENTRY_INVALID)
+j++;
+exynos_info->volt_table[i+j] = u[i]*1000;
+}
+return count;
+}
diff -urNp Kernel/arch/arm/mach-exynos/dvfs-hotplug.c HelloWorld-Renew-v1.0-n7000-jb/arch/arm/mach-exynos/dvfs-hotplug.c
--- Kernel/arch/arm/mach-exynos/dvfs-hotplug.c	2013-02-20 13:36:09.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/arch/arm/mach-exynos/dvfs-hotplug.c	2013-04-29 16:41:35.134587461 +0200
@@ -18,6 +18,7 @@
 #include <linux/reboot.h>
 #include <linux/suspend.h>
 #include <linux/io.h>
+#include <linux/earlysuspend.h>
 
 #include <plat/cpu.h>
 
@@ -31,10 +32,19 @@ static unsigned int freq_min = -1UL;
 
 static unsigned int can_hotplug;
 
+static bool screen_off;
+
 static void exynos4_integrated_dvfs_hotplug(unsigned int freq_old,
 					unsigned int freq_new)
 {
 	total_num_target_freq++;
+
+	if (screen_off) {
+		if (!cpu_online(1)) {
+                return; //if screen off and 1-core then don't hotplug
+		}
+	}
+
 	freq_in_trg = 800000;
 
 	if ((freq_old >= freq_in_trg) && (freq_new >= freq_in_trg)) {
@@ -138,6 +148,22 @@ static struct notifier_block pm_hotplug
 	.notifier_call = hotplug_pm_transition,
 };
 
+static void hotplug_early_suspend(struct early_suspend *handler)
+{
+	screen_off = true;
+}
+
+static void hotplug_late_resume(struct early_suspend *handler)
+{
+	screen_off = false;
+}
+
+static struct early_suspend hotplug_early_suspend_notifier = {
+	.suspend = hotplug_early_suspend,
+	.resume = hotplug_late_resume,
+	.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN,
+};
+
 /*
  * Note : This function should be called after intialization of CPUFreq
  * driver for exynos4. The cpufreq_frequency_table for exynos4 should be
@@ -173,6 +199,8 @@ static int __init exynos4_integrated_dvf
 
 	register_pm_notifier(&pm_hotplug);
 
+	register_early_suspend(&hotplug_early_suspend_notifier);
+
 	return cpufreq_register_notifier(&dvfs_hotplug,
 					 CPUFREQ_TRANSITION_NOTIFIER);
 }
diff -urNp Kernel/arch/arm/mach-exynos/mach-u1.c HelloWorld-Renew-v1.0-n7000-jb/arch/arm/mach-exynos/mach-u1.c
--- Kernel/arch/arm/mach-exynos/mach-u1.c	2013-02-20 13:36:09.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/arch/arm/mach-exynos/mach-u1.c	2013-04-30 15:47:24.738366618 +0200
@@ -5892,10 +5892,10 @@ static void mxt540e_power_off_oled(void)
 #define MXT540E_MAX_MT_FINGERS		10
 #define MXT540E_CHRGTIME_BATT		48
 #define MXT540E_CHRGTIME_CHRG		48
-#define MXT540E_THRESHOLD_BATT		50
-#define MXT540E_THRESHOLD_CHRG		40
-#define MXT540E_ACTVSYNCSPERX_BATT		34
-#define MXT540E_ACTVSYNCSPERX_CHRG		34
+#define MXT540E_THRESHOLD_BATT		25
+#define MXT540E_THRESHOLD_CHRG		25
+#define MXT540E_ACTVSYNCSPERX_BATT		24
+#define MXT540E_ACTVSYNCSPERX_CHRG		28
 #define MXT540E_CALCFG_BATT		98
 #define MXT540E_CALCFG_CHRG		114
 #define MXT540E_ATCHFRCCALTHR_WAKEUP		8
diff -urNp Kernel/arch/arm/mach-exynos/pm-hotplug.c HelloWorld-Renew-v1.0-n7000-jb/arch/arm/mach-exynos/pm-hotplug.c
--- Kernel/arch/arm/mach-exynos/pm-hotplug.c	2013-02-20 13:36:09.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/arch/arm/mach-exynos/pm-hotplug.c	2013-05-01 08:45:58.485071843 +0200
@@ -1,13 +1,13 @@
 /* linux/arch/arm/mach-s5pv310/pm-hotplug.c
- *
- * Copyright (c) 2010 Samsung Electronics Co., Ltd.
- *		http://www.samsung.com/
- *
- * S5PV310 - Dynamic CPU hotpluging
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
+*
+* Copyright (c) 2010 Samsung Electronics Co., Ltd.
+* http://www.samsung.com/
+*
+* S5PV310 - Dynamic CPU hotpluging
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
 */
 
 #include <linux/init.h>
@@ -26,6 +26,7 @@
 #include <linux/sched.h>
 #include <linux/suspend.h>
 #include <linux/reboot.h>
+#include <linux/earlysuspend.h>
 
 #include <plat/map-base.h>
 #include <plat/gpio-cfg.h>
@@ -35,11 +36,16 @@
 #include <linux/gpio.h>
 #include <linux/cpufreq.h>
 
+#include <linux/device.h> //for second_core by tegrak
+#include <linux/miscdevice.h> //for second_core by tegrak
+
 #define CPUMON 1
 
-#define CHECK_DELAY	(.5*HZ)
-#define TRANS_LOAD_L	20
-#define TRANS_LOAD_H	50
+#define CHECK_DELAY (.5*HZ)
+#define TRANS_LOAD_L 20
+#define TRANS_LOAD_H (TRANS_LOAD_L*3)
+#define TRANS_LOAD_L_SCREEN_OFF 35
+#define TRANS_LOAD_H_SCREEN_OFF 90
 
 #define HOTPLUG_UNLOCKED 0
 #define HOTPLUG_LOCKED 1
@@ -56,147 +62,415 @@ static unsigned int trans_load_l = TRANS
 module_param_named(loadl, trans_load_l, uint, 0644);
 static unsigned int trans_load_h = TRANS_LOAD_H;
 module_param_named(loadh, trans_load_h, uint, 0644);
+static unsigned int trans_load_l_off = TRANS_LOAD_L_SCREEN_OFF;
+module_param_named(loadl_scroff, trans_load_l_off, uint, 0644);
+static unsigned int trans_load_h_off = TRANS_LOAD_H_SCREEN_OFF;
+module_param_named(loadh_scroff, trans_load_h_off, uint, 0644);
+static unsigned int trans_load_l_inuse = TRANS_LOAD_L;
+static unsigned int trans_load_h_inuse = TRANS_LOAD_H;
 
 struct cpu_time_info {
-	cputime64_t prev_cpu_idle;
-	cputime64_t prev_cpu_wall;
-	unsigned int load;
+cputime64_t prev_cpu_idle;
+cputime64_t prev_cpu_wall;
+unsigned int load;
 };
 
 static DEFINE_PER_CPU(struct cpu_time_info, hotplug_cpu_time);
 
+static bool screen_off;
+
 /* mutex can be used since hotplug_timer does not run in
-   timer(softirq) context but in process context */
+timer(softirq) context but in process context */
 static DEFINE_MUTEX(hotplug_lock);
+static bool pm_hotplug_enabled = true;
+
+/* Second core values by tegrak */
+#define SECOND_CORE_VERSION (1)
+int second_core_on = 1;
+int hotplug_on = 1;
 
 static void hotplug_timer(struct work_struct *work)
 {
-	unsigned int i, avg_load = 0, load = 0;
-	unsigned int cur_freq;
+unsigned int i, avg_load = 0, load = 0;
+unsigned int cur_freq;
 
-	mutex_lock(&hotplug_lock);
+mutex_lock(&hotplug_lock);
+if(!pm_hotplug_enabled) {
+printk(KERN_INFO "pm-hotplug: disable cpu auto-hotplug\n");
+goto off_hotplug;
+}
 
-	if (user_lock == 1)
-		goto no_hotplug;
+// exit if we turned off dynamic hotplug by tegrak
+// cancel the timer
+if (!hotplug_on) {
+if (!second_core_on && cpu_online(1) == 1)
+cpu_down(1);
+goto off_hotplug;
+}
 
-	for_each_online_cpu(i) {
-		struct cpu_time_info *tmp_info;
-		cputime64_t cur_wall_time, cur_idle_time;
-		unsigned int idle_time, wall_time;
+if (user_lock == 1)
+goto no_hotplug;
 
-		tmp_info = &per_cpu(hotplug_cpu_time, i);
+for_each_online_cpu(i) {
+struct cpu_time_info *tmp_info;
+cputime64_t cur_wall_time, cur_idle_time;
+unsigned int idle_time, wall_time;
 
-		cur_idle_time = get_cpu_idle_time_us(i, &cur_wall_time);
+tmp_info = &per_cpu(hotplug_cpu_time, i);
 
-		idle_time = (unsigned int)cputime64_sub(cur_idle_time,
-						tmp_info->prev_cpu_idle);
-		tmp_info->prev_cpu_idle = cur_idle_time;
+cur_idle_time = get_cpu_idle_time_us(i, &cur_wall_time);
 
-		wall_time = (unsigned int)cputime64_sub(cur_wall_time,
-						tmp_info->prev_cpu_wall);
-		tmp_info->prev_cpu_wall = cur_wall_time;
+idle_time = (unsigned int)cputime64_sub(cur_idle_time,
+tmp_info->prev_cpu_idle);
+tmp_info->prev_cpu_idle = cur_idle_time;
 
-		if (wall_time < idle_time)
-			goto no_hotplug;
+wall_time = (unsigned int)cputime64_sub(cur_wall_time,
+tmp_info->prev_cpu_wall);
+tmp_info->prev_cpu_wall = cur_wall_time;
 
-		tmp_info->load = 100 * (wall_time - idle_time) / wall_time;
+if (wall_time < idle_time)
+goto no_hotplug;
 
-		load += tmp_info->load;
-	}
+tmp_info->load = 100 * (wall_time - idle_time) / wall_time;
 
-	avg_load = load / num_online_cpus();
+load += tmp_info->load;
+}
 
-	cur_freq = cpufreq_get(0);
+avg_load = load / num_online_cpus();
 
-	if (((avg_load < trans_load_l) || (cur_freq <= 200 * 1000)) &&
-	    (cpu_online(1) == 1)) {
-		printk(KERN_INFO "cpu1 turning off!\n");
-		cpu_down(1);
+cur_freq = cpufreq_get(0);
+
+if (((avg_load < trans_load_l_inuse) || (cur_freq <= 200 * 1000)) &&
+(cpu_online(1) == 1)) {
+printk(KERN_INFO "cpu1 turning off!\n");
+cpu_down(1);
 #if CPUMON
-		printk(KERN_ERR "CPUMON D %d\n", avg_load);
+printk(KERN_ERR "CPUMON D %d\n", avg_load);
 #endif
-		printk(KERN_INFO "cpu1 off end!\n");
-		hotpluging_rate = CHECK_DELAY;
-	} else if (((avg_load > trans_load_h) && (cur_freq > 200 * 1000)) &&
-		   (cpu_online(1) == 0)) {
-		printk(KERN_INFO "cpu1 turning on!\n");
-		cpu_up(1);
+printk(KERN_INFO "cpu1 off end!\n");
+hotpluging_rate = CHECK_DELAY;
+} else if (((avg_load > trans_load_h_inuse) && (cur_freq > 200 * 1000)) &&
+(cpu_online(1) == 0)) {
+printk(KERN_INFO "cpu1 turning on!\n");
+cpu_up(1);
 #if CPUMON
-		printk(KERN_ERR "CPUMON U %d\n", avg_load);
+printk(KERN_ERR "CPUMON U %d\n", avg_load);
 #endif
-		printk(KERN_INFO "cpu1 on end!\n");
-		hotpluging_rate = CHECK_DELAY * 4;
-	}
+printk(KERN_INFO "cpu1 on end!\n");
+hotpluging_rate = CHECK_DELAY * 4;
+}
  no_hotplug:
 
-	queue_delayed_work_on(0, hotplug_wq, &hotplug_work, hotpluging_rate);
+queue_delayed_work_on(0, hotplug_wq, &hotplug_work, hotpluging_rate);
 
-	mutex_unlock(&hotplug_lock);
+off_hotplug:
+mutex_unlock(&hotplug_lock);
 }
 
 static int exynos4_pm_hotplug_notifier_event(struct notifier_block *this,
-					     unsigned long event, void *ptr)
+unsigned long event, void *ptr)
 {
-	static unsigned user_lock_saved;
+static unsigned user_lock_saved;
 
-	switch (event) {
-	case PM_SUSPEND_PREPARE:
-		mutex_lock(&hotplug_lock);
-		user_lock_saved = user_lock;
-		user_lock = 1;
-		pr_info("%s: saving pm_hotplug lock %x\n",
-			__func__, user_lock_saved);
-		mutex_unlock(&hotplug_lock);
-		return NOTIFY_OK;
-	case PM_POST_RESTORE:
-	case PM_POST_SUSPEND:
-		mutex_lock(&hotplug_lock);
-		pr_info("%s: restoring pm_hotplug lock %x\n",
-			__func__, user_lock_saved);
-		user_lock = user_lock_saved;
-		mutex_unlock(&hotplug_lock);
-		return NOTIFY_OK;
-	}
-	return NOTIFY_DONE;
+switch (event) {
+case PM_SUSPEND_PREPARE:
+mutex_lock(&hotplug_lock);
+user_lock_saved = user_lock;
+user_lock = 1;
+pr_info("%s: saving pm_hotplug lock %x\n",
+__func__, user_lock_saved);
+mutex_unlock(&hotplug_lock);
+return NOTIFY_OK;
+case PM_POST_RESTORE:
+case PM_POST_SUSPEND:
+mutex_lock(&hotplug_lock);
+pr_info("%s: restoring pm_hotplug lock %x\n",
+__func__, user_lock_saved);
+user_lock = user_lock_saved;
+mutex_unlock(&hotplug_lock);
+return NOTIFY_OK;
+}
+return NOTIFY_DONE;
 }
 
 static struct notifier_block exynos4_pm_hotplug_notifier = {
-	.notifier_call = exynos4_pm_hotplug_notifier_event,
+.notifier_call = exynos4_pm_hotplug_notifier_event,
 };
 
 static int hotplug_reboot_notifier_call(struct notifier_block *this,
-					unsigned long code, void *_cmd)
+unsigned long code, void *_cmd)
 {
-	mutex_lock(&hotplug_lock);
-	pr_err("%s: disabling pm hotplug\n", __func__);
-	user_lock = 1;
-	mutex_unlock(&hotplug_lock);
+mutex_lock(&hotplug_lock);
+pr_err("%s: disabling pm hotplug\n", __func__);
+user_lock = 1;
+mutex_unlock(&hotplug_lock);
 
-	return NOTIFY_DONE;
+return NOTIFY_DONE;
 }
 
 static struct notifier_block hotplug_reboot_notifier = {
-	.notifier_call = hotplug_reboot_notifier_call,
+.notifier_call = hotplug_reboot_notifier_call,
+};
+
+static void hotplug_early_suspend(struct early_suspend *handler)
+{
+mutex_lock(&hotplug_lock);
+screen_off = true;
+trans_load_l_inuse = trans_load_l_off;
+trans_load_h_inuse = trans_load_h_off;
+mutex_unlock(&hotplug_lock);
+}
+
+static void hotplug_late_resume(struct early_suspend *handler)
+{
+printk(KERN_INFO "pm-hotplug: enable cpu auto-hotplug\n");
+
+mutex_lock(&hotplug_lock);
+screen_off = false;
+trans_load_l_inuse = trans_load_l;
+trans_load_h_inuse = trans_load_h;
+//cpu_up(1); //when the screen is on, activate the second cpu no matter what the load is
+//queue_delayed_work_on(0, hotplug_wq, &hotplug_work, hotpluging_rate);
+mutex_unlock(&hotplug_lock);
+}
+
+static struct early_suspend hotplug_early_suspend_notifier = {
+.suspend = hotplug_early_suspend,
+.resume = hotplug_late_resume,
+.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN,
+};
+
+/****************************************
+* DEVICE ATTRIBUTES FUNCTION by tegrak
+****************************************/
+#define declare_show(filename) \
+static ssize_t show_##filename(struct device *dev, struct device_attribute *attr, char *buf)
+
+#define declare_store(filename) \
+static ssize_t store_##filename(\
+struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+
+/****************************************
+* second_core attributes function by tegrak
+****************************************/
+declare_show(version) {
+return sprintf(buf, "%u\n", SECOND_CORE_VERSION);
+}
+
+declare_show(author) {
+return sprintf(buf, "Tegrak\n");
+}
+
+declare_show(hotplug_on) {
+return sprintf(buf, "%s\n", (hotplug_on) ? ("on") : ("off"));
+}
+
+declare_store(hotplug_on) {	
+mutex_lock(&hotplug_lock);
+
+if (user_lock) {
+goto finish;
+}
+
+if (!hotplug_on && strcmp(buf, "on\n") == 0) {
+hotplug_on = 1;
+// restart worker thread.
+hotpluging_rate = CHECK_DELAY;
+queue_delayed_work_on(0, hotplug_wq, &hotplug_work, hotpluging_rate);
+printk("second_core: hotplug is on!\n");
+}
+else if (hotplug_on && strcmp(buf, "off\n") == 0) {
+hotplug_on = 0;
+second_core_on = 1;
+if (cpu_online(1) == 0) {
+cpu_up(1);
+}
+printk("second_core: hotplug is off!\n");
+}
+
+finish:
+mutex_unlock(&hotplug_lock);
+return size;
+}
+
+declare_show(second_core_on) {
+return sprintf(buf, "%s\n", (second_core_on) ? ("on") : ("off"));
+}
+
+declare_store(second_core_on) {
+mutex_lock(&hotplug_lock);
+
+if (hotplug_on || user_lock) {
+goto finish;
+}
+
+if (!second_core_on && strcmp(buf, "on\n") == 0) {
+second_core_on = 1;
+if (cpu_online(1) == 0) {
+cpu_up(1);
+}
+printk("second_core: 2nd core is always on!\n");
+}
+else if (second_core_on && strcmp(buf, "off\n") == 0) {
+second_core_on = 0;
+if (cpu_online(1) == 1) {
+cpu_down(1);
+}
+printk("second_core: 2nd core is always off!\n");
+}
+
+finish:
+mutex_unlock(&hotplug_lock);
+return size;
+}
+
+/****************************************
+* DEVICE ATTRIBUTE by tegrak
+****************************************/
+#define declare_attr_rw(filename, perm) \
+static DEVICE_ATTR(filename, perm, show_##filename, store_##filename)
+#define declare_attr_ro(filename, perm) \
+static DEVICE_ATTR(filename, perm, show_##filename, NULL)
+#define declare_attr_wo(filename, perm) \
+static DEVICE_ATTR(filename, perm, NULL, store_##filename)
+
+declare_attr_ro(version, 0444);
+declare_attr_ro(author, 0444);
+declare_attr_rw(hotplug_on, 0666);
+declare_attr_rw(second_core_on, 0666);
+
+static struct attribute *second_core_attributes[] = {
+&dev_attr_hotplug_on.attr,
+&dev_attr_second_core_on.attr,
+&dev_attr_version.attr,
+&dev_attr_author.attr,
+NULL
+};
+
+static struct attribute_group second_core_group = {
+.attrs = second_core_attributes,
+};
+
+static struct miscdevice second_core_device = {
+.minor = MISC_DYNAMIC_MINOR,
+.name = "second_core",
+};
+
+static int pm_hotplug_cpufreq_policy_notifier_call(struct notifier_block *this,
+unsigned long code, void *data)
+{
+struct cpufreq_policy *policy = data;
+
+switch (code) {
+case CPUFREQ_ADJUST:
+if (
+(!strnicmp(policy->governor->name, "pegasusq", CPUFREQ_NAME_LEN)) ||
+(!strnicmp(policy->governor->name, "lulzactiveq", CPUFREQ_NAME_LEN)) ||
+(!strnicmp(policy->governor->name, "hotplug", CPUFREQ_NAME_LEN)) ||
+(!strnicmp(policy->governor->name, "assplug", CPUFREQ_NAME_LEN))
+)
+{
+if(pm_hotplug_enabled)
+{
+pr_info("Pm-hotplug is disabled: governor=%s\n",
+policy->governor->name);
+mutex_lock(&hotplug_lock);
+pm_hotplug_enabled = false;
+mutex_unlock(&hotplug_lock);
+}
+}
+else
+{
+if(!pm_hotplug_enabled)
+{
+pr_info("Pm-hotplug is enabled: governor=%s\n",
+policy->governor->name);
+mutex_lock(&hotplug_lock);
+pm_hotplug_enabled = true;
+queue_delayed_work_on(0, hotplug_wq, &hotplug_work, hotpluging_rate);
+mutex_unlock(&hotplug_lock);
+}
+}
+break;
+case CPUFREQ_INCOMPATIBLE:
+case CPUFREQ_NOTIFY:
+default:
+break;
+}
+
+return NOTIFY_DONE;
+}
+static struct notifier_block pm_hotplug_cpufreq_policy_notifier = {
+.notifier_call = pm_hotplug_cpufreq_policy_notifier_call,
 };
 
 static int __init exynos4_pm_hotplug_init(void)
 {
-	printk(KERN_INFO "EXYNOS4 PM-hotplug init function\n");
-	/* hotplug_wq = create_workqueue("dynamic hotplug"); */
-	hotplug_wq = alloc_workqueue("dynamic hotplug", 0, 0);
-	if (!hotplug_wq) {
-		printk(KERN_ERR "Creation of hotplug work failed\n");
-		return -EFAULT;
-	}
+int ret;
+printk(KERN_INFO "EXYNOS4 PM-hotplug init function\n");
+/* hotplug_wq = create_workqueue("dynamic hotplug"); */
+hotplug_wq = alloc_workqueue("dynamic hotplug", 0, 0);
+if (!hotplug_wq) {
+printk(KERN_ERR "Creation of hotplug work failed\n");
+return -EFAULT;
+}
+
+#if defined(CONFIG_CPU_FREQ_DEFAULT_GOV_PEGASUSQ) || \
+defined(CONFIG_CPU_FREQ_DEFAULT_GOV_HOTPLUG) || \
+defined(CONFIG_CPU_FREQ_DEFAULT_GOV_LULZACTIVEQ)
+pm_hotplug_enabled = 0;
+#else
+pm_hotplug_enabled = 1;
+#endif
+
+INIT_DELAYED_WORK(&hotplug_work, hotplug_timer);
 
-	INIT_DELAYED_WORK(&hotplug_work, hotplug_timer);
+queue_delayed_work_on(0, hotplug_wq, &hotplug_work, 60 * HZ);
+
+register_pm_notifier(&exynos4_pm_hotplug_notifier);
+register_reboot_notifier(&hotplug_reboot_notifier);
+register_early_suspend(&hotplug_early_suspend_notifier);
+
+// register second_core device by tegrak
+ret = misc_register(&second_core_device);
+if (ret) {
+printk(KERN_ERR "failed at(%d)\n", __LINE__);
+return ret;
+}
+
+ret = sysfs_create_group(&second_core_device.this_device->kobj, &second_core_group);
+if (ret)
+{
+printk(KERN_ERR "failed at(%d)\n", __LINE__);
+return ret;
+}
 
-	queue_delayed_work_on(0, hotplug_wq, &hotplug_work, 60 * HZ);
+cpufreq_register_notifier(&pm_hotplug_cpufreq_policy_notifier,
+CPUFREQ_POLICY_NOTIFIER);
+return 0;
+}
+
+late_initcall(exynos4_pm_hotplug_init);
+
+static struct platform_device exynos4_pm_hotplug_device = {
+.name = "exynos4-dynamic-cpu-hotplug",
+.id = -1,
+};
+
+static int __init exynos4_pm_hotplug_device_init(void)
+{
+int ret;
+
+ret = platform_device_register(&exynos4_pm_hotplug_device);
+
+if (ret) {
+printk(KERN_ERR "failed at(%d)\n", __LINE__);
+return ret;
+}
 
-	register_pm_notifier(&exynos4_pm_hotplug_notifier);
-	register_reboot_notifier(&hotplug_reboot_notifier);
+printk(KERN_INFO "exynos4_pm_hotplug_device_init: %d\n", ret);
 
-	return 0;
+return ret;
 }
 
 late_initcall(exynos4_pm_hotplug_init);
diff -urNp Kernel/arch/arm/mach-exynos/stand-hotplug.c HelloWorld-Renew-v1.0-n7000-jb/arch/arm/mach-exynos/stand-hotplug.c
--- Kernel/arch/arm/mach-exynos/stand-hotplug.c	2013-02-20 13:36:09.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/arch/arm/mach-exynos/stand-hotplug.c	2013-04-29 16:41:35.134587461 +0200
@@ -87,7 +87,7 @@
 
 #define HOTPLUG_UNLOCKED 0
 #define HOTPLUG_LOCKED 1
-#define PM_HOTPLUG_DEBUG 1
+#define PM_HOTPLUG_DEBUG 0
 #define NUM_CPUS num_possible_cpus()
 #define CPULOAD_TABLE (NR_CPUS + 1)
 
diff -urNp Kernel/arch/arm/mm/fault.c HelloWorld-Renew-v1.0-n7000-jb/arch/arm/mm/fault.c
--- Kernel/arch/arm/mm/fault.c	2013-02-20 13:36:11.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/arch/arm/mm/fault.c	2013-04-29 16:41:35.138587461 +0200
@@ -24,7 +24,7 @@
 #include <asm/pgtable.h>
 #include <asm/tlbflush.h>
 
-#if defined(CONFIG_MACH_Q1_BD)
+#if defined(CONFIG_MACH_Q1_BD) && defined(SEC_DEBUG)
 #include <mach/sec_debug.h>
 #endif
 
@@ -166,7 +166,7 @@ __do_kernel_fault(struct mm_struct *mm,
 	do_exit(SIGKILL);
 }
 
-#if defined(CONFIG_MACH_Q1_BD)
+#if defined(CONFIG_MACH_Q1_BD) && defined(SEC_DEBUG)
 /*
  * This function can be used while current pointer is invalid.
  */
@@ -310,7 +310,7 @@ do_page_fault(unsigned long addr, unsign
 		return 0;
 
 	tsk = current;
-#if defined(CONFIG_MACH_Q1_BD)
+#if defined(CONFIG_MACH_Q1_BD) && defined(SEC_DEBUG)
 	/*
 	 * If current pointer is NULL, infinite abort can occur.
 	 * It make us get correct debug information in the situation.
diff -urNp Kernel/block/Kconfig.iosched HelloWorld-Renew-v1.0-n7000-jb/block/Kconfig.iosched
--- Kernel/block/Kconfig.iosched	2013-02-20 13:36:17.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/block/Kconfig.iosched	2013-05-01 11:26:39.409099024 +0200
@@ -43,6 +43,34 @@ config CFQ_GROUP_IOSCHED
 	---help---
 	  Enable group IO scheduling in CFQ.
 
+config IOSCHED_ROW
+	tristate "ROW I/O scheduler"
+	default y
+	---help---
+	  The ROW I/O scheduler gives priority to READ requests over the
+	  WRITE requests when dispatching, without starving WRITE requests.
+	  Requests are kept in priority queues. Dispatching is done in a RR
+	  manner when the dispatch quantum for each queue is calculated
+	  according to queue priority.
+	  Most suitable for mobile devices.
+
+config IOSCHED_SIO
+	tristate "Simple I/O scheduler"
+	default y
+	---help---
+	  The Simple I/O scheduler is an extremely simple scheduler,
+	  based on noop and deadline, that relies on deadlines to
+	  ensure fairness. The algorithm does not do any sorting but
+	  basic merging, trying to keep a minimum overhead. It is aimed
+	  mainly for aleatory access devices (eg: flash devices).
+
+config IOSCHED_VR
+	tristate "V(R) I/O scheduler"
+	default y
+	---help---
+	  Requests are chosen according to SSTF with a penalty of rev_penalty
+	  for switching head direction.
+
 choice
 	prompt "Default I/O scheduler"
 	default DEFAULT_CFQ
@@ -56,6 +84,15 @@ choice
 	config DEFAULT_CFQ
 		bool "CFQ" if IOSCHED_CFQ=y
 
+	config DEFAULT_ROW
+		bool "ROW" if IOSCHED_ROW=y
+
+	config DEFAULT_SIO
+		bool "SIO" if IOSCHED_SIO=y
+
+	config DEFAULT_VR
+		bool "V(R)" if IOSCHED_VR=y
+
 	config DEFAULT_NOOP
 		bool "No-op"
 
@@ -65,6 +102,9 @@ config DEFAULT_IOSCHED
 	string
 	default "deadline" if DEFAULT_DEADLINE
 	default "cfq" if DEFAULT_CFQ
+	default "row" if DEFAULT_ROW
+	default "sio" if DEFAULT_SIO
+	default "vr" if DEFAULT_VR
 	default "noop" if DEFAULT_NOOP
 
 endmenu
diff -urNp Kernel/block/Makefile HelloWorld-Renew-v1.0-n7000-jb/block/Makefile
--- Kernel/block/Makefile	2013-02-20 13:36:17.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/block/Makefile	2013-04-25 17:38:09.000000000 +0200
@@ -13,6 +13,9 @@ obj-$(CONFIG_BLK_DEV_THROTTLING)	+= blk-
 obj-$(CONFIG_IOSCHED_NOOP)	+= noop-iosched.o
 obj-$(CONFIG_IOSCHED_DEADLINE)	+= deadline-iosched.o
 obj-$(CONFIG_IOSCHED_CFQ)	+= cfq-iosched.o
+obj-$(CONFIG_IOSCHED_ROW)	+= row-iosched.o
+obj-$(CONFIG_IOSCHED_SIO)       += sio-iosched.o
+obj-$(CONFIG_IOSCHED_VR)        += vr-iosched.o
 
 obj-$(CONFIG_BLOCK_COMPAT)	+= compat_ioctl.o
 obj-$(CONFIG_BLK_DEV_INTEGRITY)	+= blk-integrity.o
diff -urNp Kernel/block/row-iosched.c HelloWorld-Renew-v1.0-n7000-jb/block/row-iosched.c
--- Kernel/block/row-iosched.c	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/block/row-iosched.c	2013-04-26 22:26:51.000000000 +0200
@@ -0,0 +1,694 @@
+/*
+ * ROW (Read Over Write) I/O scheduler.
+ *
+ * Copyright (c) 2012, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/* See Documentation/block/row-iosched.txt */
+
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/blkdev.h>
+#include <linux/elevator.h>
+#include <linux/bio.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/compiler.h>
+#include <linux/blktrace_api.h>
+#include <linux/jiffies.h>
+
+/*
+ * enum row_queue_prio - Priorities of the ROW queues
+ *
+ * This enum defines the priorities (and the number of queues)
+ * the requests will be disptributed to. The higher priority -
+ * the bigger is the dispatch quantum given to that queue.
+ * ROWQ_PRIO_HIGH_READ - is the higher priority queue.
+ *
+ */
+enum row_queue_prio {
+	ROWQ_PRIO_HIGH_READ = 0,
+	ROWQ_PRIO_REG_READ,
+	ROWQ_PRIO_HIGH_SWRITE,
+	ROWQ_PRIO_REG_SWRITE,
+	ROWQ_PRIO_REG_WRITE,
+	ROWQ_PRIO_LOW_READ,
+	ROWQ_PRIO_LOW_SWRITE,
+	ROWQ_MAX_PRIO,
+};
+
+/* Flags indicating whether idling is enabled on the queue */
+static const bool queue_idling_enabled[] = {
+	true,	/* ROWQ_PRIO_HIGH_READ */
+	true,	/* ROWQ_PRIO_REG_READ */
+	false,	/* ROWQ_PRIO_HIGH_SWRITE */
+	false,	/* ROWQ_PRIO_REG_SWRITE */
+	false,	/* ROWQ_PRIO_REG_WRITE */
+	false,	/* ROWQ_PRIO_LOW_READ */
+	false,	/* ROWQ_PRIO_LOW_SWRITE */
+};
+
+/* Default values for row queues quantums in each dispatch cycle */
+static const int queue_quantum[] = {
+	100,	/* ROWQ_PRIO_HIGH_READ */
+	100,	/* ROWQ_PRIO_REG_READ */
+	2,	/* ROWQ_PRIO_HIGH_SWRITE */
+	1,	/* ROWQ_PRIO_REG_SWRITE */
+	1,	/* ROWQ_PRIO_REG_WRITE */
+	1,	/* ROWQ_PRIO_LOW_READ */
+	1	/* ROWQ_PRIO_LOW_SWRITE */
+};
+
+/* Default values for idling on read queues */
+#define ROW_IDLE_TIME_MSEC 10	/* msec */
+#define ROW_READ_FREQ_MSEC 25	/* msec */
+
+/**
+ * struct rowq_idling_data -  parameters for idling on the queue
+ * @last_insert_time:	time the last request was inserted
+ *			to the queue
+ * @begin_idling:	flag indicating wether we should idle
+ *
+ */
+struct rowq_idling_data {
+	ktime_t			last_insert_time;
+	bool			begin_idling;
+};
+
+/**
+ * struct row_queue - requests grouping structure
+ * @rdata:		parent row_data structure
+ * @fifo:		fifo of requests
+ * @prio:		queue priority (enum row_queue_prio)
+ * @nr_dispatched:	number of requests already dispatched in
+ *			the current dispatch cycle
+ * @slice:		number of requests to dispatch in a cycle
+ * @idle_data:		data for idling on queues
+ *
+ */
+struct row_queue {
+	struct row_data		*rdata;
+	struct list_head	fifo;
+	enum row_queue_prio	prio;
+
+	unsigned int		nr_dispatched;
+	unsigned int		slice;
+
+	/* used only for READ queues */
+	struct rowq_idling_data	idle_data;
+};
+
+/**
+ * struct idling_data - data for idling on empty rqueue
+ * @idle_time:		idling duration (jiffies)
+ * @freq:		min time between two requests that
+ *			triger idling (msec)
+ * @idle_work:		pointer to struct delayed_work
+ *
+ */
+struct idling_data {
+	unsigned long			idle_time;
+	u32				freq;
+
+	struct workqueue_struct	*idle_workqueue;
+	struct delayed_work		idle_work;
+};
+
+/**
+ * struct row_queue - Per block device rqueue structure
+ * @dispatch_queue:	dispatch rqueue
+ * @row_queues:		array of priority request queues with
+ *			dispatch quantum per rqueue
+ * @curr_queue:		index in the row_queues array of the
+ *			currently serviced rqueue
+ * @read_idle:		data for idling after READ request
+ * @nr_reqs: nr_reqs[0] holds the number of all READ requests in
+ *			scheduler, nr_reqs[1] holds the number of all WRITE
+ *			requests in scheduler
+ * @cycle_flags:	used for marking unserved queueus
+ *
+ */
+struct row_data {
+	struct request_queue		*dispatch_queue;
+
+	struct {
+		struct row_queue	rqueue;
+		int			disp_quantum;
+	} row_queues[ROWQ_MAX_PRIO];
+
+	enum row_queue_prio		curr_queue;
+
+	struct idling_data		read_idle;
+	unsigned int			nr_reqs[2];
+
+	unsigned int			cycle_flags;
+};
+
+#define RQ_ROWQ(rq) ((struct row_queue *) ((rq)->elevator_private[0]))
+
+#define row_log(q, fmt, args...)   \
+	blk_add_trace_msg(q, "%s():" fmt , __func__, ##args)
+#define row_log_rowq(rdata, rowq_id, fmt, args...)		\
+	blk_add_trace_msg(rdata->dispatch_queue, "rowq%d " fmt, \
+		rowq_id, ##args)
+
+static inline void row_mark_rowq_unserved(struct row_data *rd,
+					 enum row_queue_prio qnum)
+{
+	rd->cycle_flags |= (1 << qnum);
+}
+
+static inline void row_clear_rowq_unserved(struct row_data *rd,
+					  enum row_queue_prio qnum)
+{
+	rd->cycle_flags &= ~(1 << qnum);
+}
+
+static inline int row_rowq_unserved(struct row_data *rd,
+				   enum row_queue_prio qnum)
+{
+	return rd->cycle_flags & (1 << qnum);
+}
+
+/******************** Static helper functions ***********************/
+/*
+ * kick_queue() - Wake up device driver queue thread
+ * @work:	pointer to struct work_struct
+ *
+ * This is a idling delayed work function. It's purpose is to wake up the
+ * device driver in order for it to start fetching requests.
+ *
+ */
+static void kick_queue(struct work_struct *work)
+{
+	struct delayed_work *idle_work = to_delayed_work(work);
+	struct idling_data *read_data =
+		container_of(idle_work, struct idling_data, idle_work);
+	struct row_data *rd =
+		container_of(read_data, struct row_data, read_idle);
+
+	row_log_rowq(rd, rd->curr_queue, "Performing delayed work");
+	/* Mark idling process as done */
+	rd->row_queues[rd->curr_queue].rqueue.idle_data.begin_idling = false;
+
+	if (!(rd->nr_reqs[0] + rd->nr_reqs[1]))
+		row_log(rd->dispatch_queue, "No requests in scheduler");
+	else {
+		spin_lock_irq(rd->dispatch_queue->queue_lock);
+		__blk_run_queue(rd->dispatch_queue);
+		spin_unlock_irq(rd->dispatch_queue->queue_lock);
+	}
+}
+
+/*
+ * row_restart_disp_cycle() - Restart the dispatch cycle
+ * @rd:	pointer to struct row_data
+ *
+ * This function restarts the dispatch cycle by:
+ * - Setting current queue to ROWQ_PRIO_HIGH_READ
+ * - For each queue: reset the number of requests dispatched in
+ *   the cycle
+ */
+static inline void row_restart_disp_cycle(struct row_data *rd)
+{
+	int i;
+
+	for (i = 0; i < ROWQ_MAX_PRIO; i++)
+		rd->row_queues[i].rqueue.nr_dispatched = 0;
+
+	rd->curr_queue = ROWQ_PRIO_HIGH_READ;
+	row_log(rd->dispatch_queue, "Restarting cycle");
+}
+
+static inline void row_get_next_queue(struct row_data *rd)
+{
+	rd->curr_queue++;
+	if (rd->curr_queue == ROWQ_MAX_PRIO)
+		row_restart_disp_cycle(rd);
+}
+
+/******************* Elevator callback functions *********************/
+
+/*
+ * row_add_request() - Add request to the scheduler
+ * @q:	requests queue
+ * @rq:	request to add
+ *
+ */
+static void row_add_request(struct request_queue *q,
+			    struct request *rq)
+{
+	struct row_data *rd = (struct row_data *)q->elevator->elevator_data;
+	struct row_queue *rqueue = RQ_ROWQ(rq);
+
+	list_add_tail(&rq->queuelist, &rqueue->fifo);
+	rd->nr_reqs[rq_data_dir(rq)]++;
+	rq_set_fifo_time(rq, jiffies); /* for statistics*/
+
+	if (queue_idling_enabled[rqueue->prio]) {
+		if (delayed_work_pending(&rd->read_idle.idle_work))
+			(void)cancel_delayed_work(
+				&rd->read_idle.idle_work);
+		if (ktime_to_ms(ktime_sub(ktime_get(),
+				rqueue->idle_data.last_insert_time)) <
+				rd->read_idle.freq) {
+			rqueue->idle_data.begin_idling = true;
+			row_log_rowq(rd, rqueue->prio, "Enable idling");
+		} else {
+			rqueue->idle_data.begin_idling = false;
+			row_log_rowq(rd, rqueue->prio, "Disable idling");
+		}
+
+		rqueue->idle_data.last_insert_time = ktime_get();
+	}
+	row_log_rowq(rd, rqueue->prio, "added request");
+}
+
+/*
+ * row_remove_request() -  Remove given request from scheduler
+ * @q:	requests queue
+ * @rq:	request to remove
+ *
+ */
+static void row_remove_request(struct request_queue *q,
+			       struct request *rq)
+{
+	struct row_data *rd = (struct row_data *)q->elevator->elevator_data;
+
+	rq_fifo_clear(rq);
+	rd->nr_reqs[rq_data_dir(rq)]--;
+}
+
+/*
+ * row_dispatch_insert() - move request to dispatch queue
+ * @rd:	pointer to struct row_data
+ *
+ * This function moves the next request to dispatch from
+ * rd->curr_queue to the dispatch queue
+ *
+ */
+static void row_dispatch_insert(struct row_data *rd)
+{
+	struct request *rq;
+
+	rq = rq_entry_fifo(rd->row_queues[rd->curr_queue].rqueue.fifo.next);
+	row_remove_request(rd->dispatch_queue, rq);
+	elv_dispatch_add_tail(rd->dispatch_queue, rq);
+	rd->row_queues[rd->curr_queue].rqueue.nr_dispatched++;
+	row_clear_rowq_unserved(rd, rd->curr_queue);
+	row_log_rowq(rd, rd->curr_queue, " Dispatched request nr_disp = %d",
+		     rd->row_queues[rd->curr_queue].rqueue.nr_dispatched);
+}
+
+/*
+ * row_choose_queue() -  choose the next queue to dispatch from
+ * @rd:	pointer to struct row_data
+ *
+ * Updates rd->curr_queue. Returns 1 if there are requests to
+ * dispatch, 0 if there are no requests in scheduler
+ *
+ */
+static int row_choose_queue(struct row_data *rd)
+{
+	int prev_curr_queue = rd->curr_queue;
+
+	if (!(rd->nr_reqs[0] + rd->nr_reqs[1])) {
+		row_log(rd->dispatch_queue, "No more requests in scheduler");
+		return 0;
+	}
+
+	row_get_next_queue(rd);
+
+	/*
+	 * Loop over all queues to find the next queue that is not empty.
+	 * Stop when you get back to curr_queue
+	 */
+	while (list_empty(&rd->row_queues[rd->curr_queue].rqueue.fifo)
+	       && rd->curr_queue != prev_curr_queue) {
+		/* Mark rqueue as unserved */
+		row_mark_rowq_unserved(rd, rd->curr_queue);
+		row_get_next_queue(rd);
+	}
+
+	return 1;
+}
+
+/*
+ * row_dispatch_requests() - selects the next request to dispatch
+ * @q:		requests queue
+ * @force:	ignored
+ *
+ * Return 0 if no requests were moved to the dispatch queue.
+ *	  1 otherwise
+ *
+ */
+static int row_dispatch_requests(struct request_queue *q, int force)
+{
+	struct row_data *rd = (struct row_data *)q->elevator->elevator_data;
+	int ret = 0, currq, i;
+
+	currq = rd->curr_queue;
+
+	/*
+	 * Find the first unserved queue (with higher priority then currq)
+	 * that is not empty
+	 */
+	for (i = 0; i < currq; i++) {
+		if (row_rowq_unserved(rd, i) &&
+		    !list_empty(&rd->row_queues[i].rqueue.fifo)) {
+			row_log_rowq(rd, currq,
+				" Preemting for unserved rowq%d", i);
+			rd->curr_queue = i;
+			row_dispatch_insert(rd);
+			ret = 1;
+			goto done;
+		}
+	}
+
+	if (rd->row_queues[currq].rqueue.nr_dispatched >=
+	    rd->row_queues[currq].disp_quantum) {
+		rd->row_queues[currq].rqueue.nr_dispatched = 0;
+		row_log_rowq(rd, currq, "Expiring rqueue");
+		ret = row_choose_queue(rd);
+		if (ret)
+			row_dispatch_insert(rd);
+		goto done;
+	}
+
+	/* Dispatch from curr_queue */
+	if (list_empty(&rd->row_queues[currq].rqueue.fifo)) {
+		/* check idling */
+		if (delayed_work_pending(&rd->read_idle.idle_work)) {
+			if (force) {
+				(void)cancel_delayed_work(
+				&rd->read_idle.idle_work);
+				row_log_rowq(rd, currq,
+					"Canceled delayed work - forced dispatch");
+			} else {
+				row_log_rowq(rd, currq,
+						 "Delayed work pending. Exiting");
+				goto done;
+			}
+		}
+
+		if (!force && queue_idling_enabled[currq] &&
+		    rd->row_queues[currq].rqueue.idle_data.begin_idling) {
+			if (!queue_delayed_work(rd->read_idle.idle_workqueue,
+						&rd->read_idle.idle_work,
+						rd->read_idle.idle_time)) {
+				row_log_rowq(rd, currq,
+					     "Work already on queue!");
+				pr_err("ROW_BUG: Work already on queue!");
+			} else
+				row_log_rowq(rd, currq,
+				     "Scheduled delayed work. exiting");
+			goto done;
+		} else {
+			row_log_rowq(rd, currq,
+				     "Currq empty. Choose next queue");
+			ret = row_choose_queue(rd);
+			if (!ret)
+				goto done;
+		}
+	}
+
+	ret = 1;
+	row_dispatch_insert(rd);
+
+done:
+	return ret;
+}
+
+/*
+ * row_init_queue() - Init scheduler data structures
+ * @q:	requests queue
+ *
+ * Return pointer to struct row_data to be saved in elevator for
+ * this dispatch queue
+ *
+ */
+static void *row_init_queue(struct request_queue *q)
+{
+
+	struct row_data *rdata;
+	int i;
+
+	rdata = kmalloc_node(sizeof(*rdata),
+			     GFP_KERNEL | __GFP_ZERO, q->node);
+	if (!rdata)
+		return NULL;
+
+	for (i = 0; i < ROWQ_MAX_PRIO; i++) {
+		INIT_LIST_HEAD(&rdata->row_queues[i].rqueue.fifo);
+		rdata->row_queues[i].disp_quantum = queue_quantum[i];
+		rdata->row_queues[i].rqueue.rdata = rdata;
+		rdata->row_queues[i].rqueue.prio = i;
+		rdata->row_queues[i].rqueue.idle_data.begin_idling = false;
+		rdata->row_queues[i].rqueue.idle_data.last_insert_time =
+			ktime_set(0, 0);
+	}
+
+	/*
+	 * Currently idling is enabled only for READ queues. If we want to
+	 * enable it for write queues also, note that idling frequency will
+	 * be the same in both cases
+	 */
+	rdata->read_idle.idle_time = msecs_to_jiffies(ROW_IDLE_TIME_MSEC);
+	/* Maybe 0 on some platforms */
+	if (!rdata->read_idle.idle_time)
+		rdata->read_idle.idle_time = 1;
+	rdata->read_idle.freq = ROW_READ_FREQ_MSEC;
+	rdata->read_idle.idle_workqueue = alloc_workqueue("row_idle_work",
+					    WQ_MEM_RECLAIM | WQ_HIGHPRI, 0);
+	if (!rdata->read_idle.idle_workqueue)
+		panic("Failed to create idle workqueue\n");
+	INIT_DELAYED_WORK(&rdata->read_idle.idle_work, kick_queue);
+
+	rdata->curr_queue = ROWQ_PRIO_HIGH_READ;
+	rdata->dispatch_queue = q;
+
+	rdata->nr_reqs[READ] = rdata->nr_reqs[WRITE] = 0;
+
+	return rdata;
+}
+
+/*
+ * row_exit_queue() - called on unloading the RAW scheduler
+ * @e:	poiner to struct elevator_queue
+ *
+ */
+static void row_exit_queue(struct elevator_queue *e)
+{
+	struct row_data *rd = (struct row_data *)e->elevator_data;
+	int i;
+
+	for (i = 0; i < ROWQ_MAX_PRIO; i++)
+		BUG_ON(!list_empty(&rd->row_queues[i].rqueue.fifo));
+	(void)cancel_delayed_work_sync(&rd->read_idle.idle_work);
+	BUG_ON(delayed_work_pending(&rd->read_idle.idle_work));
+	destroy_workqueue(rd->read_idle.idle_workqueue);
+	kfree(rd);
+}
+
+/*
+ * row_merged_requests() - Called when 2 requests are merged
+ * @q:		requests queue
+ * @rq:		request the two requests were merged into
+ * @next:	request that was merged
+ */
+static void row_merged_requests(struct request_queue *q, struct request *rq,
+				 struct request *next)
+{
+	struct row_queue   *rqueue = RQ_ROWQ(next);
+
+	list_del_init(&next->queuelist);
+
+	rqueue->rdata->nr_reqs[rq_data_dir(rq)]--;
+}
+
+/*
+ * get_queue_type() - Get queue type for a given request
+ *
+ * This is a helping function which purpose is to determine what
+ * ROW queue the given request should be added to (and
+ * dispatched from leter on)
+ *
+ * TODO: Right now only 3 queues are used REG_READ, REG_WRITE
+ * and REG_SWRITE
+ */
+static enum row_queue_prio get_queue_type(struct request *rq)
+{
+	const int data_dir = rq_data_dir(rq);
+	const bool is_sync = rq_is_sync(rq);
+
+	if (data_dir == READ)
+		return ROWQ_PRIO_REG_READ;
+	else if (is_sync)
+		return ROWQ_PRIO_REG_SWRITE;
+	else
+		return ROWQ_PRIO_REG_WRITE;
+}
+
+/*
+ * row_set_request() - Set ROW data structures associated with this request.
+ * @q:		requests queue
+ * @rq:		pointer to the request
+ * @gfp_mask:	ignored
+ *
+ */
+static int
+row_set_request(struct request_queue *q, struct request *rq, gfp_t gfp_mask)
+{
+	struct row_data *rd = (struct row_data *)q->elevator->elevator_data;
+	unsigned long flags;
+
+	spin_lock_irqsave(q->queue_lock, flags);
+	rq->elevator_private[0] =
+		(void *)(&rd->row_queues[get_queue_type(rq)]);
+	spin_unlock_irqrestore(q->queue_lock, flags);
+
+	return 0;
+}
+
+/********** Helping sysfs functions/defenitions for ROW attributes ******/
+static ssize_t row_var_show(int var, char *page)
+{
+	return snprintf(page, 100, "%d\n", var);
+}
+
+static ssize_t row_var_store(int *var, const char *page, size_t count)
+{
+	int err;
+	err = kstrtoul(page, 10, (unsigned long *)var);
+
+	return count;
+}
+
+#define SHOW_FUNCTION(__FUNC, __VAR, __CONV)				\
+static ssize_t __FUNC(struct elevator_queue *e, char *page)		\
+{									\
+	struct row_data *rowd = e->elevator_data;			\
+	int __data = __VAR;						\
+	if (__CONV)							\
+		__data = jiffies_to_msecs(__data);			\
+	return row_var_show(__data, (page));			\
+}
+SHOW_FUNCTION(row_hp_read_quantum_show,
+	rowd->row_queues[ROWQ_PRIO_HIGH_READ].disp_quantum, 0);
+SHOW_FUNCTION(row_rp_read_quantum_show,
+	rowd->row_queues[ROWQ_PRIO_REG_READ].disp_quantum, 0);
+SHOW_FUNCTION(row_hp_swrite_quantum_show,
+	rowd->row_queues[ROWQ_PRIO_HIGH_SWRITE].disp_quantum, 0);
+SHOW_FUNCTION(row_rp_swrite_quantum_show,
+	rowd->row_queues[ROWQ_PRIO_REG_SWRITE].disp_quantum, 0);
+SHOW_FUNCTION(row_rp_write_quantum_show,
+	rowd->row_queues[ROWQ_PRIO_REG_WRITE].disp_quantum, 0);
+SHOW_FUNCTION(row_lp_read_quantum_show,
+	rowd->row_queues[ROWQ_PRIO_LOW_READ].disp_quantum, 0);
+SHOW_FUNCTION(row_lp_swrite_quantum_show,
+	rowd->row_queues[ROWQ_PRIO_LOW_SWRITE].disp_quantum, 0);
+SHOW_FUNCTION(row_read_idle_show, rowd->read_idle.idle_time, 1);
+SHOW_FUNCTION(row_read_idle_freq_show, rowd->read_idle.freq, 0);
+#undef SHOW_FUNCTION
+
+#define STORE_FUNCTION(__FUNC, __PTR, MIN, MAX, __CONV)			\
+static ssize_t __FUNC(struct elevator_queue *e,				\
+		const char *page, size_t count)				\
+{									\
+	struct row_data *rowd = e->elevator_data;			\
+	int __data;						\
+	int ret = row_var_store(&__data, (page), count);		\
+	if (__CONV)							\
+		__data = (int)msecs_to_jiffies(__data);			\
+	if (__data < (MIN))						\
+		__data = (MIN);						\
+	else if (__data > (MAX))					\
+		__data = (MAX);						\
+	*(__PTR) = __data;						\
+	return ret;							\
+}
+STORE_FUNCTION(row_hp_read_quantum_store,
+&rowd->row_queues[ROWQ_PRIO_HIGH_READ].disp_quantum, 1, INT_MAX, 0);
+STORE_FUNCTION(row_rp_read_quantum_store,
+			&rowd->row_queues[ROWQ_PRIO_REG_READ].disp_quantum,
+			1, INT_MAX, 0);
+STORE_FUNCTION(row_hp_swrite_quantum_store,
+			&rowd->row_queues[ROWQ_PRIO_HIGH_SWRITE].disp_quantum,
+			1, INT_MAX, 0);
+STORE_FUNCTION(row_rp_swrite_quantum_store,
+			&rowd->row_queues[ROWQ_PRIO_REG_SWRITE].disp_quantum,
+			1, INT_MAX, 0);
+STORE_FUNCTION(row_rp_write_quantum_store,
+			&rowd->row_queues[ROWQ_PRIO_REG_WRITE].disp_quantum,
+			1, INT_MAX, 0);
+STORE_FUNCTION(row_lp_read_quantum_store,
+			&rowd->row_queues[ROWQ_PRIO_LOW_READ].disp_quantum,
+			1, INT_MAX, 0);
+STORE_FUNCTION(row_lp_swrite_quantum_store,
+			&rowd->row_queues[ROWQ_PRIO_LOW_SWRITE].disp_quantum,
+			1, INT_MAX, 1);
+STORE_FUNCTION(row_read_idle_store, &rowd->read_idle.idle_time, 1, INT_MAX, 1);
+STORE_FUNCTION(row_read_idle_freq_store, &rowd->read_idle.freq, 1, INT_MAX, 0);
+
+#undef STORE_FUNCTION
+
+#define ROW_ATTR(name) \
+	__ATTR(name, S_IRUGO|S_IWUSR, row_##name##_show, \
+				      row_##name##_store)
+
+static struct elv_fs_entry row_attrs[] = {
+	ROW_ATTR(hp_read_quantum),
+	ROW_ATTR(rp_read_quantum),
+	ROW_ATTR(hp_swrite_quantum),
+	ROW_ATTR(rp_swrite_quantum),
+	ROW_ATTR(rp_write_quantum),
+	ROW_ATTR(lp_read_quantum),
+	ROW_ATTR(lp_swrite_quantum),
+	ROW_ATTR(read_idle),
+	ROW_ATTR(read_idle_freq),
+	__ATTR_NULL
+};
+
+static struct elevator_type iosched_row = {
+	.ops = {
+		.elevator_merge_req_fn		= row_merged_requests,
+		.elevator_dispatch_fn		= row_dispatch_requests,
+		.elevator_add_req_fn		= row_add_request,
+		.elevator_former_req_fn		= elv_rb_former_request,
+		.elevator_latter_req_fn		= elv_rb_latter_request,
+		.elevator_set_req_fn		= row_set_request,
+		.elevator_init_fn		= row_init_queue,
+		.elevator_exit_fn		= row_exit_queue,
+	},
+
+	.elevator_attrs = row_attrs,
+	.elevator_name = "row",
+	.elevator_owner = THIS_MODULE,
+};
+
+static int __init row_init(void)
+{
+	elv_register(&iosched_row);
+	return 0;
+}
+
+static void __exit row_exit(void)
+{
+	elv_unregister(&iosched_row);
+}
+
+module_init(row_init);
+module_exit(row_exit);
+
+MODULE_LICENSE("GPLv2");
+MODULE_DESCRIPTION("Read Over Write IO scheduler");
diff -urNp Kernel/block/sio-iosched.c HelloWorld-Renew-v1.0-n7000-jb/block/sio-iosched.c
--- Kernel/block/sio-iosched.c	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/block/sio-iosched.c	2013-04-25 17:38:09.000000000 +0200
@@ -0,0 +1,399 @@
+/*
+ * Simple IO scheduler
+ * Based on Noop, Deadline and V(R) IO schedulers.
+ *
+ * Copyright (C) 2012 Miguel Boton <mboton@gmail.com>
+ *
+ *
+ * This algorithm does not do any kind of sorting, as it is aimed for
+ * aleatory access devices, but it does some basic merging. We try to
+ * keep minimum overhead to achieve low latency.
+ *
+ * Asynchronous and synchronous requests are not treated separately, but
+ * we relay on deadlines to ensure fairness.
+ *
+ */
+#include <linux/blkdev.h>
+#include <linux/elevator.h>
+#include <linux/bio.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/version.h>
+
+enum { ASYNC, SYNC };
+
+/* Tunables */
+static const int sync_read_expire  = HZ / 2;	/* max time before a sync read is submitted. */
+static const int sync_write_expire = 2 * HZ;	/* max time before a sync write is submitted. */
+
+static const int async_read_expire  =  4 * HZ;	/* ditto for async, these limits are SOFT! */
+static const int async_write_expire = 16 * HZ;	/* ditto for async, these limits are SOFT! */
+
+static const int writes_starved = 1;		/* max times reads can starve a write */
+static const int fifo_batch     = 1;		/* # of sequential requests treated as one
+						   by the above parameters. For throughput. */
+
+/* Elevator data */
+struct sio_data {
+	/* Request queues */
+	struct list_head fifo_list[2][2];
+
+	/* Attributes */
+	unsigned int batched;
+	unsigned int starved;
+
+	/* Settings */
+	int fifo_expire[2][2];
+	int fifo_batch;
+	int writes_starved;
+};
+
+static void
+sio_merged_requests(struct request_queue *q, struct request *rq,
+		    struct request *next)
+{
+	/*
+	 * If next expires before rq, assign its expire time to rq
+	 * and move into next position (next will be deleted) in fifo.
+	 */
+	if (!list_empty(&rq->queuelist) && !list_empty(&next->queuelist)) {
+		if (time_before(rq_fifo_time(next), rq_fifo_time(rq))) {
+			list_move(&rq->queuelist, &next->queuelist);
+			rq_set_fifo_time(rq, rq_fifo_time(next));
+		}
+	}
+
+	/* Delete next request */
+	rq_fifo_clear(next);
+}
+
+static void
+sio_add_request(struct request_queue *q, struct request *rq)
+{
+	struct sio_data *sd = q->elevator->elevator_data;
+	const int sync = rq_is_sync(rq);
+	const int data_dir = rq_data_dir(rq);
+
+	/*
+	 * Add request to the proper fifo list and set its
+	 * expire time.
+	 */
+	rq_set_fifo_time(rq, jiffies + sd->fifo_expire[sync][data_dir]);
+	list_add_tail(&rq->queuelist, &sd->fifo_list[sync][data_dir]);
+}
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,38)
+static int
+sio_queue_empty(struct request_queue *q)
+{
+	struct sio_data *sd = q->elevator->elevator_data;
+
+	/* Check if fifo lists are empty */
+	return list_empty(&sd->fifo_list[SYNC][READ]) && list_empty(&sd->fifo_list[SYNC][WRITE]) &&
+	       list_empty(&sd->fifo_list[ASYNC][READ]) && list_empty(&sd->fifo_list[ASYNC][WRITE]);
+}
+#endif
+
+static struct request *
+sio_expired_request(struct sio_data *sd, int sync, int data_dir)
+{
+	struct list_head *list = &sd->fifo_list[sync][data_dir];
+	struct request *rq;
+
+	if (list_empty(list))
+		return NULL;
+
+	/* Retrieve request */
+	rq = rq_entry_fifo(list->next);
+
+	/* Request has expired */
+	if (time_after(jiffies, rq_fifo_time(rq)))
+		return rq;
+
+	return NULL;
+}
+
+static struct request *
+sio_choose_expired_request(struct sio_data *sd)
+{
+	struct request *rq;
+
+	/*
+	 * Check expired requests.
+	 * Asynchronous requests have priority over synchronous.
+	 * Write requests have priority over read.
+	 */
+	rq = sio_expired_request(sd, ASYNC, WRITE);
+	if (rq)
+		return rq;
+	rq = sio_expired_request(sd, ASYNC, READ);
+	if (rq)
+		return rq;
+
+	rq = sio_expired_request(sd, SYNC, WRITE);
+	if (rq)
+		return rq;
+	rq = sio_expired_request(sd, SYNC, READ);
+	if (rq)
+		return rq;
+
+	return NULL;
+}
+
+static struct request *
+sio_choose_request(struct sio_data *sd, int data_dir)
+{
+	struct list_head *sync = sd->fifo_list[SYNC];
+	struct list_head *async = sd->fifo_list[ASYNC];
+
+	/*
+	 * Retrieve request from available fifo list.
+	 * Synchronous requests have priority over asynchronous.
+	 * Read requests have priority over write.
+	 */
+	if (!list_empty(&sync[data_dir]))
+		return rq_entry_fifo(sync[data_dir].next);
+	if (!list_empty(&async[data_dir]))
+		return rq_entry_fifo(async[data_dir].next);
+
+	if (!list_empty(&sync[!data_dir]))
+		return rq_entry_fifo(sync[!data_dir].next);
+	if (!list_empty(&async[!data_dir]))
+		return rq_entry_fifo(async[!data_dir].next);
+
+	return NULL;
+}
+
+static inline void
+sio_dispatch_request(struct sio_data *sd, struct request *rq)
+{
+	/*
+	 * Remove the request from the fifo list
+	 * and dispatch it.
+	 */
+	rq_fifo_clear(rq);
+	elv_dispatch_add_tail(rq->q, rq);
+
+	sd->batched++;
+
+	if (rq_data_dir(rq))
+		sd->starved = 0;
+	else
+		sd->starved++;
+}
+
+static int
+sio_dispatch_requests(struct request_queue *q, int force)
+{
+	struct sio_data *sd = q->elevator->elevator_data;
+	struct request *rq = NULL;
+	int data_dir = READ;
+
+	/*
+	 * Retrieve any expired request after a batch of
+	 * sequential requests.
+	 */
+	if (sd->batched > sd->fifo_batch) {
+		sd->batched = 0;
+		rq = sio_choose_expired_request(sd);
+	}
+
+	/* Retrieve request */
+	if (!rq) {
+		if (sd->starved > sd->writes_starved)
+			data_dir = WRITE;
+
+		rq = sio_choose_request(sd, data_dir);
+		if (!rq)
+			return 0;
+	}
+
+	/* Dispatch request */
+	sio_dispatch_request(sd, rq);
+
+	return 1;
+}
+
+static struct request *
+sio_former_request(struct request_queue *q, struct request *rq)
+{
+	struct sio_data *sd = q->elevator->elevator_data;
+	const int sync = rq_is_sync(rq);
+	const int data_dir = rq_data_dir(rq);
+
+	if (rq->queuelist.prev == &sd->fifo_list[sync][data_dir])
+		return NULL;
+
+	/* Return former request */
+	return list_entry(rq->queuelist.prev, struct request, queuelist);
+}
+
+static struct request *
+sio_latter_request(struct request_queue *q, struct request *rq)
+{
+	struct sio_data *sd = q->elevator->elevator_data;
+	const int sync = rq_is_sync(rq);
+	const int data_dir = rq_data_dir(rq);
+
+	if (rq->queuelist.next == &sd->fifo_list[sync][data_dir])
+		return NULL;
+
+	/* Return latter request */
+	return list_entry(rq->queuelist.next, struct request, queuelist);
+}
+
+static void *
+sio_init_queue(struct request_queue *q)
+{
+	struct sio_data *sd;
+
+	/* Allocate structure */
+	sd = kmalloc_node(sizeof(*sd), GFP_KERNEL, q->node);
+	if (!sd)
+		return NULL;
+
+	/* Initialize fifo lists */
+	INIT_LIST_HEAD(&sd->fifo_list[SYNC][READ]);
+	INIT_LIST_HEAD(&sd->fifo_list[SYNC][WRITE]);
+	INIT_LIST_HEAD(&sd->fifo_list[ASYNC][READ]);
+	INIT_LIST_HEAD(&sd->fifo_list[ASYNC][WRITE]);
+
+	/* Initialize data */
+	sd->batched = 0;
+	sd->fifo_expire[SYNC][READ] = sync_read_expire;
+	sd->fifo_expire[SYNC][WRITE] = sync_write_expire;
+	sd->fifo_expire[ASYNC][READ] = async_read_expire;
+	sd->fifo_expire[ASYNC][WRITE] = async_write_expire;
+	sd->fifo_batch = fifo_batch;
+
+	return sd;
+}
+
+static void
+sio_exit_queue(struct elevator_queue *e)
+{
+	struct sio_data *sd = e->elevator_data;
+
+	BUG_ON(!list_empty(&sd->fifo_list[SYNC][READ]));
+	BUG_ON(!list_empty(&sd->fifo_list[SYNC][WRITE]));
+	BUG_ON(!list_empty(&sd->fifo_list[ASYNC][READ]));
+	BUG_ON(!list_empty(&sd->fifo_list[ASYNC][WRITE]));
+
+	/* Free structure */
+	kfree(sd);
+}
+
+/*
+ * sysfs code
+ */
+
+static ssize_t
+sio_var_show(int var, char *page)
+{
+	return sprintf(page, "%d\n", var);
+}
+
+static ssize_t
+sio_var_store(int *var, const char *page, size_t count)
+{
+	char *p = (char *) page;
+
+	*var = simple_strtol(p, &p, 10);
+	return count;
+}
+
+#define SHOW_FUNCTION(__FUNC, __VAR, __CONV)				\
+static ssize_t __FUNC(struct elevator_queue *e, char *page)		\
+{									\
+	struct sio_data *sd = e->elevator_data;			\
+	int __data = __VAR;						\
+	if (__CONV)							\
+		__data = jiffies_to_msecs(__data);			\
+	return sio_var_show(__data, (page));			\
+}
+SHOW_FUNCTION(sio_sync_read_expire_show, sd->fifo_expire[SYNC][READ], 1);
+SHOW_FUNCTION(sio_sync_write_expire_show, sd->fifo_expire[SYNC][WRITE], 1);
+SHOW_FUNCTION(sio_async_read_expire_show, sd->fifo_expire[ASYNC][READ], 1);
+SHOW_FUNCTION(sio_async_write_expire_show, sd->fifo_expire[ASYNC][WRITE], 1);
+SHOW_FUNCTION(sio_fifo_batch_show, sd->fifo_batch, 0);
+SHOW_FUNCTION(sio_writes_starved_show, sd->writes_starved, 0);
+#undef SHOW_FUNCTION
+
+#define STORE_FUNCTION(__FUNC, __PTR, MIN, MAX, __CONV)			\
+static ssize_t __FUNC(struct elevator_queue *e, const char *page, size_t count)	\
+{									\
+	struct sio_data *sd = e->elevator_data;			\
+	int __data;							\
+	int ret = sio_var_store(&__data, (page), count);		\
+	if (__data < (MIN))						\
+		__data = (MIN);						\
+	else if (__data > (MAX))					\
+		__data = (MAX);						\
+	if (__CONV)							\
+		*(__PTR) = msecs_to_jiffies(__data);			\
+	else								\
+		*(__PTR) = __data;					\
+	return ret;							\
+}
+STORE_FUNCTION(sio_sync_read_expire_store, &sd->fifo_expire[SYNC][READ], 0, INT_MAX, 1);
+STORE_FUNCTION(sio_sync_write_expire_store, &sd->fifo_expire[SYNC][WRITE], 0, INT_MAX, 1);
+STORE_FUNCTION(sio_async_read_expire_store, &sd->fifo_expire[ASYNC][READ], 0, INT_MAX, 1);
+STORE_FUNCTION(sio_async_write_expire_store, &sd->fifo_expire[ASYNC][WRITE], 0, INT_MAX, 1);
+STORE_FUNCTION(sio_fifo_batch_store, &sd->fifo_batch, 0, INT_MAX, 0);
+STORE_FUNCTION(sio_writes_starved_store, &sd->writes_starved, 0, INT_MAX, 0);
+#undef STORE_FUNCTION
+
+#define DD_ATTR(name) \
+	__ATTR(name, S_IRUGO|S_IWUSR, sio_##name##_show, \
+				      sio_##name##_store)
+
+static struct elv_fs_entry sio_attrs[] = {
+	DD_ATTR(sync_read_expire),
+	DD_ATTR(sync_write_expire),
+	DD_ATTR(async_read_expire),
+	DD_ATTR(async_write_expire),
+	DD_ATTR(fifo_batch),
+	DD_ATTR(writes_starved),
+	__ATTR_NULL
+};
+
+static struct elevator_type iosched_sio = {
+	.ops = {
+		.elevator_merge_req_fn		= sio_merged_requests,
+		.elevator_dispatch_fn		= sio_dispatch_requests,
+		.elevator_add_req_fn		= sio_add_request,
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,38)
+		.elevator_queue_empty_fn	= sio_queue_empty,
+#endif
+		.elevator_former_req_fn		= sio_former_request,
+		.elevator_latter_req_fn		= sio_latter_request,
+		.elevator_init_fn		= sio_init_queue,
+		.elevator_exit_fn		= sio_exit_queue,
+	},
+
+	.elevator_attrs = sio_attrs,
+	.elevator_name = "sio",
+	.elevator_owner = THIS_MODULE,
+};
+
+static int __init sio_init(void)
+{
+	/* Register elevator */
+	elv_register(&iosched_sio);
+
+	return 0;
+}
+
+static void __exit sio_exit(void)
+{
+	/* Unregister elevator */
+	elv_unregister(&iosched_sio);
+}
+
+module_init(sio_init);
+module_exit(sio_exit);
+
+MODULE_AUTHOR("Miguel Boton");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Simple IO scheduler");
+MODULE_VERSION("0.2");
diff -urNp Kernel/block/vr-iosched.c HelloWorld-Renew-v1.0-n7000-jb/block/vr-iosched.c
--- Kernel/block/vr-iosched.c	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/block/vr-iosched.c	2013-04-25 17:38:09.000000000 +0200
@@ -0,0 +1,453 @@
+/*
+* V(R) I/O Scheduler
+*
+* Copyright (C) 2007 Aaron Carroll <aaronc@gelato.unsw.edu.au>
+*
+*
+* The algorithm:
+*
+* The next request is decided based on its distance from the last
+* request, with a multiplicative penalty of `rev_penalty' applied
+* for reversing the head direction. A rev_penalty of 1 means SSTF
+* behaviour. As this variable is increased, the algorithm approaches
+* pure SCAN. Setting rev_penalty to 0 forces SCAN.
+*
+* Async and synch requests are not treated seperately. Instead we
+* rely on deadlines to ensure fairness.
+*
+*/
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/blkdev.h>
+#include <linux/elevator.h>
+#include <linux/bio.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/compiler.h>
+#include <linux/rbtree.h>
+#include <linux/version.h>
+
+#include <asm/div64.h>
+
+enum vr_data_dir {
+ASYNC,
+SYNC,
+};
+
+enum vr_head_dir {
+FORWARD,
+BACKWARD,
+};
+
+static const int sync_expire = HZ / 2; /* max time before a sync is submitted. */
+static const int async_expire = 5 * HZ; /* ditto for async, these limits are SOFT! */
+static const int fifo_batch = 1;
+static const int rev_penalty = 1; /* penalty for reversing head direction */
+
+struct vr_data {
+struct rb_root sort_list;
+struct list_head fifo_list[2];
+
+struct request *next_rq;
+struct request *prev_rq;
+
+unsigned int nbatched;
+sector_t last_sector; /* head position */
+int head_dir;
+
+/* tunables */
+int fifo_expire[2];
+int fifo_batch;
+int rev_penalty;
+};
+
+static void vr_move_request(struct vr_data *, struct request *);
+
+static inline struct vr_data *
+vr_get_data(struct request_queue *q)
+{
+return q->elevator->elevator_data;
+}
+
+static void
+vr_add_rq_rb(struct vr_data *vd, struct request *rq)
+{
+struct request *alias = elv_rb_add(&vd->sort_list, rq);
+
+if (unlikely(alias)) {
+vr_move_request(vd, alias);
+alias = elv_rb_add(&vd->sort_list, rq);
+BUG_ON(alias);
+}
+
+if (blk_rq_pos(rq) >= vd->last_sector) {
+if (!vd->next_rq || blk_rq_pos(vd->next_rq) > blk_rq_pos(rq))
+vd->next_rq = rq;
+}
+else {
+if (!vd->prev_rq || blk_rq_pos(vd->prev_rq) < blk_rq_pos(rq))
+vd->prev_rq = rq;
+}
+
+BUG_ON(vd->next_rq && vd->next_rq == vd->prev_rq);
+BUG_ON(vd->next_rq && vd->prev_rq && blk_rq_pos(vd->next_rq) < blk_rq_pos(vd->prev_rq));
+}
+
+static void
+vr_del_rq_rb(struct vr_data *vd, struct request *rq)
+{
+/*
+* We might be deleting our cached next request.
+* If so, find its sucessor.
+*/
+
+if (vd->next_rq == rq)
+vd->next_rq = elv_rb_latter_request(NULL, rq);
+else if (vd->prev_rq == rq)
+vd->prev_rq = elv_rb_former_request(NULL, rq);
+
+BUG_ON(vd->next_rq && vd->next_rq == vd->prev_rq);
+BUG_ON(vd->next_rq && vd->prev_rq && blk_rq_pos(vd->next_rq) < blk_rq_pos(vd->prev_rq));
+
+elv_rb_del(&vd->sort_list, rq);
+}
+
+/*
+* add rq to rbtree and fifo
+*/
+static void
+vr_add_request(struct request_queue *q, struct request *rq)
+{
+struct vr_data *vd = vr_get_data(q);
+const int dir = rq_is_sync(rq);
+
+vr_add_rq_rb(vd, rq);
+
+if (vd->fifo_expire[dir]) {
+rq_set_fifo_time(rq, jiffies + vd->fifo_expire[dir]);
+list_add_tail(&rq->queuelist, &vd->fifo_list[dir]);
+}
+}
+
+/*
+* remove rq from rbtree and fifo.
+*/
+static void
+vr_remove_request(struct request_queue *q, struct request *rq)
+{
+struct vr_data *vd = vr_get_data(q);
+
+rq_fifo_clear(rq);
+vr_del_rq_rb(vd, rq);
+}
+
+static int
+vr_merge(struct request_queue *q, struct request **rqp, struct bio *bio)
+{
+sector_t sector = bio->bi_sector + bio_sectors(bio);
+struct vr_data *vd = vr_get_data(q);
+struct request *rq = elv_rb_find(&vd->sort_list, sector);
+
+if (rq && elv_rq_merge_ok(rq, bio)) {
+*rqp = rq;
+return ELEVATOR_FRONT_MERGE;
+}
+return ELEVATOR_NO_MERGE;
+}
+
+static void
+vr_merged_request(struct request_queue *q, struct request *req, int type)
+{
+struct vr_data *vd = vr_get_data(q);
+
+/*
+* if the merge was a front merge, we need to reposition request
+*/
+if (type == ELEVATOR_FRONT_MERGE) {
+vr_del_rq_rb(vd, req);
+vr_add_rq_rb(vd, req);
+}
+}
+
+static void
+vr_merged_requests(struct request_queue *q, struct request *rq,
+struct request *next)
+{
+/*
+* if next expires before rq, assign its expire time to rq
+* and move into next position (next will be deleted) in fifo
+*/
+if (!list_empty(&rq->queuelist) && !list_empty(&next->queuelist)) {
+if (time_before(rq_fifo_time(next), rq_fifo_time(rq))) {
+list_move(&rq->queuelist, &next->queuelist);
+rq_set_fifo_time(rq, rq_fifo_time(next));
+}
+}
+
+vr_remove_request(q, next);
+}
+
+/*
+* move an entry to dispatch queue
+*/
+static void
+vr_move_request(struct vr_data *vd, struct request *rq)
+{
+struct request_queue *q = rq->q;
+
+if (blk_rq_pos(rq) > vd->last_sector)
+vd->head_dir = FORWARD;
+else
+vd->head_dir = BACKWARD;
+
+vd->last_sector = blk_rq_pos(rq);
+vd->next_rq = elv_rb_latter_request(NULL, rq);
+vd->prev_rq = elv_rb_former_request(NULL, rq);
+
+BUG_ON(vd->next_rq && vd->next_rq == vd->prev_rq);
+
+vr_remove_request(q, rq);
+elv_dispatch_add_tail(q, rq);
+vd->nbatched++;
+}
+
+/*
+* get the first expired request in direction ddir
+*/
+static struct request *
+vr_expired_request(struct vr_data *vd, int ddir)
+{
+struct request *rq;
+
+if (list_empty(&vd->fifo_list[ddir]))
+return NULL;
+
+rq = rq_entry_fifo(vd->fifo_list[ddir].next);
+if (time_after(jiffies, rq_fifo_time(rq)))
+return rq;
+
+return NULL;
+}
+
+/*
+* Returns the oldest expired request
+*/
+static struct request *
+vr_check_fifo(struct vr_data *vd)
+{
+struct request *rq_sync = vr_expired_request(vd, SYNC);
+struct request *rq_async = vr_expired_request(vd, ASYNC);
+
+if (rq_async && rq_sync) {
+if (time_after(rq_fifo_time(rq_async), rq_fifo_time(rq_sync)))
+return rq_sync;
+}
+else if (rq_sync)
+return rq_sync;
+
+return rq_async;
+}
+
+/*
+* Return the request with the lowest penalty
+*/
+static struct request *
+vr_choose_request(struct vr_data *vd)
+{
+int penalty = (vd->rev_penalty) ? : INT_MAX;
+struct request *next = vd->next_rq;
+struct request *prev = vd->prev_rq;
+sector_t next_pen, prev_pen;
+
+BUG_ON(prev && prev == next);
+
+if (!prev)
+return next;
+else if (!next)
+return prev;
+
+/* At this point both prev and next are defined and distinct */
+
+next_pen = blk_rq_pos(next) - vd->last_sector;
+prev_pen = vd->last_sector - blk_rq_pos(prev);
+
+if (vd->head_dir == FORWARD)
+next_pen = do_div(next_pen, penalty);
+else
+prev_pen = do_div(prev_pen, penalty);
+
+if (next_pen <= prev_pen)
+return next;
+
+return prev;
+}
+
+static int
+vr_dispatch_requests(struct request_queue *q, int force)
+{
+struct vr_data *vd = vr_get_data(q);
+struct request *rq = NULL;
+
+/* Check for and issue expired requests */
+if (vd->nbatched > vd->fifo_batch) {
+vd->nbatched = 0;
+rq = vr_check_fifo(vd);
+}
+
+if (!rq) {
+rq = vr_choose_request(vd);
+if (!rq)
+return 0;
+}
+
+vr_move_request(vd, rq);
+
+return 1;
+}
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,38)
+static int
+vr_queue_empty(struct request_queue *q)
+{
+struct vr_data *vd = vr_get_data(q);
+return RB_EMPTY_ROOT(&vd->sort_list);
+}
+#endif
+
+static void
+vr_exit_queue(struct elevator_queue *e)
+{
+struct vr_data *vd = e->elevator_data;
+BUG_ON(!RB_EMPTY_ROOT(&vd->sort_list));
+kfree(vd);
+}
+
+/*
+* initialize elevator private data (vr_data).
+*/
+static void *vr_init_queue(struct request_queue *q)
+{
+struct vr_data *vd;
+
+vd = kmalloc_node(sizeof(*vd), GFP_KERNEL | __GFP_ZERO, q->node);
+if (!vd)
+return NULL;
+
+INIT_LIST_HEAD(&vd->fifo_list[SYNC]);
+INIT_LIST_HEAD(&vd->fifo_list[ASYNC]);
+vd->sort_list = RB_ROOT;
+vd->fifo_expire[SYNC] = sync_expire;
+vd->fifo_expire[ASYNC] = async_expire;
+vd->fifo_batch = fifo_batch;
+vd->rev_penalty = rev_penalty;
+return vd;
+}
+
+/*
+* sysfs parts below
+*/
+
+static ssize_t
+vr_var_show(int var, char *page)
+{
+return sprintf(page, "%d\n", var);
+}
+
+static ssize_t
+vr_var_store(int *var, const char *page, size_t count)
+{
+*var = simple_strtol(page, NULL, 10);
+return count;
+}
+
+#define SHOW_FUNCTION(__FUNC, __VAR, __CONV) \
+static ssize_t __FUNC(struct elevator_queue *e, char *page) \
+{ \
+struct vr_data *vd = e->elevator_data; \
+int __data = __VAR; \
+if (__CONV) \
+__data = jiffies_to_msecs(__data); \
+return vr_var_show(__data, (page)); \
+}
+SHOW_FUNCTION(vr_sync_expire_show, vd->fifo_expire[SYNC], 1);
+SHOW_FUNCTION(vr_async_expire_show, vd->fifo_expire[ASYNC], 1);
+SHOW_FUNCTION(vr_fifo_batch_show, vd->fifo_batch, 0);
+SHOW_FUNCTION(vr_rev_penalty_show, vd->rev_penalty, 0);
+#undef SHOW_FUNCTION
+
+#define STORE_FUNCTION(__FUNC, __PTR, MIN, MAX, __CONV) \
+static ssize_t __FUNC(struct elevator_queue *e, const char *page, size_t count) \
+{ \
+struct vr_data *vd = e->elevator_data; \
+int __data; \
+int ret = vr_var_store(&__data, (page), count); \
+if (__data < (MIN)) \
+__data = (MIN); \
+else if (__data > (MAX)) \
+__data = (MAX); \
+if (__CONV) \
+*(__PTR) = msecs_to_jiffies(__data); \
+else \
+*(__PTR) = __data; \
+return ret; \
+}
+STORE_FUNCTION(vr_sync_expire_store, &vd->fifo_expire[SYNC], 0, INT_MAX, 1);
+STORE_FUNCTION(vr_async_expire_store, &vd->fifo_expire[ASYNC], 0, INT_MAX, 1);
+STORE_FUNCTION(vr_fifo_batch_store, &vd->fifo_batch, 0, INT_MAX, 0);
+STORE_FUNCTION(vr_rev_penalty_store, &vd->rev_penalty, 0, INT_MAX, 0);
+#undef STORE_FUNCTION
+
+#define DD_ATTR(name) \
+__ATTR(name, S_IRUGO|S_IWUSR, vr_##name##_show, \
+vr_##name##_store)
+
+static struct elv_fs_entry vr_attrs[] = {
+DD_ATTR(sync_expire),
+DD_ATTR(async_expire),
+DD_ATTR(fifo_batch),
+DD_ATTR(rev_penalty),
+__ATTR_NULL
+};
+
+static struct elevator_type iosched_vr = {
+.ops = {
+.elevator_merge_fn = vr_merge,
+.elevator_merged_fn = vr_merged_request,
+.elevator_merge_req_fn = vr_merged_requests,
+.elevator_dispatch_fn = vr_dispatch_requests,
+.elevator_add_req_fn = vr_add_request,
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,38)
+.elevator_queue_empty_fn = vr_queue_empty,
+#endif
+.elevator_former_req_fn = elv_rb_former_request,
+.elevator_latter_req_fn = elv_rb_latter_request,
+.elevator_init_fn = vr_init_queue,
+.elevator_exit_fn = vr_exit_queue,
+},
+
+.elevator_attrs = vr_attrs,
+.elevator_name = "vr",
+.elevator_owner = THIS_MODULE,
+};
+
+static int __init vr_init(void)
+{
+elv_register(&iosched_vr);
+
+return 0;
+}
+
+static void __exit vr_exit(void)
+{
+elv_unregister(&iosched_vr);
+}
+
+module_init(vr_init);
+module_exit(vr_exit);
+
+MODULE_AUTHOR("Aaron Carroll");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("V(R) IO scheduler");
+
+
diff -urNp Kernel/drivers/cpufreq/cpufreq.c HelloWorld-Renew-v1.0-n7000-jb/drivers/cpufreq/cpufreq.c
--- Kernel/drivers/cpufreq/cpufreq.c	2013-02-20 13:36:19.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/drivers/cpufreq/cpufreq.c	2013-05-01 12:57:16.857114354 +0200
@@ -276,7 +276,22 @@ void cpufreq_notify_transition(struct cp
 }
 EXPORT_SYMBOL_GPL(cpufreq_notify_transition);
 
-
+/**
+* cpufreq_notify_utilization - notify CPU userspace about CPU utilization
+* change
+*
+* This function is called everytime the CPU load is evaluated by the
+* ondemand governor. It notifies userspace of cpu load changes via sysfs.
+*/
+void cpufreq_notify_utilization(struct cpufreq_policy *policy,
+    unsigned int util)
+{
+  if (policy)
+    policy->util = util;
+ 
+  if (policy->util >= MIN_CPU_UTIL_NOTIFY)
+    sysfs_notify(&policy->kobj, NULL, "cpu_utilization");
+}
 
 /*********************************************************************
  *                          SYSFS INTERFACE                          *
@@ -364,6 +379,7 @@ show_one(cpuinfo_transition_latency, cpu
 show_one(scaling_min_freq, min);
 show_one(scaling_max_freq, max);
 show_one(scaling_cur_freq, cur);
+show_one(cpu_utilization, util);
 
 static int __cpufreq_set_policy(struct cpufreq_policy *data,
 				struct cpufreq_policy *policy);
@@ -553,6 +569,11 @@ static ssize_t show_scaling_setspeed(str
 	return policy->governor->show_setspeed(policy, buf);
 }
 
+/* sysfs interface for UV control */
+extern ssize_t show_UV_mV_table(struct cpufreq_policy *policy, char *buf);
+extern ssize_t store_UV_mV_table(struct cpufreq_policy *policy,
+                                      const char *buf, size_t count);
+
 /**
  * show_scaling_driver - show the current cpufreq HW/BIOS limitation
  */
@@ -578,10 +599,13 @@ cpufreq_freq_attr_ro(scaling_cur_freq);
 cpufreq_freq_attr_ro(bios_limit);
 cpufreq_freq_attr_ro(related_cpus);
 cpufreq_freq_attr_ro(affected_cpus);
+cpufreq_freq_attr_ro(cpu_utilization);
 cpufreq_freq_attr_rw(scaling_min_freq);
 cpufreq_freq_attr_rw(scaling_max_freq);
 cpufreq_freq_attr_rw(scaling_governor);
 cpufreq_freq_attr_rw(scaling_setspeed);
+/* UV table */
+cpufreq_freq_attr_rw(UV_mV_table);
 
 static struct attribute *default_attrs[] = {
 	&cpuinfo_min_freq.attr,
@@ -590,11 +614,13 @@ static struct attribute *default_attrs[]
 	&scaling_min_freq.attr,
 	&scaling_max_freq.attr,
 	&affected_cpus.attr,
+	&cpu_utilization.attr,
 	&related_cpus.attr,
 	&scaling_governor.attr,
 	&scaling_driver.attr,
 	&scaling_available_governors.attr,
 	&scaling_setspeed.attr,
+	&UV_mV_table.attr,
 	NULL
 };
 
diff -urNp Kernel/drivers/cpufreq/cpufreq_HYPER.c HelloWorld-Renew-v1.0-n7000-jb/drivers/cpufreq/cpufreq_HYPER.c
--- Kernel/drivers/cpufreq/cpufreq_HYPER.c	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/drivers/cpufreq/cpufreq_HYPER.c	2013-04-26 22:14:09.000000000 +0200
@@ -0,0 +1,1178 @@
+/*
+* drivers/cpufreq/cpufreq_HYPER.c
+*
+* Copyright (C) 2001 Russell King
+* (C) 2003 Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>.
+* Jun Nakajima <jun.nakajima@intel.com>
+*
+* 2012 Minor Edits by Sar Castillo <sar.castillo@gmail.com>
+* 2012 MAR heavy addons by DORIMANX <yuri@bynet.co.il>
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/cpufreq.h>
+#include <linux/cpu.h>
+#include <linux/jiffies.h>
+#include <linux/kernel_stat.h>
+#include <linux/mutex.h>
+#include <linux/hrtimer.h>
+#include <linux/tick.h>
+#include <linux/ktime.h>
+#include <linux/sched.h>
+#include <linux/pm_qos.h>
+#include <linux/input.h>
+#include <linux/slab.h>
+
+/*
+* dbs is used in this file as a shortform for demandbased switching
+* It helps to keep variable names smaller, simpler
+*/
+
+#define DEF_FREQUENCY_DOWN_DIFFERENTIAL (20)
+#define MIN_FREQUENCY_DOWN_DIFFERENTIAL (1)
+#define DEF_FREQUENCY_UP_THRESHOLD (70)
+#define DEF_SAMPLING_DOWN_FACTOR (1)
+#define BOOSTED_SAMPLING_DOWN_FACTOR (10)
+#define MAX_SAMPLING_DOWN_FACTOR (100000)
+#define MICRO_FREQUENCY_DOWN_DIFFERENTIAL (5)
+#define MICRO_FREQUENCY_UP_THRESHOLD (70)
+#define MICRO_FREQUENCY_MIN_SAMPLE_RATE (10000)
+#define MIN_FREQUENCY_UP_THRESHOLD (11)
+#define MAX_FREQUENCY_UP_THRESHOLD (100)
+#define MIN_FREQUENCY_DOWN_DIFFERENTIAL (1)
+#define FREQ_STEP (30)
+#define DEFAULT_FREQ_BOOST_TIME (500000)
+#define UP_THRESHOLD_AT_MIN_FREQ (60)
+#define FREQ_FOR_RESPONSIVENESS (400000)
+
+u64 hyper_freq_boosted_time;
+
+/*
+* The polling frequency of this governor depends on the capability of
+* the processor. Default polling frequency is 1000 times the transition
+* latency of the processor. The governor will work on any processor with
+* transition latency <= 10mS, using appropriate sampling
+* rate.
+* For CPUs with transition latency > 10mS (mostly drivers with CPUFREQ_ETERNAL)
+* this governor will not work.
+* All times here are in uS.
+*/
+#define MIN_SAMPLING_RATE_RATIO (2)
+
+static unsigned int min_sampling_rate;
+#define DEFAULT_SAMPLING_RATE (50000)
+#define BOOSTED_SAMPLING_RATE (20000)
+#define LATENCY_MULTIPLIER (1000)
+#define MIN_LATENCY_MULTIPLIER (100)
+#define TRANSITION_LATENCY_LIMIT (10 * 1000 * 1000)
+
+/* have the timer rate booted for this much time 4s*/
+#define TIMER_RATE_BOOST_TIME 4000000
+int hyper_sampling_rate_boosted;
+u64 hyper_sampling_rate_boosted_time;
+unsigned int hyper_current_sampling_rate;
+
+static void do_dbs_timer(struct work_struct *work);
+static int cpufreq_governor_dbs(struct cpufreq_policy *policy,
+unsigned int event);
+
+#ifndef CONFIG_CPU_FREQ_DEFAULT_GOV_HYPER
+static
+#endif
+struct cpufreq_governor cpufreq_gov_HYPER = {
+       .name = "HYPER",
+       .governor = cpufreq_governor_dbs,
+       .max_transition_latency = TRANSITION_LATENCY_LIMIT,
+       .owner = THIS_MODULE,
+};
+
+/* Sampling types */
+enum {DBS_NORMAL_SAMPLE, DBS_SUB_SAMPLE};
+
+struct cpu_dbs_info_s {
+cputime64_t prev_cpu_idle;
+cputime64_t prev_cpu_iowait;
+cputime64_t prev_cpu_wall;
+unsigned int prev_cpu_wall_delta;
+cputime64_t prev_cpu_nice;
+struct cpufreq_policy *cur_policy;
+struct delayed_work work;
+struct cpufreq_frequency_table *freq_table;
+unsigned int freq_lo;
+unsigned int freq_lo_jiffies;
+unsigned int freq_hi_jiffies;
+unsigned int rate_mult;
+unsigned int load_at_prev_sample;
+int cpu;
+unsigned int sample_type:1;
+/*
+* percpu mutex that serializes governor limit change with
+* do_dbs_timer invocation. We do not want do_dbs_timer to run
+* when user is changing the governor or limits.
+*/
+struct mutex timer_mutex;
+bool activated; /* dbs_timer_init is in effect */
+};
+static DEFINE_PER_CPU(struct cpu_dbs_info_s, od_cpu_dbs_info);
+
+static unsigned int dbs_enable;	/* number of CPUs using this policy */
+
+/*
+* dbs_mutex protects dbs_enable in governor start/stop.
+*/
+static DEFINE_MUTEX(dbs_mutex);
+
+static struct dbs_tuners {
+unsigned int sampling_rate;
+unsigned int up_threshold;
+unsigned int up_threshold_min_freq;
+unsigned int down_differential;
+unsigned int ignore_nice;
+unsigned int sampling_down_factor;
+unsigned int powersave_bias;
+unsigned int io_is_busy;
+unsigned int boosted;
+unsigned int freq_boost_time;
+unsigned int boostfreq;
+struct notifier_block dvfs_lat_qos_db;
+unsigned int dvfs_lat_qos_wants;
+unsigned int freq_step;
+unsigned int freq_responsiveness;
+
+} dbs_tuners_ins = {
+.up_threshold = DEF_FREQUENCY_UP_THRESHOLD,
+.up_threshold_min_freq = UP_THRESHOLD_AT_MIN_FREQ,
+.sampling_down_factor = DEF_SAMPLING_DOWN_FACTOR,
+.down_differential = DEF_FREQUENCY_DOWN_DIFFERENTIAL,
+.ignore_nice = 0,
+.powersave_bias = 0,
+.freq_boost_time = DEFAULT_FREQ_BOOST_TIME,
+.boostfreq = 1400000,
+.freq_step = FREQ_STEP,
+.freq_responsiveness = FREQ_FOR_RESPONSIVENESS
+};
+
+static unsigned int dbs_enable = 0;	/* number of CPUs using this policy */
+
+static inline cputime64_t get_cpu_idle_time_jiffy(unsigned int cpu,
+cputime64_t *wall)
+{
+cputime64_t idle_time;
+cputime64_t cur_wall_time;
+cputime64_t busy_time;
+
+cur_wall_time = jiffies64_to_cputime64(get_jiffies_64());
+busy_time = cputime64_add(kstat_cpu(cpu).cpustat.user,
+kstat_cpu(cpu).cpustat.system);
+
+busy_time = cputime64_add(busy_time, kstat_cpu(cpu).cpustat.irq);
+busy_time = cputime64_add(busy_time, kstat_cpu(cpu).cpustat.softirq);
+busy_time = cputime64_add(busy_time, kstat_cpu(cpu).cpustat.steal);
+busy_time = cputime64_add(busy_time, kstat_cpu(cpu).cpustat.nice);
+busy_time = cputime64_add(busy_time, kstat_cpu(cpu).cpustat.user);
+busy_time = cputime64_add(busy_time, kstat_cpu(cpu).cpustat.system);
+
+idle_time = cputime64_sub(cur_wall_time, busy_time);
+if (wall)
+*wall = (cputime64_t)jiffies_to_usecs(cur_wall_time);
+
+return (cputime64_t)jiffies_to_usecs(idle_time);
+}
+
+static inline cputime64_t get_cpu_idle_time(unsigned int cpu, cputime64_t *wall)
+{
+u64 idle_time = get_cpu_idle_time_us(cpu, NULL);
+
+if (idle_time == -1ULL)
+return get_cpu_idle_time_jiffy(cpu, wall);
+else
+idle_time += get_cpu_iowait_time_us(cpu, wall);
+
+return idle_time;
+}
+
+static inline cputime64_t get_cpu_iowait_time(unsigned int cpu, cputime64_t *wall)
+{
+u64 iowait_time = get_cpu_iowait_time_us(cpu, wall);
+
+if (iowait_time == -1ULL)
+return 0;
+
+return iowait_time;
+}
+
+/*
+* Find right sampling rate based on sampling_rate and
+* QoS requests on dvfs latency.
+*/
+static unsigned int effective_sampling_rate(void)
+{
+unsigned int effective;
+
+if (dbs_tuners_ins.dvfs_lat_qos_wants)
+effective = min(dbs_tuners_ins.dvfs_lat_qos_wants,
+dbs_tuners_ins.sampling_rate);
+else
+effective = dbs_tuners_ins.sampling_rate;
+
+return max(effective, min_sampling_rate);
+}
+
+/*
+* Find right freq to be set now with powersave_bias on.
+* Returns the freq_hi to be used right now and will set freq_hi_jiffies,
+* freq_lo, and freq_lo_jiffies in percpu area for averaging freqs.
+*/
+static unsigned int powersave_bias_target(struct cpufreq_policy *policy,
+unsigned int freq_next,
+unsigned int relation)
+{
+unsigned int freq_req, freq_reduc, freq_avg;
+unsigned int freq_hi, freq_lo;
+unsigned int index = 0;
+unsigned int jiffies_total, jiffies_hi, jiffies_lo;
+struct cpu_dbs_info_s *dbs_info = &per_cpu(od_cpu_dbs_info,
+policy->cpu);
+
+if (!dbs_info->freq_table) {
+dbs_info->freq_lo = 0;
+dbs_info->freq_lo_jiffies = 0;
+return freq_next;
+}
+
+cpufreq_frequency_table_target(policy, dbs_info->freq_table, freq_next,
+relation, &index);
+freq_req = dbs_info->freq_table[index].frequency;
+freq_reduc = freq_req * dbs_tuners_ins.powersave_bias / 1000;
+freq_avg = freq_req - freq_reduc;
+
+/* Find freq bounds for freq_avg in freq_table */
+index = 0;
+cpufreq_frequency_table_target(policy, dbs_info->freq_table, freq_avg,
+CPUFREQ_RELATION_H, &index);
+freq_lo = dbs_info->freq_table[index].frequency;
+index = 0;
+cpufreq_frequency_table_target(policy, dbs_info->freq_table, freq_avg,
+CPUFREQ_RELATION_L, &index);
+freq_hi = dbs_info->freq_table[index].frequency;
+
+/* Find out how long we have to be in hi and lo freqs */
+if (freq_hi == freq_lo) {
+dbs_info->freq_lo = 0;
+dbs_info->freq_lo_jiffies = 0;
+return freq_lo;
+}
+jiffies_total = usecs_to_jiffies(effective_sampling_rate());
+jiffies_hi = (freq_avg - freq_lo) * jiffies_total;
+jiffies_hi += ((freq_hi - freq_lo) / 2);
+jiffies_hi /= (freq_hi - freq_lo);
+jiffies_lo = jiffies_total - jiffies_hi;
+dbs_info->freq_lo = freq_lo;
+dbs_info->freq_lo_jiffies = jiffies_lo;
+dbs_info->freq_hi_jiffies = jiffies_hi;
+return freq_hi;
+}
+
+static void hyper_power_powersave_bias_init_cpu(int cpu)
+{
+struct cpu_dbs_info_s *dbs_info = &per_cpu(od_cpu_dbs_info, cpu);
+dbs_info->freq_table = cpufreq_frequency_get_table(cpu);
+dbs_info->freq_lo = 0;
+}
+
+static void HYPER_powersave_bias_init(void)
+{
+int i;
+for_each_online_cpu(i) {
+hyper_power_powersave_bias_init_cpu(i);
+}
+}
+
+/************************** sysfs interface ************************/
+
+static ssize_t show_sampling_rate_min(struct kobject *kobj,
+struct attribute *attr, char *buf)
+{
+return sprintf(buf, "%u\n", min_sampling_rate);
+}
+
+define_one_global_ro(sampling_rate_min);
+
+/* cpufreq_hyper_power Governor Tunables */
+#define show_one(file_name, object) \
+static ssize_t show_##file_name \
+(struct kobject *kobj, struct attribute *attr, char *buf) \
+{ \
+return sprintf(buf, "%u\n", dbs_tuners_ins.object); \
+}
+show_one(sampling_rate, sampling_rate);
+show_one(io_is_busy, io_is_busy);
+show_one(up_threshold, up_threshold);
+show_one(up_threshold_min_freq, up_threshold_min_freq);
+show_one(sampling_down_factor, sampling_down_factor);
+show_one(ignore_nice_load, ignore_nice);
+show_one(powersave_bias, powersave_bias);
+show_one(down_differential, down_differential);
+show_one(boostpulse, boosted);
+show_one(boosttime, freq_boost_time);
+show_one(boostfreq, boostfreq);
+show_one(freq_step, freq_step);
+show_one(freq_responsiveness, freq_responsiveness);
+
+/**
+* update_sampling_rate - update sampling rate effective immediately if needed.
+* @new_rate: new sampling rate. If it is 0, regard sampling rate is not
+* changed and assume that qos request value is changed.
+*
+* If new rate is smaller than the old, simply updaing
+* dbs_tuners_int.sampling_rate might not be appropriate. For example,
+* if the original sampling_rate was 1 second and the requested new sampling
+* rate is 10 ms because the user needs immediate reaction from ondemand
+* governor, but not sure if higher frequency will be required or not,
+* then, the governor may change the sampling rate too late; up to 1 second
+* later. Thus, if we are reducing the sampling rate, we need to make the
+* new value effective immediately.
+*/
+static void update_sampling_rate(unsigned int new_rate)
+{
+int cpu;
+unsigned int effective;
+
+if (new_rate)
+dbs_tuners_ins.sampling_rate = max(new_rate, min_sampling_rate);
+
+effective = effective_sampling_rate();
+
+for_each_online_cpu(cpu) {
+struct cpufreq_policy *policy;
+struct cpu_dbs_info_s *dbs_info;
+unsigned long next_sampling, appointed_at;
+
+/*
+* mutex_destory(&dbs_info->timer_mutex) should not happen
+* in this context. dbs_mutex is locked/unlocked at GOV_START
+* and GOV_STOP context only other than here.
+*/
+mutex_lock(&dbs_mutex);
+
+policy = cpufreq_cpu_get(cpu);
+if (!policy) {
+mutex_unlock(&dbs_mutex);
+continue;
+}
+dbs_info = &per_cpu(od_cpu_dbs_info, policy->cpu);
+cpufreq_cpu_put(policy);
+
+/* timer_mutex is destroyed or will be destroyed soon */
+if (!dbs_info->activated) {
+mutex_unlock(&dbs_mutex);
+continue;
+}
+
+mutex_lock(&dbs_info->timer_mutex);
+
+if (!delayed_work_pending(&dbs_info->work)) {
+mutex_unlock(&dbs_info->timer_mutex);
+mutex_unlock(&dbs_mutex);
+continue;
+}
+
+next_sampling = jiffies + usecs_to_jiffies(new_rate);
+appointed_at = dbs_info->work.timer.expires;
+
+if (time_before(next_sampling, appointed_at)) {
+mutex_unlock(&dbs_info->timer_mutex);
+cancel_delayed_work_sync(&dbs_info->work);
+mutex_lock(&dbs_info->timer_mutex);
+
+schedule_delayed_work_on(dbs_info->cpu, &dbs_info->work,
+usecs_to_jiffies(effective));
+}
+mutex_unlock(&dbs_info->timer_mutex);
+
+/*
+* For the little possiblity that dbs_timer_exit() has been
+* called after checking dbs_info->activated above.
+* If cancel_delayed_work_syn() has been calld by
+* dbs_timer_exit() before schedule_delayed_work_on() of this
+* function, it should be revoked by calling cancel again
+* before releasing dbs_mutex, which will trigger mutex_destroy
+* to be called.
+*/
+if (!dbs_info->activated)
+cancel_delayed_work_sync(&dbs_info->work);
+
+mutex_unlock(&dbs_mutex);
+}
+}
+
+static ssize_t store_boosttime(struct kobject *kobj, struct attribute *attr,
+const char *buf, size_t count)
+{
+unsigned int input;
+int ret;
+
+ret = sscanf(buf, "%u", &input);
+if (ret != 1)
+return -EINVAL;
+
+dbs_tuners_ins.freq_boost_time = input;
+return count;
+}
+
+
+static ssize_t store_boostpulse(struct kobject *kobj, struct attribute *attr,
+const char *buf, size_t count)
+{
+int ret;
+unsigned long val;
+
+ret = kstrtoul(buf, 0, &val);
+if (ret < 0)
+return ret;
+
+dbs_tuners_ins.boosted = 1;
+hyper_freq_boosted_time = ktime_to_us(ktime_get());
+
+if (hyper_sampling_rate_boosted) {
+hyper_sampling_rate_boosted = 0;
+dbs_tuners_ins.sampling_rate = hyper_current_sampling_rate;
+}
+return count;
+}
+
+static ssize_t store_boostfreq(struct kobject *a, struct attribute *b,
+const char *buf, size_t count)
+{
+unsigned int input;
+int ret;
+ret = sscanf(buf, "%u", &input);
+if (ret != 1)
+return -EINVAL;
+dbs_tuners_ins.boostfreq = input;
+return count;
+}
+
+static ssize_t store_sampling_rate(struct kobject *a, struct attribute *b,
+const char *buf, size_t count)
+{
+unsigned int input;
+int ret;
+ret = sscanf(buf, "%u", &input);
+if (ret != 1)
+return -EINVAL;
+update_sampling_rate(input);
+hyper_current_sampling_rate = dbs_tuners_ins.sampling_rate;
+return count;
+}
+
+static ssize_t store_io_is_busy(struct kobject *a, struct attribute *b,
+const char *buf, size_t count)
+{
+unsigned int input;
+int ret;
+
+ret = sscanf(buf, "%u", &input);
+if (ret != 1)
+return -EINVAL;
+dbs_tuners_ins.io_is_busy = !!input;
+return count;
+}
+
+static ssize_t store_up_threshold(struct kobject *a, struct attribute *b,
+const char *buf, size_t count)
+{
+unsigned int input;
+int ret;
+ret = sscanf(buf, "%u", &input);
+
+if (ret != 1 || input > MAX_FREQUENCY_UP_THRESHOLD ||
+input < MIN_FREQUENCY_UP_THRESHOLD) {
+return -EINVAL;
+}
+dbs_tuners_ins.up_threshold = input;
+return count;
+}
+
+static ssize_t store_up_threshold_min_freq(struct kobject *a, struct attribute *b,
+const char *buf, size_t count)
+{
+unsigned int input;
+int ret;
+ret = sscanf(buf, "%u", &input);
+
+if (ret != 1 || input > MAX_FREQUENCY_UP_THRESHOLD ||
+input < MIN_FREQUENCY_UP_THRESHOLD) {
+return -EINVAL;
+}
+dbs_tuners_ins.up_threshold_min_freq = input;
+return count;
+}
+
+static ssize_t store_sampling_down_factor(struct kobject *a,
+struct attribute *b, const char *buf, size_t count)
+{
+unsigned int input, j;
+int ret;
+ret = sscanf(buf, "%u", &input);
+
+if (ret != 1 || input > MAX_SAMPLING_DOWN_FACTOR || input < 1)
+return -EINVAL;
+dbs_tuners_ins.sampling_down_factor = input;
+
+/* Reset down sampling multiplier in case it was active */
+for_each_online_cpu(j) {
+struct cpu_dbs_info_s *dbs_info;
+dbs_info = &per_cpu(od_cpu_dbs_info, j);
+dbs_info->rate_mult = 1;
+}
+return count;
+}
+
+static ssize_t store_ignore_nice_load(struct kobject *a, struct attribute *b,
+const char *buf, size_t count)
+{
+unsigned int input;
+int ret;
+
+unsigned int j;
+
+ret = sscanf(buf, "%u", &input);
+if (ret != 1)
+return -EINVAL;
+
+if (input > 1)
+input = 1;
+
+if (input == dbs_tuners_ins.ignore_nice) { /* nothing to do */
+return count;
+}
+dbs_tuners_ins.ignore_nice = input;
+
+/* we need to re-evaluate prev_cpu_idle */
+for_each_online_cpu(j) {
+struct cpu_dbs_info_s *dbs_info;
+dbs_info = &per_cpu(od_cpu_dbs_info, j);
+dbs_info->prev_cpu_idle = get_cpu_idle_time(j,
+&dbs_info->prev_cpu_wall);
+if (dbs_tuners_ins.ignore_nice)
+dbs_info->prev_cpu_nice = kstat_cpu(j).cpustat.nice;
+
+}
+return count;
+}
+
+static ssize_t store_powersave_bias(struct kobject *a, struct attribute *b,
+const char *buf, size_t count)
+{
+unsigned int input;
+int ret;
+ret = sscanf(buf, "%u", &input);
+
+if (ret != 1)
+return -EINVAL;
+
+if (input > 1000)
+input = 1000;
+
+dbs_tuners_ins.powersave_bias = input;
+HYPER_powersave_bias_init();
+return count;
+}
+
+static ssize_t store_down_differential(struct kobject *a, struct attribute *b,
+const char *buf, size_t count)
+{
+unsigned int input;
+int ret;
+ret = sscanf(buf, "%u", &input);
+if (ret != 1)
+return -EINVAL;
+dbs_tuners_ins.down_differential = min(input, 100u);
+return count;
+}
+
+static ssize_t store_freq_step(struct kobject *a, struct attribute *b,
+const char *buf, size_t count)
+{
+unsigned int input;
+int ret;
+ret = sscanf(buf, "%u", &input);
+if (ret != 1)
+return -EINVAL;
+dbs_tuners_ins.freq_step = min(input, 100u);
+return count;
+}
+
+static ssize_t store_freq_responsiveness(struct kobject *a, struct attribute *b,
+const char *buf, size_t count)
+{
+unsigned int input;
+int ret;
+ret = sscanf(buf, "%u", &input);
+
+if (ret != 1)
+return -EINVAL;
+
+if (input > 1400000)
+input = 1400000;
+
+if (input < 100000)
+input = 100000;
+
+dbs_tuners_ins.freq_responsiveness = input;
+
+return count;
+}
+
+define_one_global_rw(sampling_rate);
+define_one_global_rw(io_is_busy);
+define_one_global_rw(up_threshold);
+define_one_global_rw(up_threshold_min_freq);
+define_one_global_rw(sampling_down_factor);
+define_one_global_rw(ignore_nice_load);
+define_one_global_rw(powersave_bias);
+define_one_global_rw(down_differential);
+define_one_global_rw(boostpulse);
+define_one_global_rw(boosttime);
+define_one_global_rw(boostfreq);
+define_one_global_rw(freq_step);
+define_one_global_rw(freq_responsiveness);
+
+static struct attribute *dbs_attributes[] = {
+&sampling_rate_min.attr,
+&sampling_rate.attr,
+&up_threshold.attr,
+&up_threshold_min_freq.attr,
+&sampling_down_factor.attr,
+&ignore_nice_load.attr,
+&powersave_bias.attr,
+&io_is_busy.attr,
+&down_differential.attr,
+&boostpulse.attr,
+&boosttime.attr,
+&boostfreq.attr,
+&freq_step.attr,
+&freq_responsiveness.attr,
+NULL
+};
+
+static struct attribute_group dbs_attr_group = {
+.attrs = dbs_attributes,
+.name = "HYPER",
+};
+
+/************************** sysfs end ************************/
+
+static void dbs_freq_increase(struct cpufreq_policy *p, unsigned int freq)
+{
+if (dbs_tuners_ins.powersave_bias)
+freq = powersave_bias_target(p, freq, CPUFREQ_RELATION_H);
+#if !defined(CONFIG_ARCH_EXYNOS4) && !defined(CONFIG_ARCH_EXYNOS5)
+else if (p->cur == p->max)
+return;
+#endif
+
+__cpufreq_driver_target(p, freq, dbs_tuners_ins.powersave_bias ?
+CPUFREQ_RELATION_L : CPUFREQ_RELATION_H);
+}
+
+static void dbs_check_cpu(struct cpu_dbs_info_s *this_dbs_info)
+{
+/* Extrapolated load of this CPU */
+unsigned int load_at_max_freq = 0;
+unsigned int avg_load_at_max_freq = 0;
+unsigned int max_load_freq;
+/* Current load across this CPU */
+unsigned int cur_load = 0;
+
+struct cpufreq_policy *policy;
+unsigned int j;
+int up_threshold = dbs_tuners_ins.up_threshold;
+
+this_dbs_info->freq_lo = 0;
+policy = this_dbs_info->cur_policy;
+
+/* Only core0 controls the boost */
+if (dbs_tuners_ins.boosted && policy->cpu == 0) {
+if (ktime_to_us(ktime_get()) - hyper_freq_boosted_time >=
+dbs_tuners_ins.freq_boost_time) {
+dbs_tuners_ins.boosted = 0;
+}
+}
+
+/* Only core0 controls the timer_rate */
+if (hyper_sampling_rate_boosted && policy->cpu == 0) {
+if (ktime_to_us(ktime_get()) - hyper_sampling_rate_boosted_time >=
+TIMER_RATE_BOOST_TIME) {
+
+dbs_tuners_ins.sampling_rate = hyper_current_sampling_rate;
+hyper_sampling_rate_boosted = 0;
+}
+}
+
+/*
+* Every sampling_rate, we check, if current idle time is less
+* than 20% (default), then we try to increase frequency
+* Every sampling_rate, we look for a the lowest
+* frequency which can sustain the load while keeping idle time over
+* 30%. If such a frequency exist, we try to decrease to this frequency.
+*
+* Any frequency increase takes it to the maximum frequency.
+* Frequency reduction happens at minimum steps of
+* 5% (default) of current frequency
+*/
+
+/* Get Absolute Load - in terms of freq */
+max_load_freq = 0;
+
+for_each_cpu(j, policy->cpus) {
+struct cpu_dbs_info_s *j_dbs_info;
+cputime64_t cur_wall_time, cur_idle_time, cur_iowait_time;
+unsigned int idle_time, wall_time, iowait_time;
+unsigned int load_freq;
+int freq_avg;
+bool deep_sleep_detected = false;
+/* the evil magic numbers, only 2 at least */
+const unsigned int deep_sleep_backoff = 10;
+const unsigned int deep_sleep_factor = 5;
+
+j_dbs_info = &per_cpu(od_cpu_dbs_info, j);
+
+cur_idle_time = get_cpu_idle_time(j, &cur_wall_time);
+
+cur_iowait_time = get_cpu_iowait_time(j, &cur_wall_time);
+
+wall_time = (unsigned int)
+(cur_wall_time - j_dbs_info->prev_cpu_wall);
+j_dbs_info->prev_cpu_wall = cur_wall_time;
+
+/*
+* Ignore wall delta jitters in both directions. An
+* exceptionally long wall_time will likely result
+* idle but it was waken up to do work so the next
+* slice is less likely to want to run at low
+* frequency. Let's evaluate the next slice instead of
+* the idle long one that passed already and it's too
+* late to reduce in frequency. As opposed an
+* exceptionally short slice that just run at low
+* frequency is unlikely to be idle, but we may go
+* back to idle pretty soon and that not idle slice
+* already passed. If short slices will keep coming
+* after a series of long slices the exponential
+* backoff will converge faster and we'll react faster
+* to high load. As opposed we'll decay slower
+* towards low load and long idle times.
+*/
+if (j_dbs_info->prev_cpu_wall_delta >
+wall_time * deep_sleep_factor ||
+j_dbs_info->prev_cpu_wall_delta * deep_sleep_factor <
+wall_time)
+deep_sleep_detected = true;
+j_dbs_info->prev_cpu_wall_delta =
+(j_dbs_info->prev_cpu_wall_delta * deep_sleep_backoff
++ wall_time) / (deep_sleep_backoff+1);
+
+idle_time = (unsigned int)
+(cur_idle_time - j_dbs_info->prev_cpu_idle);
+j_dbs_info->prev_cpu_idle = cur_idle_time;
+
+iowait_time = (unsigned int)
+(cur_iowait_time - j_dbs_info->prev_cpu_iowait);
+j_dbs_info->prev_cpu_iowait = cur_iowait_time;
+
+if (dbs_tuners_ins.ignore_nice) {
+u64 cur_nice;
+unsigned long cur_nice_jiffies;
+
+cur_nice = kstat_cpu(j).cpustat.nice -
+j_dbs_info->prev_cpu_nice;
+/*
+* Assumption: nice time between sampling periods will
+* be less than 2^32 jiffies for 32 bit sys
+*/
+cur_nice_jiffies = (unsigned long)
+cputime64_to_jiffies64(cur_nice);
+
+j_dbs_info->prev_cpu_nice = kstat_cpu(j).cpustat.nice;
+idle_time += jiffies_to_usecs(cur_nice_jiffies);
+}
+
+if (deep_sleep_detected)
+continue;
+
+/*
+* For the purpose of HYPER, waiting for disk IO is an
+* indication that you're performance critical, and not that
+* the system is actually idle. So subtract the iowait time
+* from the cpu idle time.
+*/
+
+if (dbs_tuners_ins.io_is_busy && idle_time >= iowait_time)
+idle_time -= iowait_time;
+
+if (unlikely(!wall_time || wall_time < idle_time))
+continue;
+
+cur_load = 100 * (wall_time - idle_time) / wall_time;
+
+freq_avg = __cpufreq_driver_getavg(policy, j);
+if (freq_avg <= 0)
+freq_avg = policy->cur;
+
+load_freq = cur_load * freq_avg;
+if (load_freq > max_load_freq)
+max_load_freq = load_freq;
+
+/* calculate the scaled load across CPU */
+load_at_max_freq += (cur_load * policy->cur) /
+policy->cpuinfo.max_freq;
+
+avg_load_at_max_freq += ((load_at_max_freq +
+j_dbs_info->load_at_prev_sample) / 2);
+
+j_dbs_info->load_at_prev_sample = load_at_max_freq;
+}
+
+if (dbs_tuners_ins.sampling_rate < DEFAULT_SAMPLING_RATE)
+cpufreq_notify_utilization(policy, avg_load_at_max_freq);
+else
+cpufreq_notify_utilization(policy, load_at_max_freq);
+
+/* Check for frequency increase */
+if (policy->cur < dbs_tuners_ins.freq_responsiveness)
+up_threshold = dbs_tuners_ins.up_threshold_min_freq;
+
+if (max_load_freq > up_threshold * policy->cur) {
+int inc = (policy->max * dbs_tuners_ins.freq_step) / 100;
+int target = min(policy->max, policy->cur + inc);
+/* If switching to max speed, apply sampling_down_factor */
+if (policy->cur < policy->max && target == policy->max) {
+if (hyper_sampling_rate_boosted &&
+(dbs_tuners_ins.sampling_down_factor <
+BOOSTED_SAMPLING_DOWN_FACTOR)) {
+this_dbs_info->rate_mult =
+BOOSTED_SAMPLING_DOWN_FACTOR;
+} else {
+this_dbs_info->rate_mult =
+dbs_tuners_ins.sampling_down_factor;
+}
+}
+dbs_freq_increase(policy, target);
+return;
+}
+
+/* check for frequency boost */
+if (dbs_tuners_ins.boosted && policy->cur < dbs_tuners_ins.boostfreq) {
+dbs_freq_increase(policy, dbs_tuners_ins.boostfreq);
+dbs_tuners_ins.boostfreq = policy->cur;
+return;
+}
+
+/* Check for frequency decrease */
+#if !defined(CONFIG_ARCH_EXYNOS4) && !defined(CONFIG_ARCH_EXYNOS5)
+/* if we cannot reduce the frequency anymore, break out early */
+if (policy->cur == policy->min)
+return;
+#endif
+
+/*
+* The optimal frequency is the frequency that is the lowest that
+* can support the current CPU usage without triggering the up
+* policy. To be safe, we focus 10 points under the threshold.
+*/
+if (max_load_freq <
+(dbs_tuners_ins.up_threshold - dbs_tuners_ins.down_differential) *
+policy->cur) {
+unsigned int freq_next;
+unsigned int down_thres;
+freq_next = max_load_freq /
+(dbs_tuners_ins.up_threshold -
+dbs_tuners_ins.down_differential);
+
+if (dbs_tuners_ins.boosted &&
+freq_next < dbs_tuners_ins.boostfreq) {
+freq_next = dbs_tuners_ins.boostfreq;
+}
+/* No longer fully busy, reset rate_mult */
+this_dbs_info->rate_mult = 1;
+
+if (freq_next < policy->min)
+freq_next = policy->min;
+
+down_thres = dbs_tuners_ins.up_threshold_min_freq
+- dbs_tuners_ins.down_differential;
+
+if (freq_next < dbs_tuners_ins.freq_responsiveness
+&& (max_load_freq / freq_next) > down_thres)
+freq_next = dbs_tuners_ins.freq_responsiveness;
+
+if (!dbs_tuners_ins.powersave_bias) {
+__cpufreq_driver_target(policy, freq_next,
+CPUFREQ_RELATION_L);
+} else {
+int freq = powersave_bias_target(policy, freq_next,
+CPUFREQ_RELATION_L);
+__cpufreq_driver_target(policy, freq,
+CPUFREQ_RELATION_L);
+}
+}
+}
+
+static void do_dbs_timer(struct work_struct *work)
+{
+struct cpu_dbs_info_s *dbs_info =
+container_of(work, struct cpu_dbs_info_s, work.work);
+unsigned int cpu = dbs_info->cpu;
+int sample_type = dbs_info->sample_type;
+
+int delay;
+
+mutex_lock(&dbs_info->timer_mutex);
+
+/* Common NORMAL_SAMPLE setup */
+dbs_info->sample_type = DBS_NORMAL_SAMPLE;
+if (!dbs_tuners_ins.powersave_bias ||
+sample_type == DBS_NORMAL_SAMPLE) {
+dbs_check_cpu(dbs_info);
+if (dbs_info->freq_lo) {
+/* Setup timer for SUB_SAMPLE */
+dbs_info->sample_type = DBS_SUB_SAMPLE;
+delay = dbs_info->freq_hi_jiffies;
+} else {
+/* We want all CPUs to do sampling nearly on
+* same jiffy
+*/
+delay = usecs_to_jiffies(effective_sampling_rate()
+* dbs_info->rate_mult);
+
+if (num_online_cpus() > 1)
+delay -= jiffies % delay;
+}
+} else {
+__cpufreq_driver_target(dbs_info->cur_policy,
+dbs_info->freq_lo, CPUFREQ_RELATION_H);
+delay = dbs_info->freq_lo_jiffies;
+}
+schedule_delayed_work_on(cpu, &dbs_info->work, delay);
+mutex_unlock(&dbs_info->timer_mutex);
+}
+
+static inline void dbs_timer_init(struct cpu_dbs_info_s *dbs_info)
+{
+/* We want all CPUs to do sampling nearly on same jiffy */
+int delay = usecs_to_jiffies(effective_sampling_rate());
+
+if (num_online_cpus() > 1)
+delay -= jiffies % delay;
+
+dbs_info->sample_type = DBS_NORMAL_SAMPLE;
+INIT_DELAYED_WORK_DEFERRABLE(&dbs_info->work, do_dbs_timer);
+schedule_delayed_work_on(dbs_info->cpu, &dbs_info->work, 10 * delay);
+dbs_info->activated = true;
+}
+
+static inline void dbs_timer_exit(struct cpu_dbs_info_s *dbs_info)
+{
+dbs_info->activated = false;
+cancel_delayed_work_sync(&dbs_info->work);
+}
+
+/*
+* Not all CPUs want IO time to be accounted as busy; this dependson how
+* efficient idling at a higher frequency/voltage is.
+* Pavel Machek says this is not so for various generations of AMD and old
+* Intel systems.
+* Mike Chan (androidlcom) calis this is also not true for ARM.
+* Because of this, whitelist specific known (series) of CPUs by default, and
+* leave all others up to the user.
+*/
+static int should_io_be_busy(void)
+{
+return 0;
+}
+
+static int cpufreq_governor_dbs(struct cpufreq_policy *policy,
+unsigned int event)
+{
+unsigned int cpu = policy->cpu;
+struct cpu_dbs_info_s *this_dbs_info;
+unsigned int j;
+int rc;
+
+this_dbs_info = &per_cpu(od_cpu_dbs_info, cpu);
+
+switch (event) {
+case CPUFREQ_GOV_START:
+if ((!cpu_online(cpu)) || (!policy->cur))
+return -EINVAL;
+
+mutex_lock(&dbs_mutex);
+
+dbs_enable++;
+for_each_cpu(j, policy->cpus) {
+struct cpu_dbs_info_s *j_dbs_info;
+j_dbs_info = &per_cpu(od_cpu_dbs_info, j);
+j_dbs_info->cur_policy = policy;
+
+j_dbs_info->prev_cpu_idle = get_cpu_idle_time(j,
+&j_dbs_info->prev_cpu_wall);
+if (dbs_tuners_ins.ignore_nice)
+j_dbs_info->prev_cpu_nice =
+kstat_cpu(j).cpustat.nice;
+}
+this_dbs_info->cpu = cpu;
+this_dbs_info->rate_mult = 1;
+hyper_power_powersave_bias_init_cpu(cpu);
+/*
+* Start the timerschedule work, when this governor
+* is used for first time
+*/
+if (dbs_enable == 1) {
+unsigned int latency;
+
+rc = sysfs_create_group(cpufreq_global_kobject,
+&dbs_attr_group);
+if (rc) {
+mutex_unlock(&dbs_mutex);
+return rc;
+}
+
+/* policy latency is in nS. Convert it to uS first */
+latency = policy->cpuinfo.transition_latency / 1000;
+if (latency == 0)
+latency = 1;
+/* Bring kernel and HW constraints together */
+min_sampling_rate = max(min_sampling_rate,
+MIN_LATENCY_MULTIPLIER * latency);
+dbs_tuners_ins.sampling_rate =
+max(min_sampling_rate,
+latency * LATENCY_MULTIPLIER);
+dbs_tuners_ins.io_is_busy = should_io_be_busy();
+}
+mutex_unlock(&dbs_mutex);
+
+mutex_init(&this_dbs_info->timer_mutex);
+dbs_timer_init(this_dbs_info);
+break;
+
+case CPUFREQ_GOV_STOP:
+dbs_timer_exit(this_dbs_info);
+
+mutex_lock(&dbs_mutex);
+mutex_destroy(&this_dbs_info->timer_mutex);
+dbs_enable--;
+mutex_unlock(&dbs_mutex);
+if (!dbs_enable)
+sysfs_remove_group(cpufreq_global_kobject,
+&dbs_attr_group);
+
+break;
+
+case CPUFREQ_GOV_LIMITS:
+mutex_lock(&this_dbs_info->timer_mutex);
+if (policy->max < this_dbs_info->cur_policy->cur)
+__cpufreq_driver_target(this_dbs_info->cur_policy,
+policy->max, CPUFREQ_RELATION_H);
+else if (policy->min > this_dbs_info->cur_policy->cur)
+__cpufreq_driver_target(this_dbs_info->cur_policy,
+policy->min, CPUFREQ_RELATION_L);
+mutex_unlock(&this_dbs_info->timer_mutex);
+break;
+}
+return 0;
+}
+
+/**
+* qos_dvfs_lat_notify - PM QoS Notifier for DVFS_LATENCY QoS Request
+* @nb notifier block struct
+* @value QoS value
+* @dummy
+*/
+static int qos_dvfs_lat_notify(struct notifier_block *nb, unsigned long value,
+void *dummy)
+{
+/*
+* In the worst case, with a continuous up-treshold + e cpu load
+* from up-threshold - e load, the ondemand governor will react
+* sampling_rate * 2.
+*
+* Thus, based on the worst case scenario, we use value / 2;
+*/
+dbs_tuners_ins.dvfs_lat_qos_wants = value / 2;
+
+/* Update sampling rate */
+update_sampling_rate(0);
+
+return NOTIFY_OK;
+}
+
+static struct notifier_block HYPER_qos_dvfs_lat_nb = {
+.notifier_call = qos_dvfs_lat_notify,
+};
+
+static int __init cpufreq_gov_dbs_init(void)
+{
+cputime64_t wall;
+u64 idle_time;
+int cpu = get_cpu();
+int err = 0;
+
+idle_time = get_cpu_idle_time_us(cpu, &wall);
+put_cpu();
+if (idle_time != -1ULL) {
+/* Idle micro accounting is supported. Use finer thresholds */
+dbs_tuners_ins.up_threshold = MICRO_FREQUENCY_UP_THRESHOLD;
+dbs_tuners_ins.down_differential =
+MICRO_FREQUENCY_DOWN_DIFFERENTIAL;
+/*
+* In no_hz/micro accounting case we set the minimum frequency
+* not depending on HZ, but fixed (very low). The deferred
+* timer might skip some samples if idle/sleeping as needed.
+*/
+min_sampling_rate = MICRO_FREQUENCY_MIN_SAMPLE_RATE;
+} else {
+/* For correct statistics, we need 10 ticks for each measure */
+min_sampling_rate =
+MIN_SAMPLING_RATE_RATIO * jiffies_to_usecs(10);
+}
+
+err = pm_qos_add_notifier(PM_QOS_DVFS_RESPONSE_LATENCY,
+&HYPER_qos_dvfs_lat_nb);
+if (err)
+return err;
+
+err = cpufreq_register_governor(&cpufreq_gov_HYPER);
+if (err) {
+pm_qos_remove_notifier(PM_QOS_DVFS_RESPONSE_LATENCY,
+&HYPER_qos_dvfs_lat_nb);
+}
+
+return err;
+}
+
+static void __exit cpufreq_gov_dbs_exit(void)
+{
+pm_qos_remove_notifier(PM_QOS_DVFS_RESPONSE_LATENCY,
+&HYPER_qos_dvfs_lat_nb);
+
+cpufreq_unregister_governor(&cpufreq_gov_HYPER);
+}
+
+MODULE_AUTHOR("Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>");
+MODULE_AUTHOR("Alexey Starikovskiy <alexey.y.starikovskiy@intel.com>");
+MODULE_DESCRIPTION("'cpufreq_HYPER' - A dynamic cpufreq governor for "
+"Low Latency Frequency Transition capable processors");
+MODULE_LICENSE("GPL");
+
+#ifdef CONFIG_CPU_FREQ_DEFAULT_GOV_HYPER
+fs_initcall(cpufreq_gov_dbs_init);
+#else
+module_init(cpufreq_gov_dbs_init);
+#endif
+module_exit(cpufreq_gov_dbs_exit);
diff -urNp Kernel/drivers/cpufreq/cpufreq_lagfree.c HelloWorld-Renew-v1.0-n7000-jb/drivers/cpufreq/cpufreq_lagfree.c
--- Kernel/drivers/cpufreq/cpufreq_lagfree.c	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/drivers/cpufreq/cpufreq_lagfree.c	2013-04-25 17:38:09.000000000 +0200
@@ -0,0 +1,684 @@
+/*
+ *  drivers/cpufreq/cpufreq_lagfree.c
+ *
+ *  Copyright (C)  2001 Russell King
+ *            (C)  2003 Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>.
+ *                      Jun Nakajima <jun.nakajima@intel.com>
+ *            (C)  2004 Alexander Clouter <alex-kernel@digriz.org.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/smp.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/ctype.h>
+#include <linux/cpufreq.h>
+#include <linux/sysctl.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/sysfs.h>
+#include <linux/cpu.h>
+#include <linux/kmod.h>
+#include <linux/workqueue.h>
+#include <linux/jiffies.h>
+#include <linux/kernel_stat.h>
+#include <linux/percpu.h>
+#include <linux/mutex.h>
+#include <linux/earlysuspend.h>
+/*
+ * dbs is used in this file as a shortform for demandbased switching
+ * It helps to keep variable names smaller, simpler
+ */
+
+#define DEF_FREQUENCY_UP_THRESHOLD				(60)
+#define DEF_FREQUENCY_DOWN_THRESHOLD				(30)
+#define FREQ_STEP_DOWN 						(200000)
+static unsigned int step_down;
+#define FREQ_SLEEP_MAX 						(500000)
+static unsigned int sleep_max;
+#define FREQ_AWAKE_MIN 						(100000)
+static unsigned int awake_min;
+#define FREQ_STEP_UP_SLEEP_PERCENT				(15)
+
+/*
+ * The polling frequency of this governor depends on the capability of
+ * the processor. Default polling frequency is 1000 times the transition
+ * latency of the processor. The governor will work on any processor with
+ * transition latency <= 10mS, using appropriate sampling
+ * rate.
+ * For CPUs with transition latency > 10mS (mostly drivers
+ * with CPUFREQ_ETERNAL), this governor will not work.
+ * All times here are in uS.
+ */
+#define MIN_SAMPLING_RATE_RATIO			(1)
+
+static unsigned int min_sampling_rate;
+unsigned int suspended = 0;
+#define LATENCY_MULTIPLIER			(500)
+#define MIN_LATENCY_MULTIPLIER			(100)
+#define DEF_SAMPLING_DOWN_FACTOR		(2)
+#define MAX_SAMPLING_DOWN_FACTOR		(10)
+#define TRANSITION_LATENCY_LIMIT		(10 * 1000 * 1000)
+
+static void do_dbs_timer(struct work_struct *work);
+
+struct cpu_dbs_info_s {
+	struct cpufreq_policy *cur_policy;
+	unsigned int prev_cpu_idle_up;
+	unsigned int prev_cpu_idle_down;
+	unsigned int enable;
+	unsigned int down_skip;
+	unsigned int requested_freq;
+};
+static DEFINE_PER_CPU(struct cpu_dbs_info_s, cpu_dbs_info);
+
+static unsigned int dbs_enable;	/* number of CPUs using this policy */
+
+/*
+ * DEADLOCK ALERT! There is a ordering requirement between cpu_hotplug
+ * lock and dbs_mutex. cpu_hotplug lock should always be held before
+ * dbs_mutex. If any function that can potentially take cpu_hotplug lock
+ * (like __cpufreq_driver_target()) is being called with dbs_mutex taken, then
+ * cpu_hotplug lock should be taken before that. Note that cpu_hotplug lock
+ * is recursive for the same process. -Venki
+ */
+static DEFINE_MUTEX (dbs_mutex);
+static DECLARE_DELAYED_WORK(dbs_work, do_dbs_timer);
+
+struct dbs_tuners {
+	unsigned int sampling_rate;
+	unsigned int sampling_down_factor;
+	unsigned int up_threshold;
+	unsigned int down_threshold;
+	unsigned int ignore_nice;
+	//unsigned int freq_step;
+};
+
+static struct dbs_tuners dbs_tuners_ins = {
+	.up_threshold = DEF_FREQUENCY_UP_THRESHOLD,
+	.down_threshold = DEF_FREQUENCY_DOWN_THRESHOLD,
+	.sampling_down_factor = DEF_SAMPLING_DOWN_FACTOR,
+	.ignore_nice = 1,
+	//.freq_step = 5,
+};
+
+static inline unsigned int get_cpu_idle_time(unsigned int cpu)
+{
+	unsigned int add_nice = 0, ret;
+
+	if (dbs_tuners_ins.ignore_nice)
+		add_nice = kstat_cpu(cpu).cpustat.nice;
+
+	ret = kstat_cpu(cpu).cpustat.idle +
+		kstat_cpu(cpu).cpustat.iowait +
+		add_nice;
+
+	return ret;
+}
+
+/* keep track of frequency transitions */
+static int
+dbs_cpufreq_notifier(struct notifier_block *nb, unsigned long val,
+		     void *data)
+{
+	struct cpufreq_freqs *freq = data;
+	struct cpu_dbs_info_s *this_dbs_info = &per_cpu(cpu_dbs_info,
+							freq->cpu);
+
+	if (!this_dbs_info->enable)
+		return 0;
+
+	this_dbs_info->requested_freq = freq->new;
+
+	return 0;
+}
+
+static struct notifier_block dbs_cpufreq_notifier_block = {
+	.notifier_call = dbs_cpufreq_notifier
+};
+
+/************************** sysfs interface ************************/
+static ssize_t show_sampling_rate_max(struct cpufreq_policy *policy, char *buf)
+{
+	return sprintf (buf, "%u\n", min_sampling_rate*100);
+}
+
+static ssize_t show_sampling_rate_min(struct cpufreq_policy *policy, char *buf)
+{
+	return sprintf (buf, "%u\n", min_sampling_rate);
+}
+
+#define define_one_ro(_name)				\
+static struct freq_attr _name =				\
+__ATTR(_name, 0444, show_##_name, NULL)
+
+define_one_ro(sampling_rate_max);
+define_one_ro(sampling_rate_min);
+
+/* cpufreq_lagfree Governor Tunables */
+#define show_one(file_name, object)					\
+static ssize_t show_##file_name						\
+(struct cpufreq_policy *unused, char *buf)				\
+{									\
+	return sprintf(buf, "%u\n", dbs_tuners_ins.object);		\
+}
+show_one(sampling_rate, sampling_rate);
+show_one(sampling_down_factor, sampling_down_factor);
+show_one(up_threshold, up_threshold);
+show_one(down_threshold, down_threshold);
+show_one(ignore_nice_load, ignore_nice);
+//show_one(freq_step, freq_step);
+
+static ssize_t store_sampling_down_factor(struct cpufreq_policy *unused,
+		const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf (buf, "%u", &input);
+	if (ret != 1 || input > 25 || input < 1)
+		return -EINVAL;
+
+	mutex_lock(&dbs_mutex);
+	dbs_tuners_ins.sampling_down_factor = input;
+	mutex_unlock(&dbs_mutex);
+
+	return count;
+}
+
+static ssize_t store_sampling_rate(struct cpufreq_policy *unused,
+		const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf (buf, "%u", &input);
+
+	mutex_lock(&dbs_mutex);
+	if (ret != 1 || input > min_sampling_rate*100 || input < min_sampling_rate) {
+		mutex_unlock(&dbs_mutex);
+		return -EINVAL;
+	}
+
+	dbs_tuners_ins.sampling_rate = input;
+	mutex_unlock(&dbs_mutex);
+
+	return count;
+}
+
+static ssize_t store_up_threshold(struct cpufreq_policy *unused,
+		const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf (buf, "%u", &input);
+
+	mutex_lock(&dbs_mutex);
+	if (ret != 1 || input > 100 || input <= dbs_tuners_ins.down_threshold) {
+		mutex_unlock(&dbs_mutex);
+		return -EINVAL;
+	}
+
+	dbs_tuners_ins.up_threshold = input;
+	mutex_unlock(&dbs_mutex);
+
+	return count;
+}
+
+static ssize_t store_down_threshold(struct cpufreq_policy *unused,
+		const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf (buf, "%u", &input);
+
+	mutex_lock(&dbs_mutex);
+	if (ret != 1 || input > 100 || input >= dbs_tuners_ins.up_threshold) {
+		mutex_unlock(&dbs_mutex);
+		return -EINVAL;
+	}
+
+	dbs_tuners_ins.down_threshold = input;
+	mutex_unlock(&dbs_mutex);
+
+	return count;
+}
+
+static ssize_t store_ignore_nice_load(struct cpufreq_policy *policy,
+		const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+
+	unsigned int j;
+
+	ret = sscanf(buf, "%u", &input);
+	if (ret != 1)
+		return -EINVAL;
+
+	if (input > 1)
+		input = 1;
+
+	mutex_lock(&dbs_mutex);
+	if (input == dbs_tuners_ins.ignore_nice) { /* nothing to do */
+		mutex_unlock(&dbs_mutex);
+		return count;
+	}
+	dbs_tuners_ins.ignore_nice = input;
+
+	/* we need to re-evaluate prev_cpu_idle_up and prev_cpu_idle_down */
+	for_each_online_cpu(j) {
+		struct cpu_dbs_info_s *j_dbs_info;
+		j_dbs_info = &per_cpu(cpu_dbs_info, j);
+		j_dbs_info->prev_cpu_idle_up = get_cpu_idle_time(j);
+		j_dbs_info->prev_cpu_idle_down = j_dbs_info->prev_cpu_idle_up;
+	}
+	mutex_unlock(&dbs_mutex);
+
+	return count;
+}
+
+/*static ssize_t store_freq_step(struct cpufreq_policy *policy,
+		const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1)
+		return -EINVAL;
+
+	if (input > 100)
+		input = 100;
+
+	/ * no need to test here if freq_step is zero as the user might actually
+	 * want this, they would be crazy though :) * /
+	mutex_lock(&dbs_mutex);
+	dbs_tuners_ins.freq_step = input;
+	mutex_unlock(&dbs_mutex);
+
+	return count;
+}*/
+
+#define define_one_rw(_name) \
+static struct freq_attr _name = \
+__ATTR(_name, 0644, show_##_name, store_##_name)
+
+define_one_rw(sampling_rate);
+define_one_rw(sampling_down_factor);
+define_one_rw(up_threshold);
+define_one_rw(down_threshold);
+define_one_rw(ignore_nice_load);
+//define_one_rw(freq_step);
+
+static struct attribute * dbs_attributes[] = {
+	&sampling_rate_max.attr,
+	&sampling_rate_min.attr,
+	&sampling_rate.attr,
+	&sampling_down_factor.attr,
+	&up_threshold.attr,
+	&down_threshold.attr,
+	&ignore_nice_load.attr,
+	//&freq_step.attr,
+	NULL
+};
+
+static struct attribute_group dbs_attr_group = {
+	.attrs = dbs_attributes,
+	.name = "lagfree",
+};
+
+/************************** sysfs end ************************/
+
+static void dbs_check_cpu(int cpu)
+{
+	unsigned int idle_ticks, up_idle_ticks, down_idle_ticks;
+	unsigned int tmp_idle_ticks, total_idle_ticks;
+	unsigned int freq_target;
+	unsigned int freq_down_sampling_rate;
+	struct cpu_dbs_info_s *this_dbs_info = &per_cpu(cpu_dbs_info, cpu);
+	struct cpufreq_policy *policy;
+
+	if (!this_dbs_info->enable)
+		return;
+
+	policy = this_dbs_info->cur_policy;
+
+	/*
+	 * The default safe range is 20% to 80%
+	 * Every sampling_rate, we check
+	 *	- If current idle time is less than 20%, then we try to
+	 *	  increase frequency
+	 * Every sampling_rate*sampling_down_factor, we check
+	 *	- If current idle time is more than 80%, then we try to
+	 *	  decrease frequency
+	 *
+	 * Any frequency increase takes it to the maximum frequency.
+	 * Frequency reduction happens at minimum steps of
+	 * 5% (default) of max_frequency
+	 */
+
+	/* Check for frequency increase */
+	idle_ticks = UINT_MAX;
+
+	/* Check for frequency increase */
+	total_idle_ticks = get_cpu_idle_time(cpu);
+	tmp_idle_ticks = total_idle_ticks -
+		this_dbs_info->prev_cpu_idle_up;
+	this_dbs_info->prev_cpu_idle_up = total_idle_ticks;
+
+	if (tmp_idle_ticks < idle_ticks)
+		idle_ticks = tmp_idle_ticks;
+
+	/* Scale idle ticks by 100 and compare with up and down ticks */
+	idle_ticks *= 100;
+	up_idle_ticks = (100 - dbs_tuners_ins.up_threshold) *
+			usecs_to_jiffies(dbs_tuners_ins.sampling_rate);
+
+	if (idle_ticks < up_idle_ticks) {
+		this_dbs_info->down_skip = 0;
+		this_dbs_info->prev_cpu_idle_down =
+			this_dbs_info->prev_cpu_idle_up;
+
+		/* if we are already at full speed then break out early */
+		if (this_dbs_info->requested_freq == policy->max && !suspended)
+			return;
+
+		//freq_target = (dbs_tuners_ins.freq_step * policy->max) / 100;
+		if (suspended)
+			freq_target = (FREQ_STEP_UP_SLEEP_PERCENT * policy->max) / 100;
+		else
+			freq_target = policy->max;
+
+		/* max freq cannot be less than 100. But who knows.... */
+		if (unlikely(freq_target == 0))
+			freq_target = 5;
+
+		this_dbs_info->requested_freq += freq_target;
+		if (this_dbs_info->requested_freq > policy->max)
+			this_dbs_info->requested_freq = policy->max;
+		
+		//Screen off mode
+		if (suspended && this_dbs_info->requested_freq > sleep_max)
+			this_dbs_info->requested_freq = sleep_max;
+		    
+		//Screen off mode
+		if (!suspended && this_dbs_info->requested_freq < awake_min)
+			this_dbs_info->requested_freq = awake_min;
+
+		__cpufreq_driver_target(policy, this_dbs_info->requested_freq,
+			CPUFREQ_RELATION_H);
+		return;
+	}
+
+	/* Check for frequency decrease */
+	this_dbs_info->down_skip++;
+	if (this_dbs_info->down_skip < dbs_tuners_ins.sampling_down_factor)
+		return;
+
+	/* Check for frequency decrease */
+	total_idle_ticks = this_dbs_info->prev_cpu_idle_up;
+	tmp_idle_ticks = total_idle_ticks -
+		this_dbs_info->prev_cpu_idle_down;
+	this_dbs_info->prev_cpu_idle_down = total_idle_ticks;
+
+	if (tmp_idle_ticks < idle_ticks)
+		idle_ticks = tmp_idle_ticks;
+
+	/* Scale idle ticks by 100 and compare with up and down ticks */
+	idle_ticks *= 100;
+	this_dbs_info->down_skip = 0;
+
+	freq_down_sampling_rate = dbs_tuners_ins.sampling_rate *
+		dbs_tuners_ins.sampling_down_factor;
+	down_idle_ticks = (100 - dbs_tuners_ins.down_threshold) *
+		usecs_to_jiffies(freq_down_sampling_rate);
+
+	if (idle_ticks > down_idle_ticks) {
+		/*
+		 * if we are already at the lowest speed then break out early
+		 * or if we 'cannot' reduce the speed as the user might want
+		 * freq_target to be zero
+		 */
+		if (this_dbs_info->requested_freq == policy->min && suspended
+				/*|| dbs_tuners_ins.freq_step == 0*/)
+			return;
+
+		//freq_target = (dbs_tuners_ins.freq_step * policy->max) / 100;
+		freq_target = step_down; //policy->max;
+
+		/* max freq cannot be less than 100. But who knows.... */
+		if (unlikely(freq_target == 0))
+			freq_target = 5;
+
+		// prevent going under 0
+		if(freq_target > this_dbs_info->requested_freq)
+			this_dbs_info->requested_freq = policy->min;
+		else
+			this_dbs_info->requested_freq -= freq_target;
+		
+		if (this_dbs_info->requested_freq < policy->min)
+			this_dbs_info->requested_freq = policy->min;
+			
+		//Screen on mode
+		if (!suspended && this_dbs_info->requested_freq < awake_min)
+			this_dbs_info->requested_freq = awake_min;
+		
+		//Screen off mode
+		if (suspended && this_dbs_info->requested_freq > sleep_max)
+			this_dbs_info->requested_freq = sleep_max;
+
+		__cpufreq_driver_target(policy, this_dbs_info->requested_freq,
+				CPUFREQ_RELATION_H);
+		return;
+	}
+}
+
+static void do_dbs_timer(struct work_struct *work)
+{
+	int i;
+	mutex_lock(&dbs_mutex);
+	for_each_online_cpu(i)
+		dbs_check_cpu(i);
+	schedule_delayed_work(&dbs_work,
+			usecs_to_jiffies(dbs_tuners_ins.sampling_rate));
+	mutex_unlock(&dbs_mutex);
+}
+
+static inline void dbs_timer_init(void)
+{
+	init_timer_deferrable(&dbs_work.timer);
+	schedule_delayed_work(&dbs_work,
+			usecs_to_jiffies(dbs_tuners_ins.sampling_rate));
+	return;
+}
+
+static inline void dbs_timer_exit(void)
+{
+	cancel_delayed_work(&dbs_work);
+	return;
+}
+
+static void lagfree_early_suspend(struct early_suspend *handler) {
+	suspended = 1;
+}
+
+static void lagfree_late_resume(struct early_suspend *handler) {
+	suspended = 0;
+}
+
+static struct early_suspend lagfree_power_suspend = {
+	.suspend = lagfree_early_suspend,
+	.resume = lagfree_late_resume,
+	.level = EARLY_SUSPEND_LEVEL_DISABLE_FB + 1,
+};
+
+static int cpufreq_governor_dbs(struct cpufreq_policy *policy,
+				   unsigned int event)
+{
+	unsigned int cpu = policy->cpu;
+	struct cpu_dbs_info_s *this_dbs_info;
+	unsigned int j;
+	int rc;
+	unsigned int min_freq = ~0;
+	unsigned int max_freq = 0;
+	unsigned int i;
+	struct cpufreq_frequency_table *freq_table;
+
+	this_dbs_info = &per_cpu(cpu_dbs_info, cpu);
+
+	switch (event) {
+	case CPUFREQ_GOV_START:
+		if ((!cpu_online(cpu)) || (!policy->cur))
+			return -EINVAL;
+
+		if (this_dbs_info->enable) /* Already enabled */
+			break;
+
+		mutex_lock(&dbs_mutex);
+
+		rc = sysfs_create_group(&policy->kobj, &dbs_attr_group);
+		if (rc) {
+			mutex_unlock(&dbs_mutex);
+			return rc;
+		}
+
+		for_each_cpu(j, policy->cpus) {
+			struct cpu_dbs_info_s *j_dbs_info;
+			j_dbs_info = &per_cpu(cpu_dbs_info, j);
+			j_dbs_info->cur_policy = policy;
+
+			j_dbs_info->prev_cpu_idle_up = get_cpu_idle_time(cpu);
+			j_dbs_info->prev_cpu_idle_down
+				= j_dbs_info->prev_cpu_idle_up;
+		}
+		this_dbs_info->enable = 1;
+		this_dbs_info->down_skip = 0;
+		this_dbs_info->requested_freq = policy->cur;
+
+		dbs_enable++;
+		/*
+		 * Start the timerschedule work, when this governor
+		 * is used for first time
+		 */
+		if (dbs_enable == 1) {
+			unsigned int latency;
+			/* policy latency is in nS. Convert it to uS first */
+			latency = policy->cpuinfo.transition_latency / 1000;
+			if (latency == 0)
+				latency = 1;
+
+			/*
+			 * conservative does not implement micro like ondemand
+			 * governor, thus we are bound to jiffes/HZ
+			 */
+			min_sampling_rate =
+				MIN_SAMPLING_RATE_RATIO * jiffies_to_usecs(1);
+			/* Bring kernel and HW constraints together */
+			min_sampling_rate = max(min_sampling_rate,
+					MIN_LATENCY_MULTIPLIER * latency);
+			dbs_tuners_ins.sampling_rate =
+				max(min_sampling_rate,
+				    latency * LATENCY_MULTIPLIER);
+
+			dbs_timer_init();
+			cpufreq_register_notifier(
+					&dbs_cpufreq_notifier_block,
+					CPUFREQ_TRANSITION_NOTIFIER);
+		}
+
+		mutex_unlock(&dbs_mutex);
+		freq_table = cpufreq_frequency_get_table(policy->cpu);
+		for (i = 0; (freq_table[i].frequency != CPUFREQ_TABLE_END); i++) {
+			unsigned int freq = freq_table[i].frequency;
+			if (freq == CPUFREQ_ENTRY_INVALID) {
+				continue;
+			}
+			if (freq < min_freq)
+				min_freq = freq;
+			if (freq > max_freq)
+				max_freq = freq;
+		}
+		step_down = min_freq;
+		sleep_max = min_freq;                //Minimum CPU frequency in table
+		awake_min = min_freq;                //Minimum CPU frequency in table
+		register_early_suspend(&lagfree_power_suspend);
+		break;
+
+	case CPUFREQ_GOV_STOP:
+		mutex_lock(&dbs_mutex);
+		this_dbs_info->enable = 0;
+		sysfs_remove_group(&policy->kobj, &dbs_attr_group);
+		dbs_enable--;
+		/*
+		 * Stop the timerschedule work, when this governor
+		 * is used for first time
+		 */
+		if (dbs_enable == 0) {
+			dbs_timer_exit();
+			cpufreq_unregister_notifier(
+					&dbs_cpufreq_notifier_block,
+					CPUFREQ_TRANSITION_NOTIFIER);
+		}
+
+		mutex_unlock(&dbs_mutex);
+		unregister_early_suspend(&lagfree_power_suspend);
+		break;
+
+	case CPUFREQ_GOV_LIMITS:
+		mutex_lock(&dbs_mutex);
+		if (policy->max < this_dbs_info->cur_policy->cur)
+			__cpufreq_driver_target(
+					this_dbs_info->cur_policy,
+					policy->max, CPUFREQ_RELATION_H);
+		else if (policy->min > this_dbs_info->cur_policy->cur)
+			__cpufreq_driver_target(
+					this_dbs_info->cur_policy,
+					policy->min, CPUFREQ_RELATION_L);
+		mutex_unlock(&dbs_mutex);
+		break;
+	}
+	return 0;
+}
+
+#ifndef CONFIG_CPU_FREQ_DEFAULT_GOV_LAGFREE
+static
+#endif
+struct cpufreq_governor cpufreq_gov_lagfree = {
+	.name			= "lagfree",
+	.governor		= cpufreq_governor_dbs,
+	.max_transition_latency	= TRANSITION_LATENCY_LIMIT,
+	.owner			= THIS_MODULE,
+};
+
+static int __init cpufreq_gov_dbs_init(void)
+{
+	return cpufreq_register_governor(&cpufreq_gov_lagfree);
+}
+
+static void __exit cpufreq_gov_dbs_exit(void)
+{
+	/* Make sure that the scheduled work is indeed not running */
+	flush_scheduled_work();
+
+	cpufreq_unregister_governor(&cpufreq_gov_lagfree);
+}
+
+
+MODULE_AUTHOR ("Emilio Lpez <turl@tuxfamily.org>");
+MODULE_DESCRIPTION ("'cpufreq_lagfree' - A dynamic cpufreq governor for "
+		"Low Latency Frequency Transition capable processors "
+		"optimised for use in a battery environment"
+		"Based on conservative by Alexander Clouter");
+MODULE_LICENSE ("GPL");
+
+#ifdef CONFIG_CPU_FREQ_DEFAULT_GOV_LAGFREE
+fs_initcall(cpufreq_gov_dbs_init);
+#else
+module_init(cpufreq_gov_dbs_init);
+#endif
+module_exit(cpufreq_gov_dbs_exit);
diff -urNp Kernel/drivers/cpufreq/cpufreq_lulzactive.c HelloWorld-Renew-v1.0-n7000-jb/drivers/cpufreq/cpufreq_lulzactive.c
--- Kernel/drivers/cpufreq/cpufreq_lulzactive.c	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/drivers/cpufreq/cpufreq_lulzactive.c	2013-04-25 17:38:09.000000000 +0200
@@ -0,0 +1,1063 @@
+/*
+ * drivers/cpufreq/cpufreq_lulzactive.c
+ *
+ * Copyright (C) 2010 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Author: Mike Chan (mike@android.com)
+ * Edited: Tegrak (luciferanna@gmail.com)
+ *
+ * Driver values in /sys/devices/system/cpu/cpufreq/lulzactive
+ * 
+ */
+
+#include <linux/cpu.h>
+#include <linux/cpumask.h>
+#include <linux/cpufreq.h>
+#include <linux/mutex.h>
+#include <linux/sched.h>
+#include <linux/tick.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <linux/kthread.h>
+#include <linux/earlysuspend.h>
+#include <asm/cputime.h>
+#include <linux/suspend.h>
+
+#define LULZACTIVE_VERSION	(2)
+#define LULZACTIVE_AUTHOR	"tegrak"
+
+// if you changed some codes for optimization, just write your name here.
+#define LULZACTIVE_TUNER "gokhanmoral"
+
+static atomic_t active_count = ATOMIC_INIT(0);
+
+struct cpufreq_lulzactive_cpuinfo {
+	struct timer_list cpu_timer;
+	int timer_idlecancel;
+	u64 time_in_idle;
+	u64 idle_exit_time;
+	u64 timer_run_time;
+	int idling;
+	u64 freq_change_time;
+	u64 freq_change_time_in_idle;
+	struct cpufreq_policy *policy;
+	struct cpufreq_frequency_table *freq_table;
+	struct cpufreq_frequency_table lulzfreq_table[32];
+	unsigned int lulzfreq_table_size;
+	unsigned int target_freq;
+	int governor_enabled;
+};
+
+static DEFINE_PER_CPU(struct cpufreq_lulzactive_cpuinfo, cpuinfo);
+
+/* Workqueues handle frequency scaling */
+static struct task_struct *up_task;
+static struct workqueue_struct *down_wq;
+static struct work_struct freq_scale_down_work;
+static cpumask_t up_cpumask;
+static spinlock_t up_cpumask_lock;
+static cpumask_t down_cpumask;
+static spinlock_t down_cpumask_lock;
+static struct mutex set_speed_lock;
+
+/* Hi speed to bump to from lo speed when load burst (default max) */
+static u64 hispeed_freq;
+
+/*
+ * The minimum amount of time to spend at a frequency before we can step up.
+ */
+#define DEFAULT_UP_SAMPLE_TIME 20 * USEC_PER_MSEC
+static unsigned long up_sample_time;
+
+/*
+ * The minimum amount of time to spend at a frequency before we can step down.
+ */
+#define DEFAULT_DOWN_SAMPLE_TIME 40 * USEC_PER_MSEC
+static unsigned long down_sample_time;
+
+/*
+ * CPU freq will be increased if measured load > inc_cpu_load;
+ */
+#define DEFAULT_INC_CPU_LOAD 80
+static unsigned long inc_cpu_load;
+
+/*
+ * CPU freq will be decreased if measured load < dec_cpu_load;
+ * not implemented yet.
+ */
+#define DEFAULT_DEC_CPU_LOAD 40
+static unsigned long dec_cpu_load;
+
+/*
+ * Increasing frequency table index
+ * zero disables and causes to always jump straight to max frequency.
+ */
+#define DEFAULT_PUMP_UP_STEP 0
+static unsigned long pump_up_step;
+
+/*
+ * The sample rate of the timer used to increase frequency
+ */
+#define DEFAULT_TIMER_RATE 20 * USEC_PER_MSEC
+static unsigned long timer_rate;
+
+/*
+ * Decreasing frequency table index
+ * zero disables and will calculate frequency according to load heuristic.
+ */
+#define DEFAULT_PUMP_DOWN_STEP 0
+static unsigned long pump_down_step;
+
+/*
+ * Use minimum frequency while suspended.
+ */
+static unsigned int early_suspended;
+
+#define SCREEN_OFF_LOWEST_STEP 		(0xffffffff)
+#define DEFAULT_SCREEN_OFF_MIN_STEP	(SCREEN_OFF_LOWEST_STEP)
+static unsigned long screen_off_min_step;
+
+static int cpufreq_governor_lulzactive(struct cpufreq_policy *policy,
+		unsigned int event);
+
+#ifndef CONFIG_CPU_FREQ_DEFAULT_GOV_LULZACTIVE
+static
+#endif
+struct cpufreq_governor cpufreq_gov_lulzactive = {
+	.name = "lulzactive",
+	.governor = cpufreq_governor_lulzactive,
+	.max_transition_latency = 10000000,
+	.owner = THIS_MODULE,
+};
+
+static unsigned int get_lulzfreq_table_size(struct cpufreq_lulzactive_cpuinfo *pcpu) {
+	unsigned int size = 0, i;
+	for (i = 0; (pcpu->freq_table[i].frequency != CPUFREQ_TABLE_END); i++) {
+		unsigned int freq = pcpu->freq_table[i].frequency;
+		if (freq == CPUFREQ_ENTRY_INVALID) continue;
+		pcpu->lulzfreq_table[size].index = i; //in case we need it later -gm
+		pcpu->lulzfreq_table[size].frequency = freq;
+		size++;
+	}
+	pcpu->lulzfreq_table[size].index = 0;
+	pcpu->lulzfreq_table[size].frequency = CPUFREQ_TABLE_END;
+	return size;
+}
+
+static inline void fix_screen_off_min_step(struct cpufreq_lulzactive_cpuinfo *pcpu) {
+	if (pcpu->lulzfreq_table_size <= 0) {
+		screen_off_min_step = 0;
+		return;
+	}
+	
+	if (DEFAULT_SCREEN_OFF_MIN_STEP == screen_off_min_step) 
+		for(screen_off_min_step=0;
+		pcpu->lulzfreq_table[screen_off_min_step].frequency != 500000;
+		screen_off_min_step++);
+	
+	if (screen_off_min_step >= pcpu->lulzfreq_table_size)
+		for(screen_off_min_step=0;
+		pcpu->lulzfreq_table[screen_off_min_step].frequency != 500000;
+		screen_off_min_step++);
+}
+
+static inline unsigned int adjust_screen_off_freq(
+	struct cpufreq_lulzactive_cpuinfo *pcpu, unsigned int freq) {
+	
+	if (early_suspended && freq > pcpu->lulzfreq_table[screen_off_min_step].frequency) {		
+		freq = pcpu->lulzfreq_table[screen_off_min_step].frequency;
+		pcpu->target_freq = pcpu->policy->cur;
+		
+		if (freq > pcpu->policy->max)
+			freq = pcpu->policy->max;
+		if (freq < pcpu->policy->min)
+			freq = pcpu->policy->min;
+	}
+	
+	return freq;
+}
+
+static void cpufreq_lulzactive_timer(unsigned long data)
+{
+	unsigned int delta_idle;
+	unsigned int delta_time;
+	int cpu_load;
+	int load_since_change;
+	u64 time_in_idle;
+	u64 idle_exit_time;
+	struct cpufreq_lulzactive_cpuinfo *pcpu =
+		&per_cpu(cpuinfo, data);
+	u64 now_idle;
+	unsigned int new_freq;
+	unsigned int index;
+	unsigned long flags;
+	int ret;
+
+	smp_rmb();
+
+	if (!pcpu->governor_enabled)
+		goto exit;
+
+    // do not let inc_cpu_load be less than dec_cpu_load.
+    if (dec_cpu_load > inc_cpu_load) {
+        dec_cpu_load = dec_cpu_load - (dec_cpu_load - inc_cpu_load) - 1;
+    }
+
+	/*
+	 * Once pcpu->timer_run_time is updated to >= pcpu->idle_exit_time,
+	 * this lets idle exit know the current idle time sample has
+	 * been processed, and idle exit can generate a new sample and
+	 * re-arm the timer.  This prevents a concurrent idle
+	 * exit on that CPU from writing a new set of info at the same time
+	 * the timer function runs (the timer function can't use that info
+	 * until more time passes).
+	 */
+	time_in_idle = pcpu->time_in_idle;
+	idle_exit_time = pcpu->idle_exit_time;
+	now_idle = get_cpu_idle_time_us(data, &pcpu->timer_run_time);
+	smp_wmb();
+
+	/* If we raced with cancelling a timer, skip. */
+	if (!idle_exit_time)
+		goto exit;
+
+	delta_idle = (unsigned int) cputime64_sub(now_idle, time_in_idle);
+	delta_time = (unsigned int) cputime64_sub(pcpu->timer_run_time,
+						  idle_exit_time);
+
+	/*
+	 * If timer ran less than 1ms after short-term sample started, retry.
+	 */
+	if (delta_time < 1000)
+		goto rearm;
+
+	if (delta_idle > delta_time)
+		cpu_load = 0;
+	else
+		cpu_load = 100 * (delta_time - delta_idle) / delta_time;
+
+	delta_idle = (unsigned int) cputime64_sub(now_idle,
+						pcpu->freq_change_time_in_idle);
+	delta_time = (unsigned int) cputime64_sub(pcpu->timer_run_time,
+						  pcpu->freq_change_time);
+
+	if ((delta_time == 0) || (delta_idle > delta_time))
+		load_since_change = 0;
+	else
+		load_since_change =
+			100 * (delta_time - delta_idle) / delta_time;
+
+	/*
+	 * Choose greater of short-term load (since last idle timer
+	 * started or timer function re-armed itself) or long-term load
+	 * (since last frequency change).
+	 */
+	if (load_since_change > cpu_load)
+		cpu_load = load_since_change;
+	
+	/*
+	 * START lulzactive algorithm section
+	 */
+	if (cpu_load >= inc_cpu_load) {
+		if (pump_up_step && pcpu->policy->cur < pcpu->policy->max) {
+			ret = cpufreq_frequency_table_target(
+				pcpu->policy, pcpu->lulzfreq_table,
+				pcpu->policy->cur, CPUFREQ_RELATION_H,
+				&index);
+			if (ret < 0) {
+				goto rearm;
+			}
+			
+			// apply pump_up_step by tegrak
+			index -= pump_up_step;
+			if (index < 0)
+				index = 0;
+			
+			new_freq = pcpu->lulzfreq_table[index].frequency;
+		}
+		else {
+			if (pcpu->policy->cur == pcpu->policy->min)
+				new_freq = hispeed_freq;
+			else
+				new_freq = pcpu->policy->max * cpu_load / 100;
+		}
+	}
+	else {		
+		if (pump_down_step) {
+			ret = cpufreq_frequency_table_target(
+				pcpu->policy, pcpu->lulzfreq_table,
+				pcpu->policy->cur, CPUFREQ_RELATION_H,
+				&index);
+			if (ret < 0) {
+				goto rearm;
+			}
+			
+			// apply pump_down_step by tegrak
+			index += pump_down_step;
+			if (index >= pcpu->lulzfreq_table_size) {
+				index = pcpu->lulzfreq_table_size - 1;
+			}
+			
+			new_freq = (pcpu->policy->cur > pcpu->policy->min) ? 
+				(pcpu->lulzfreq_table[index].frequency) :
+				(pcpu->policy->min);
+		}
+		else {
+			new_freq = pcpu->policy->cur * cpu_load / 100;
+		}		
+	}
+	if (cpufreq_frequency_table_target(pcpu->policy, pcpu->lulzfreq_table,
+					   new_freq, CPUFREQ_RELATION_H,
+					   &index)) {
+		pr_warn_once("timer %d: cpufreq_frequency_table_target error\n",
+			     (int) data);
+		goto rearm;
+	}
+	new_freq = pcpu->lulzfreq_table[index].frequency;
+
+	// adjust freq when screen off
+	new_freq = adjust_screen_off_freq(pcpu, new_freq);
+	
+	if (pcpu->target_freq == new_freq)
+		goto rearm_if_notmax;
+
+	/*
+	 * Do not scale down unless we have been at this frequency for the
+	 * minimum sample time.
+	 */
+	if (new_freq < pcpu->target_freq) {
+		if (cputime64_sub(pcpu->timer_run_time, pcpu->freq_change_time)
+		    < down_sample_time)
+			goto rearm;
+	}
+	else {
+		if (cputime64_sub(pcpu->timer_run_time, pcpu->freq_change_time) <
+		    up_sample_time) {
+			/* don't reset timer */
+			goto rearm;
+		}
+	}
+
+	if (new_freq < pcpu->target_freq) {
+		pcpu->target_freq = new_freq;
+		spin_lock_irqsave(&down_cpumask_lock, flags);
+		cpumask_set_cpu(data, &down_cpumask);
+		spin_unlock_irqrestore(&down_cpumask_lock, flags);
+		queue_work(down_wq, &freq_scale_down_work);
+	} else {
+		pcpu->target_freq = new_freq;
+		spin_lock_irqsave(&up_cpumask_lock, flags);
+		cpumask_set_cpu(data, &up_cpumask);
+		spin_unlock_irqrestore(&up_cpumask_lock, flags);
+		wake_up_process(up_task);
+	}
+
+rearm_if_notmax:
+	/*
+	 * Already set max speed and don't see a need to change that,
+	 * wait until next idle to re-evaluate, don't need timer.
+	 */
+	if (pcpu->target_freq == pcpu->policy->max)
+		goto exit;
+
+rearm:
+	if (!timer_pending(&pcpu->cpu_timer)) {
+		/*
+		 * If already at min: if that CPU is idle, don't set timer.
+		 * Else cancel the timer if that CPU goes idle.  We don't
+		 * need to re-evaluate speed until the next idle exit.
+		 */
+		if (pcpu->target_freq == pcpu->policy->min) {
+			smp_rmb();
+
+			if (pcpu->idling)
+				goto exit;
+
+			pcpu->timer_idlecancel = 1;
+		}
+
+		pcpu->time_in_idle = get_cpu_idle_time_us(
+			data, &pcpu->idle_exit_time);
+		mod_timer(&pcpu->cpu_timer,
+			  jiffies + usecs_to_jiffies(timer_rate));
+	}
+
+exit:
+	return;
+}
+
+static void cpufreq_lulzactive_idle_start(void)
+{
+	struct cpufreq_lulzactive_cpuinfo *pcpu =
+		&per_cpu(cpuinfo, smp_processor_id());
+	int pending;
+
+	if (!pcpu->governor_enabled)
+		return;
+
+	pcpu->idling = 1;
+	smp_wmb();
+	pending = timer_pending(&pcpu->cpu_timer);
+
+	if (pcpu->target_freq != pcpu->policy->min) {
+#ifdef CONFIG_SMP
+		/*
+		 * Entering idle while not at lowest speed.  On some
+		 * platforms this can hold the other CPU(s) at that speed
+		 * even though the CPU is idle. Set a timer to re-evaluate
+		 * speed so this idle CPU doesn't hold the other CPUs above
+		 * min indefinitely.  This should probably be a quirk of
+		 * the CPUFreq driver.
+		 */
+		if (!pending) {
+			pcpu->time_in_idle = get_cpu_idle_time_us(
+				smp_processor_id(), &pcpu->idle_exit_time);
+			pcpu->timer_idlecancel = 0;
+			mod_timer(&pcpu->cpu_timer,
+				  jiffies + usecs_to_jiffies(timer_rate));
+		}
+#endif
+	} else {
+		/*
+		 * If at min speed and entering idle after load has
+		 * already been evaluated, and a timer has been set just in
+		 * case the CPU suddenly goes busy, cancel that timer.  The
+		 * CPU didn't go busy; we'll recheck things upon idle exit.
+		 */
+		if (pending && pcpu->timer_idlecancel) {
+			del_timer(&pcpu->cpu_timer);
+			/*
+			 * Ensure last timer run time is after current idle
+			 * sample start time, so next idle exit will always
+			 * start a new idle sampling period.
+			 */
+			pcpu->idle_exit_time = 0;
+			pcpu->timer_idlecancel = 0;
+		}
+	}
+
+}
+
+static void cpufreq_lulzactive_idle_end(void)
+{
+	struct cpufreq_lulzactive_cpuinfo *pcpu =
+		&per_cpu(cpuinfo, smp_processor_id());
+
+	pcpu->idling = 0;
+	smp_wmb();
+
+	/*
+	 * Arm the timer for 1-2 ticks later if not already, and if the timer
+	 * function has already processed the previous load sampling
+	 * interval.  (If the timer is not pending but has not processed
+	 * the previous interval, it is probably racing with us on another
+	 * CPU.  Let it compute load based on the previous sample and then
+	 * re-arm the timer for another interval when it's done, rather
+	 * than updating the interval start time to be "now", which doesn't
+	 * give the timer function enough time to make a decision on this
+	 * run.)
+	 */
+	if (timer_pending(&pcpu->cpu_timer) == 0 &&
+	    pcpu->timer_run_time >= pcpu->idle_exit_time &&
+	    pcpu->governor_enabled) {
+		pcpu->time_in_idle =
+			get_cpu_idle_time_us(smp_processor_id(),
+					     &pcpu->idle_exit_time);
+		pcpu->timer_idlecancel = 0;
+		mod_timer(&pcpu->cpu_timer,
+			  jiffies + usecs_to_jiffies(timer_rate));
+	}
+
+}
+
+static int cpufreq_lulzactive_up_task(void *data)
+{
+	unsigned int cpu;
+	cpumask_t tmp_mask;
+	unsigned long flags;
+	struct cpufreq_lulzactive_cpuinfo *pcpu;
+
+
+	while (1) {
+		set_current_state(TASK_INTERRUPTIBLE);
+		spin_lock_irqsave(&up_cpumask_lock, flags);
+
+		if (cpumask_empty(&up_cpumask)) {
+			spin_unlock_irqrestore(&up_cpumask_lock, flags);
+			schedule();
+
+			if (kthread_should_stop())
+				break;
+
+			spin_lock_irqsave(&up_cpumask_lock, flags);
+		}
+
+		set_current_state(TASK_RUNNING);
+		tmp_mask = up_cpumask;
+		cpumask_clear(&up_cpumask);
+		spin_unlock_irqrestore(&up_cpumask_lock, flags);
+
+		for_each_cpu(cpu, &tmp_mask) {
+			unsigned int j;
+			unsigned int max_freq = 0;
+
+			pcpu = &per_cpu(cpuinfo, cpu);
+			smp_rmb();
+
+			if (!pcpu->governor_enabled)
+				continue;
+
+			mutex_lock(&set_speed_lock);
+
+			for_each_cpu(j, pcpu->policy->cpus) {
+				struct cpufreq_lulzactive_cpuinfo *pjcpu =
+					&per_cpu(cpuinfo, j);
+
+				if (pjcpu->target_freq > max_freq)
+					max_freq = pjcpu->target_freq;
+			}
+
+			if (max_freq != pcpu->policy->cur)
+				__cpufreq_driver_target(pcpu->policy,
+							max_freq,
+							CPUFREQ_RELATION_H);
+			mutex_unlock(&set_speed_lock);
+
+			pcpu->freq_change_time_in_idle =
+				get_cpu_idle_time_us(cpu,
+						     &pcpu->freq_change_time);
+		}
+	}
+
+	return 0;
+}
+
+static void cpufreq_lulzactive_freq_down(struct work_struct *work)
+{
+	unsigned int cpu;
+	cpumask_t tmp_mask;
+	unsigned long flags;
+	struct cpufreq_lulzactive_cpuinfo *pcpu;
+
+	spin_lock_irqsave(&down_cpumask_lock, flags);
+	tmp_mask = down_cpumask;
+	cpumask_clear(&down_cpumask);
+	spin_unlock_irqrestore(&down_cpumask_lock, flags);
+
+	for_each_cpu(cpu, &tmp_mask) {
+		unsigned int j;
+		unsigned int max_freq = 0;
+
+		pcpu = &per_cpu(cpuinfo, cpu);
+		smp_rmb();
+
+		if (!pcpu->governor_enabled)
+			continue;
+
+		mutex_lock(&set_speed_lock);
+
+		for_each_cpu(j, pcpu->policy->cpus) {
+			struct cpufreq_lulzactive_cpuinfo *pjcpu =
+				&per_cpu(cpuinfo, j);
+
+			if (pjcpu->target_freq > max_freq)
+				max_freq = pjcpu->target_freq;
+		}
+
+		if (max_freq != pcpu->policy->cur)
+			__cpufreq_driver_target(pcpu->policy, max_freq,
+						CPUFREQ_RELATION_H);
+
+		mutex_unlock(&set_speed_lock);
+		pcpu->freq_change_time_in_idle =
+			get_cpu_idle_time_us(cpu,
+					     &pcpu->freq_change_time);
+	}
+}
+
+static ssize_t show_hispeed_freq(struct kobject *kobj,
+				 struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%llu\n", hispeed_freq);
+}
+
+static ssize_t store_hispeed_freq(struct kobject *kobj,
+				  struct attribute *attr, const char *buf,
+				  size_t count)
+{
+	int ret;
+	u64 val;
+
+	ret = strict_strtoull(buf, 0, &val);
+	if (ret < 0)
+		return ret;
+	hispeed_freq = val;
+	return count;
+}
+
+static struct global_attr hispeed_freq_attr = __ATTR(hispeed_freq, 0644,
+		show_hispeed_freq, store_hispeed_freq);
+
+// inc_cpu_load
+static ssize_t show_inc_cpu_load(struct kobject *kobj,
+				     struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%lu\n", inc_cpu_load);
+}
+
+static ssize_t store_inc_cpu_load(struct kobject *kobj,
+			struct attribute *attr, const char *buf, size_t count)
+{
+	if(strict_strtoul(buf, 0, &inc_cpu_load)==-EINVAL) return -EINVAL;
+	
+	if (inc_cpu_load > 100) {
+		inc_cpu_load = 100;
+	}
+	else if (inc_cpu_load < 10) {
+		inc_cpu_load = 10;
+	}
+	return count;
+}
+
+static struct global_attr inc_cpu_load_attr = __ATTR(inc_cpu_load, 0666,
+		show_inc_cpu_load, store_inc_cpu_load);
+
+// down_sample_time
+static ssize_t show_down_sample_time(struct kobject *kobj,
+				struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%lu\n", down_sample_time);
+}
+
+static ssize_t store_down_sample_time(struct kobject *kobj,
+			struct attribute *attr, const char *buf, size_t count)
+{
+	if(strict_strtoul(buf, 0, &down_sample_time)==-EINVAL) return -EINVAL;
+	return count;
+}
+
+static struct global_attr down_sample_time_attr = __ATTR(down_sample_time, 0666,
+		show_down_sample_time, store_down_sample_time);
+
+// up_sample_time
+static ssize_t show_up_sample_time(struct kobject *kobj,
+				struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%lu\n", up_sample_time);
+}
+
+static ssize_t store_up_sample_time(struct kobject *kobj,
+			struct attribute *attr, const char *buf, size_t count)
+{
+	if(strict_strtoul(buf, 0, &up_sample_time)==-EINVAL) return -EINVAL;
+	return count;
+}
+
+static struct global_attr up_sample_time_attr = __ATTR(up_sample_time, 0666,
+		show_up_sample_time, store_up_sample_time);
+
+// debug_mode
+static ssize_t show_debug_mode(struct kobject *kobj,
+				     struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "0\n");
+}
+
+static ssize_t store_debug_mode(struct kobject *kobj,
+			struct attribute *attr, const char *buf, size_t count)
+{
+	return count;
+}
+
+static struct global_attr debug_mode_attr = __ATTR(debug_mode, 0666,
+		show_debug_mode, store_debug_mode);
+
+// pump_up_step
+static ssize_t show_pump_up_step(struct kobject *kobj,
+				     struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%lu\n", pump_up_step);
+}
+
+static ssize_t store_pump_up_step(struct kobject *kobj,
+			struct attribute *attr, const char *buf, size_t count)
+{
+	if(strict_strtoul(buf, 0, &pump_up_step)==-EINVAL) return -EINVAL;
+	return count;
+}
+
+static struct global_attr pump_up_step_attr = __ATTR(pump_up_step, 0666,
+		show_pump_up_step, store_pump_up_step);
+
+// pump_down_step
+static ssize_t show_pump_down_step(struct kobject *kobj,
+				     struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%lu\n", pump_down_step);
+}
+
+static ssize_t store_pump_down_step(struct kobject *kobj,
+			struct attribute *attr, const char *buf, size_t count)
+{
+	struct cpufreq_lulzactive_cpuinfo *pcpu;
+	
+	if(strict_strtoul(buf, 0, &pump_down_step)==-EINVAL) return -EINVAL;
+	
+	pcpu = &per_cpu(cpuinfo, 0);
+	// fix out of bound
+	if (pcpu->lulzfreq_table_size <= pump_down_step) {
+		pump_down_step = pcpu->lulzfreq_table_size - 1;
+	}
+	return count;
+}
+
+static struct global_attr pump_down_step_attr = __ATTR(pump_down_step, 0666,
+		show_pump_down_step, store_pump_down_step);
+
+// screen_off_min_step
+static ssize_t show_screen_off_min_step(struct kobject *kobj,
+				     struct attribute *attr, char *buf)
+{
+	struct cpufreq_lulzactive_cpuinfo *pcpu;
+	
+	pcpu = &per_cpu(cpuinfo, 0);
+	fix_screen_off_min_step(pcpu);
+	
+	return sprintf(buf, "%lu\n", screen_off_min_step);
+}
+
+static ssize_t store_screen_off_min_step(struct kobject *kobj,
+			struct attribute *attr, const char *buf, size_t count)
+{
+	struct cpufreq_lulzactive_cpuinfo *pcpu;
+	
+	if(strict_strtoul(buf, 0, &screen_off_min_step)==-EINVAL) return -EINVAL;
+	
+	pcpu = &per_cpu(cpuinfo, 0);
+	fix_screen_off_min_step(pcpu);
+	
+	return count;
+}
+
+static struct global_attr screen_off_min_step_attr = __ATTR(screen_off_min_step, 0666,
+		show_screen_off_min_step, store_screen_off_min_step);
+
+// author
+static ssize_t show_author(struct kobject *kobj,
+				     struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%s\n", LULZACTIVE_AUTHOR);
+}
+
+static struct global_attr author_attr = __ATTR(author, 0444,
+		show_author, NULL);
+
+// tuner
+static ssize_t show_tuner(struct kobject *kobj,
+				     struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%s\n", LULZACTIVE_TUNER);
+}
+
+static struct global_attr tuner_attr = __ATTR(tuner, 0444,
+		show_tuner, NULL);
+
+// version
+static ssize_t show_version(struct kobject *kobj,
+				     struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", LULZACTIVE_VERSION);
+}
+
+static struct global_attr version_attr = __ATTR(version, 0444,
+		show_version, NULL);
+
+// freq_table
+static ssize_t show_freq_table(struct kobject *kobj,
+				     struct attribute *attr, char *buf)
+{
+	struct cpufreq_lulzactive_cpuinfo *pcpu;
+	char temp[64];
+	int i;
+	
+	pcpu = &per_cpu(cpuinfo, 0);
+	
+	for (i = 0; i < pcpu->lulzfreq_table_size; i++) {
+		sprintf(temp, "%u\n", pcpu->lulzfreq_table[i].frequency);
+		strcat(buf, temp);
+	}
+	
+	return strlen(buf);
+}
+
+static struct global_attr freq_table_attr = __ATTR(freq_table, 0444,
+		show_freq_table, NULL);
+
+static struct attribute *lulzactive_attributes[] = {
+	&hispeed_freq_attr.attr,
+	&inc_cpu_load_attr.attr,
+	&up_sample_time_attr.attr,
+	&down_sample_time_attr.attr,
+	&pump_up_step_attr.attr,
+	&pump_down_step_attr.attr,
+	&screen_off_min_step_attr.attr,
+	&debug_mode_attr.attr,
+	&author_attr.attr,
+	&tuner_attr.attr,
+	&version_attr.attr,
+	&freq_table_attr.attr,
+	NULL,
+};
+
+void start_lulzactive(void);
+void stop_lulzactive(void);
+		
+static struct attribute_group lulzactive_attr_group = {
+	.attrs = lulzactive_attributes,
+	.name = "lulzactive",
+};
+
+static int cpufreq_governor_lulzactive(struct cpufreq_policy *policy,
+		unsigned int event)
+{
+	int rc;
+	unsigned int j;
+	struct cpufreq_lulzactive_cpuinfo *pcpu;
+	struct cpufreq_frequency_table *freq_table;
+
+	switch (event) {
+	case CPUFREQ_GOV_START:
+		if (!cpu_online(policy->cpu))
+			return -EINVAL;
+
+		freq_table =
+			cpufreq_frequency_get_table(policy->cpu);
+
+		for_each_cpu(j, policy->cpus) {
+			pcpu = &per_cpu(cpuinfo, j);
+			pcpu->policy = policy;
+			pcpu->target_freq = policy->cur;
+			pcpu->freq_table = freq_table;
+			pcpu->freq_change_time_in_idle =
+				get_cpu_idle_time_us(j,
+						     &pcpu->freq_change_time);
+			pcpu->governor_enabled = 1;
+			smp_wmb();
+			pcpu->lulzfreq_table_size = get_lulzfreq_table_size(pcpu);
+
+			// fix invalid screen_off_min_step
+			fix_screen_off_min_step(pcpu);
+		}
+
+		if (!hispeed_freq)
+			hispeed_freq = policy->max;
+
+		/*
+		 * Do not register the idle hook and create sysfs
+		 * entries if we have already done so.
+		 */
+		if (atomic_inc_return(&active_count) > 1)
+			return 0;
+		start_lulzactive();
+
+		rc = sysfs_create_group(cpufreq_global_kobject,
+				&lulzactive_attr_group);
+		if (rc)
+			return rc;
+
+		break;
+
+	case CPUFREQ_GOV_STOP:
+		for_each_cpu(j, policy->cpus) {
+			pcpu = &per_cpu(cpuinfo, j);
+			pcpu->governor_enabled = 0;
+			smp_wmb();
+			del_timer_sync(&pcpu->cpu_timer);
+
+			/*
+			 * Reset idle exit time since we may cancel the timer
+			 * before it can run after the last idle exit time,
+			 * to avoid tripping the check in idle exit for a timer
+			 * that is trying to run.
+			 */
+			pcpu->idle_exit_time = 0;
+		}
+
+		flush_work(&freq_scale_down_work);
+		if (atomic_dec_return(&active_count) > 0)
+			return 0;
+
+		sysfs_remove_group(cpufreq_global_kobject,
+				&lulzactive_attr_group);
+		stop_lulzactive();
+		break;
+
+	case CPUFREQ_GOV_LIMITS:
+		if (policy->max < policy->cur)
+			__cpufreq_driver_target(policy,
+					policy->max, CPUFREQ_RELATION_H);
+		else if (policy->min > policy->cur)
+			__cpufreq_driver_target(policy,
+					policy->min, CPUFREQ_RELATION_L);
+		break;
+	}
+	return 0;
+}
+
+static int cpufreq_lulzactive_idle_notifier(struct notifier_block *nb,
+					     unsigned long val,
+					     void *data)
+{
+	switch (val) {
+	case IDLE_START:
+		cpufreq_lulzactive_idle_start();
+		break;
+	case IDLE_END:
+		cpufreq_lulzactive_idle_end();
+		break;
+	}
+
+	return 0;
+}
+
+static struct notifier_block cpufreq_lulzactive_idle_nb = {
+	.notifier_call = cpufreq_lulzactive_idle_notifier,
+};
+
+static void lulzactive_early_suspend(struct early_suspend *handler) {
+	early_suspended = 1;
+}
+
+static void lulzactive_late_resume(struct early_suspend *handler) {
+	early_suspended = 0;
+}
+
+static struct early_suspend lulzactive_power_suspend = {
+	.suspend = lulzactive_early_suspend,
+	.resume = lulzactive_late_resume,
+	.level = EARLY_SUSPEND_LEVEL_DISABLE_FB + 1,
+};
+
+void start_lulzactive(void)
+{
+	//it is more appropriate to start the up_task thread after starting the governor -gm
+	unsigned int i, index500, index800;
+	struct cpufreq_lulzactive_cpuinfo *pcpu;
+	struct sched_param param = { .sched_priority = MAX_RT_PRIO-1 };
+
+	if( pump_up_step == 0 )
+	{
+		pcpu = &per_cpu(cpuinfo, 0);
+		cpufreq_frequency_table_target(
+				pcpu->policy, pcpu->lulzfreq_table,
+				500000, CPUFREQ_RELATION_H,
+				&index500);
+		cpufreq_frequency_table_target(
+				pcpu->policy, pcpu->lulzfreq_table,
+				800000, CPUFREQ_RELATION_H,
+				&index800);
+		for(i=index800;i<index500;i++)
+		{
+		  if(pcpu->lulzfreq_table[i].frequency==CPUFREQ_ENTRY_INVALID) continue;
+		  pump_up_step++;
+		}
+	}
+	if( pump_down_step == 0 )
+	{
+		pump_down_step = pump_up_step;
+	}	
+
+	up_task = kthread_create(cpufreq_lulzactive_up_task, NULL,
+				 "klulzactiveup");
+
+	sched_setscheduler_nocheck(up_task, SCHED_FIFO, &param);
+	get_task_struct(up_task);
+
+	idle_notifier_register(&cpufreq_lulzactive_idle_nb);
+	register_early_suspend(&lulzactive_power_suspend);
+}
+
+void stop_lulzactive(void)
+{
+	//cleanup the thread after stopping the governor -gm
+	kthread_stop(up_task);
+	put_task_struct(up_task);
+
+	idle_notifier_unregister(&cpufreq_lulzactive_idle_nb);
+	unregister_early_suspend(&lulzactive_power_suspend);
+	pump_up_step = DEFAULT_PUMP_UP_STEP;
+	pump_down_step = DEFAULT_PUMP_DOWN_STEP;
+}
+
+static int __init cpufreq_lulzactive_init(void)
+{
+	unsigned int i;
+	struct cpufreq_lulzactive_cpuinfo *pcpu;
+	up_sample_time = DEFAULT_UP_SAMPLE_TIME;
+	down_sample_time = DEFAULT_DOWN_SAMPLE_TIME;
+	inc_cpu_load = DEFAULT_INC_CPU_LOAD;
+	dec_cpu_load = DEFAULT_DEC_CPU_LOAD;
+	pump_up_step = DEFAULT_PUMP_UP_STEP;
+	pump_down_step = DEFAULT_PUMP_DOWN_STEP;
+	early_suspended = 0;
+	screen_off_min_step = DEFAULT_SCREEN_OFF_MIN_STEP;
+	timer_rate = DEFAULT_TIMER_RATE;
+
+
+	/* Initalize per-cpu timers */
+	for_each_possible_cpu(i) {
+		pcpu = &per_cpu(cpuinfo, i);
+		init_timer(&pcpu->cpu_timer);
+		pcpu->cpu_timer.function = cpufreq_lulzactive_timer;
+		pcpu->cpu_timer.data = i;
+	}
+
+	/* No rescuer thread, bind to CPU queuing the work for possibly
+	   warm cache (probably doesn't matter much). */
+	down_wq = alloc_workqueue("knteractive_down", 0, 1);
+
+	if (!down_wq)
+		goto err_freeuptask;
+
+	INIT_WORK(&freq_scale_down_work,
+		  cpufreq_lulzactive_freq_down);
+
+	spin_lock_init(&up_cpumask_lock);
+	spin_lock_init(&down_cpumask_lock);
+	mutex_init(&set_speed_lock);
+
+	return cpufreq_register_governor(&cpufreq_gov_lulzactive);
+
+err_freeuptask:
+	put_task_struct(up_task);
+	return -ENOMEM;
+}
+
+#ifdef CONFIG_CPU_FREQ_DEFAULT_GOV_LULZACTIVE
+fs_initcall(cpufreq_lulzactive_init);
+#else
+module_init(cpufreq_lulzactive_init);
+#endif
+
+static void __exit cpufreq_lulzactive_exit(void)
+{
+	cpufreq_unregister_governor(&cpufreq_gov_lulzactive);
+	kthread_stop(up_task);
+	put_task_struct(up_task);
+	destroy_workqueue(down_wq);
+}
+
+module_exit(cpufreq_lulzactive_exit);
+
+MODULE_AUTHOR("Tegrak <luciferanna@gmail.com>");
+MODULE_DESCRIPTION("'lulzactive' - improved interactive governor inspired by smartass");
+MODULE_LICENSE("GPL");
diff -urNp Kernel/drivers/cpufreq/cpufreq_ondemand.c HelloWorld-Renew-v1.0-n7000-jb/drivers/cpufreq/cpufreq_ondemand.c
--- Kernel/drivers/cpufreq/cpufreq_ondemand.c	2013-02-20 13:36:19.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/drivers/cpufreq/cpufreq_ondemand.c	2013-04-29 16:41:35.142587461 +0200
@@ -42,7 +42,7 @@
 #define MICRO_FREQUENCY_UP_THRESHOLD		(95)
 #endif
 
-#define MICRO_FREQUENCY_MIN_SAMPLE_RATE		(10000)
+#define MICRO_FREQUENCY_MIN_SAMPLE_RATE		(50000) //(10000)
 #define MIN_FREQUENCY_UP_THRESHOLD		(11)
 #define MAX_FREQUENCY_UP_THRESHOLD		(100)
 
@@ -139,7 +139,7 @@ static struct dbs_tuners {
 	.down_differential = DEF_FREQUENCY_DOWN_DIFFERENTIAL,
 	.ignore_nice = 0,
 	.powersave_bias = 0,
-	.freq_step = 100,
+	.freq_step = 50, //100,
 };
 
 static inline cputime64_t get_cpu_idle_time_jiffy(unsigned int cpu,
diff -urNp Kernel/drivers/cpufreq/cpufreq_smartass2.c HelloWorld-Renew-v1.0-n7000-jb/drivers/cpufreq/cpufreq_smartass2.c
--- Kernel/drivers/cpufreq/cpufreq_smartass2.c	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/drivers/cpufreq/cpufreq_smartass2.c	2013-04-25 17:38:09.000000000 +0200
@@ -0,0 +1,879 @@
+/*
+ * drivers/cpufreq/cpufreq_smartass2.c
+ *
+ * Copyright (C) 2010 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Author: Erasmux
+ *
+ * Based on the interactive governor By Mike Chan (mike@android.com)
+ * which was adaptated to 2.6.29 kernel by Nadlabak (pavel@doshaska.net)
+ *
+ * SMP support based on mod by faux123
+ *
+ * For a general overview of smartassV2 see the relavent part in
+ * Documentation/cpu-freq/governors.txt
+ *
+ */
+
+#include <linux/cpu.h>
+#include <linux/cpumask.h>
+#include <linux/cpufreq.h>
+#include <linux/sched.h>
+#include <linux/tick.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <linux/moduleparam.h>
+#include <asm/cputime.h>
+#include <linux/earlysuspend.h>
+
+
+/******************** Tunable parameters: ********************/
+
+/*
+ * The "ideal" frequency to use when awake. The governor will ramp up faster
+ * towards the ideal frequency and slower after it has passed it. Similarly,
+ * lowering the frequency towards the ideal frequency is faster than below it.
+ */
+#define DEFAULT_AWAKE_IDEAL_FREQ 800000
+static unsigned int awake_ideal_freq;
+
+/*
+ * The "ideal" frequency to use when suspended.
+ * When set to 0, the governor will not track the suspended state (meaning
+ * that practically when sleep_ideal_freq==0 the awake_ideal_freq is used
+ * also when suspended).
+ */
+#define DEFAULT_SLEEP_IDEAL_FREQ 200000
+static unsigned int sleep_ideal_freq;
+
+/*
+ * Freqeuncy delta when ramping up above the ideal freqeuncy.
+ * Zero disables and causes to always jump straight to max frequency.
+ * When below the ideal freqeuncy we always ramp up to the ideal freq.
+ */
+#define DEFAULT_RAMP_UP_STEP 200000
+static unsigned int ramp_up_step;
+
+/*
+ * Freqeuncy delta when ramping down below the ideal freqeuncy.
+ * Zero disables and will calculate ramp down according to load heuristic.
+ * When above the ideal freqeuncy we always ramp down to the ideal freq.
+ */
+#define DEFAULT_RAMP_DOWN_STEP 300000
+static unsigned int ramp_down_step;
+
+/*
+ * CPU freq will be increased if measured load > max_cpu_load;
+ */
+#define DEFAULT_MAX_CPU_LOAD 55
+static unsigned long max_cpu_load;
+
+/*
+ * CPU freq will be decreased if measured load < min_cpu_load;
+ */
+#define DEFAULT_MIN_CPU_LOAD 25
+static unsigned long min_cpu_load;
+
+/*
+ * The minimum amount of time to spend at a frequency before we can ramp up.
+ * Notice we ignore this when we are below the ideal frequency.
+ */
+#define DEFAULT_UP_RATE_US 48000;
+static unsigned long up_rate_us;
+
+/*
+ * The minimum amount of time to spend at a frequency before we can ramp down.
+ * Notice we ignore this when we are above the ideal frequency.
+ */
+#define DEFAULT_DOWN_RATE_US 99000;
+static unsigned long down_rate_us;
+
+/*
+ * The frequency to set when waking up from sleep.
+ * When sleep_ideal_freq=0 this will have no effect.
+ */
+#define DEFAULT_SLEEP_WAKEUP_FREQ 99999999
+static unsigned int sleep_wakeup_freq;
+
+/*
+ * Sampling rate, I highly recommend to leave it at 2.
+ */
+#define DEFAULT_SAMPLE_RATE_JIFFIES 2
+static unsigned int sample_rate_jiffies;
+
+
+/*************** End of tunables ***************/
+
+
+static void (*pm_idle_old)(void);
+static atomic_t active_count = ATOMIC_INIT(0);
+
+struct smartass_info_s {
+	struct cpufreq_policy *cur_policy;
+	struct cpufreq_frequency_table *freq_table;
+	struct timer_list timer;
+	u64 time_in_idle;
+	u64 idle_exit_time;
+	u64 freq_change_time;
+	u64 freq_change_time_in_idle;
+	int cur_cpu_load;
+	int old_freq;
+	int ramp_dir;
+	unsigned int enable;
+	int ideal_speed;
+};
+static DEFINE_PER_CPU(struct smartass_info_s, smartass_info);
+
+/* Workqueues handle frequency scaling */
+static struct workqueue_struct *up_wq;
+static struct workqueue_struct *down_wq;
+static struct work_struct freq_scale_work;
+
+static cpumask_t work_cpumask;
+static spinlock_t cpumask_lock;
+
+static unsigned int suspended;
+
+#define dprintk(flag,msg...) do { \
+	if (debug_mask & flag) printk(KERN_DEBUG msg); \
+	} while (0)
+
+enum {
+	SMARTASS_DEBUG_JUMPS=1,
+	SMARTASS_DEBUG_LOAD=2,
+	SMARTASS_DEBUG_ALG=4
+};
+
+/*
+ * Combination of the above debug flags.
+ */
+static unsigned long debug_mask;
+
+static int cpufreq_governor_smartass(struct cpufreq_policy *policy,
+		unsigned int event);
+
+#ifndef CONFIG_CPU_FREQ_DEFAULT_GOV_SMARTASS2
+static
+#endif
+struct cpufreq_governor cpufreq_gov_smartass2 = {
+	.name = "smartassV2",
+	.governor = cpufreq_governor_smartass,
+	.max_transition_latency = 9000000,
+	.owner = THIS_MODULE,
+};
+
+inline static void smartass_update_min_max(struct smartass_info_s *this_smartass, struct cpufreq_policy *policy, int suspend) {
+	if (suspend) {
+		this_smartass->ideal_speed = // sleep_ideal_freq; but make sure it obeys the policy min/max
+			policy->max > sleep_ideal_freq ?
+			(sleep_ideal_freq > policy->min ? sleep_ideal_freq : policy->min) : policy->max;
+	} else {
+		this_smartass->ideal_speed = // awake_ideal_freq; but make sure it obeys the policy min/max
+			policy->min < awake_ideal_freq ?
+			(awake_ideal_freq < policy->max ? awake_ideal_freq : policy->max) : policy->min;
+	}
+}
+
+inline static void smartass_update_min_max_allcpus(void) {
+	unsigned int i;
+	for_each_online_cpu(i) {
+		struct smartass_info_s *this_smartass = &per_cpu(smartass_info, i);
+		if (this_smartass->enable)
+			smartass_update_min_max(this_smartass,this_smartass->cur_policy,suspended);
+	}
+}
+
+inline static unsigned int validate_freq(struct cpufreq_policy *policy, int freq) {
+	if (freq > (int)policy->max)
+		return policy->max;
+	if (freq < (int)policy->min)
+		return policy->min;
+	return freq;
+}
+
+inline static void reset_timer(unsigned long cpu, struct smartass_info_s *this_smartass) {
+	this_smartass->time_in_idle = get_cpu_idle_time_us(cpu, &this_smartass->idle_exit_time);
+	mod_timer(&this_smartass->timer, jiffies + sample_rate_jiffies);
+}
+
+inline static void work_cpumask_set(unsigned long cpu) {
+	unsigned long flags;
+	spin_lock_irqsave(&cpumask_lock, flags);
+	cpumask_set_cpu(cpu, &work_cpumask);
+	spin_unlock_irqrestore(&cpumask_lock, flags);
+}
+
+inline static int work_cpumask_test_and_clear(unsigned long cpu) {
+	unsigned long flags;
+	int res = 0;
+	spin_lock_irqsave(&cpumask_lock, flags);
+	res = cpumask_test_and_clear_cpu(cpu, &work_cpumask);
+	spin_unlock_irqrestore(&cpumask_lock, flags);
+	return res;
+}
+
+inline static int target_freq(struct cpufreq_policy *policy, struct smartass_info_s *this_smartass,
+			      int new_freq, int old_freq, int prefered_relation) {
+	int index, target;
+	struct cpufreq_frequency_table *table = this_smartass->freq_table;
+
+	if (new_freq == old_freq)
+		return 0;
+	new_freq = validate_freq(policy,new_freq);
+	if (new_freq == old_freq)
+		return 0;
+
+	if (table &&
+	    !cpufreq_frequency_table_target(policy,table,new_freq,prefered_relation,&index))
+	{
+		target = table[index].frequency;
+		if (target == old_freq) {
+			// if for example we are ramping up to *at most* current + ramp_up_step
+			// but there is no such frequency higher than the current, try also
+			// to ramp up to *at least* current + ramp_up_step.
+			if (new_freq > old_freq && prefered_relation==CPUFREQ_RELATION_H
+			    && !cpufreq_frequency_table_target(policy,table,new_freq,
+							       CPUFREQ_RELATION_L,&index))
+				target = table[index].frequency;
+			// simlarly for ramping down:
+			else if (new_freq < old_freq && prefered_relation==CPUFREQ_RELATION_L
+				&& !cpufreq_frequency_table_target(policy,table,new_freq,
+								   CPUFREQ_RELATION_H,&index))
+				target = table[index].frequency;
+		}
+
+		if (target == old_freq) {
+			// We should not get here:
+			// If we got here we tried to change to a validated new_freq which is different
+			// from old_freq, so there is no reason for us to remain at same frequency.
+			printk(KERN_WARNING "Smartass: frequency change failed: %d to %d => %d\n",
+			       old_freq,new_freq,target);
+			return 0;
+		}
+	}
+	else target = new_freq;
+
+	__cpufreq_driver_target(policy, target, prefered_relation);
+
+	dprintk(SMARTASS_DEBUG_JUMPS,"SmartassQ: jumping from %d to %d => %d (%d)\n",
+		old_freq,new_freq,target,policy->cur);
+
+	return target;
+}
+
+static void cpufreq_smartass_timer(unsigned long cpu)
+{
+	u64 delta_idle;
+	u64 delta_time;
+	int cpu_load;
+	int old_freq;
+	u64 update_time;
+	u64 now_idle;
+	int queued_work = 0;
+	struct smartass_info_s *this_smartass = &per_cpu(smartass_info, cpu);
+	struct cpufreq_policy *policy = this_smartass->cur_policy;
+
+	now_idle = get_cpu_idle_time_us(cpu, &update_time);
+	old_freq = policy->cur;
+
+	if (this_smartass->idle_exit_time == 0 || update_time == this_smartass->idle_exit_time)
+		return;
+
+	delta_idle = cputime64_sub(now_idle, this_smartass->time_in_idle);
+	delta_time = cputime64_sub(update_time, this_smartass->idle_exit_time);
+
+	// If timer ran less than 1ms after short-term sample started, retry.
+	if (delta_time < 1000) {
+		if (!timer_pending(&this_smartass->timer))
+			reset_timer(cpu,this_smartass);
+		return;
+	}
+
+	if (delta_idle > delta_time)
+		cpu_load = 0;
+	else
+		cpu_load = 100 * (unsigned int)(delta_time - delta_idle) / (unsigned int)delta_time;
+
+	dprintk(SMARTASS_DEBUG_LOAD,"smartassT @ %d: load %d (delta_time %llu)\n",
+		old_freq,cpu_load,delta_time);
+
+	this_smartass->cur_cpu_load = cpu_load;
+	this_smartass->old_freq = old_freq;
+
+	// Scale up if load is above max or if there where no idle cycles since coming out of idle,
+	// additionally, if we are at or above the ideal_speed, verify we have been at this frequency
+	// for at least up_rate_us:
+	if (cpu_load > max_cpu_load || delta_idle == 0)
+	{
+		if (old_freq < policy->max &&
+			 (old_freq < this_smartass->ideal_speed || delta_idle == 0 ||
+			  cputime64_sub(update_time, this_smartass->freq_change_time) >= up_rate_us))
+		{
+			dprintk(SMARTASS_DEBUG_ALG,"smartassT @ %d ramp up: load %d (delta_idle %llu)\n",
+				old_freq,cpu_load,delta_idle);
+			this_smartass->ramp_dir = 1;
+			work_cpumask_set(cpu);
+			queue_work(up_wq, &freq_scale_work);
+			queued_work = 1;
+		}
+		else this_smartass->ramp_dir = 0;
+	}
+	// Similarly for scale down: load should be below min and if we are at or below ideal
+	// frequency we require that we have been at this frequency for at least down_rate_us:
+	else if (cpu_load < min_cpu_load && old_freq > policy->min &&
+		 (old_freq > this_smartass->ideal_speed ||
+		  cputime64_sub(update_time, this_smartass->freq_change_time) >= down_rate_us))
+	{
+		dprintk(SMARTASS_DEBUG_ALG,"smartassT @ %d ramp down: load %d (delta_idle %llu)\n",
+			old_freq,cpu_load,delta_idle);
+		this_smartass->ramp_dir = -1;
+		work_cpumask_set(cpu);
+		queue_work(down_wq, &freq_scale_work);
+		queued_work = 1;
+	}
+	else this_smartass->ramp_dir = 0;
+
+	// To avoid unnecessary load when the CPU is already at high load, we don't
+	// reset ourselves if we are at max speed. If and when there are idle cycles,
+	// the idle loop will activate the timer.
+	// Additionally, if we queued some work, the work task will reset the timer
+	// after it has done its adjustments.
+	if (!queued_work && old_freq < policy->max)
+		reset_timer(cpu,this_smartass);
+}
+
+static void cpufreq_idle(void)
+{
+	struct smartass_info_s *this_smartass = &per_cpu(smartass_info, smp_processor_id());
+	struct cpufreq_policy *policy = this_smartass->cur_policy;
+
+	if (!this_smartass->enable) {
+		pm_idle_old();
+		return;
+	}
+
+	if (policy->cur == policy->min && timer_pending(&this_smartass->timer))
+		del_timer(&this_smartass->timer);
+
+	pm_idle_old();
+
+	if (!timer_pending(&this_smartass->timer))
+		reset_timer(smp_processor_id(), this_smartass);
+}
+
+/* We use the same work function to sale up and down */
+static void cpufreq_smartass_freq_change_time_work(struct work_struct *work)
+{
+	unsigned int cpu;
+	int new_freq;
+	int old_freq;
+	int ramp_dir;
+	struct smartass_info_s *this_smartass;
+	struct cpufreq_policy *policy;
+	unsigned int relation = CPUFREQ_RELATION_L;
+	for_each_possible_cpu(cpu) {
+		this_smartass = &per_cpu(smartass_info, cpu);
+		if (!work_cpumask_test_and_clear(cpu))
+			continue;
+
+		ramp_dir = this_smartass->ramp_dir;
+		this_smartass->ramp_dir = 0;
+
+		old_freq = this_smartass->old_freq;
+		policy = this_smartass->cur_policy;
+
+		if (old_freq != policy->cur) {
+			// frequency was changed by someone else?
+			printk(KERN_WARNING "Smartass: frequency changed by 3rd party: %d to %d\n",
+			       old_freq,policy->cur);
+			new_freq = old_freq;
+		}
+		else if (ramp_dir > 0 && nr_running() > 1) {
+			// ramp up logic:
+			if (old_freq < this_smartass->ideal_speed)
+				new_freq = this_smartass->ideal_speed;
+			else if (ramp_up_step) {
+				new_freq = old_freq + ramp_up_step;
+				relation = CPUFREQ_RELATION_H;
+			}
+			else {
+				new_freq = policy->max;
+				relation = CPUFREQ_RELATION_H;
+			}
+			dprintk(SMARTASS_DEBUG_ALG,"smartassQ @ %d ramp up: ramp_dir=%d ideal=%d\n",
+				old_freq,ramp_dir,this_smartass->ideal_speed);
+		}
+		else if (ramp_dir < 0) {
+			// ramp down logic:
+			if (old_freq > this_smartass->ideal_speed) {
+				new_freq = this_smartass->ideal_speed;
+				relation = CPUFREQ_RELATION_H;
+			}
+			else if (ramp_down_step)
+				new_freq = old_freq - ramp_down_step;
+			else {
+				// Load heuristics: Adjust new_freq such that, assuming a linear
+				// scaling of load vs. frequency, the load in the new frequency
+				// will be max_cpu_load:
+				new_freq = old_freq * this_smartass->cur_cpu_load / max_cpu_load;
+				if (new_freq > old_freq) // min_cpu_load > max_cpu_load ?!
+					new_freq = old_freq -1;
+			}
+			dprintk(SMARTASS_DEBUG_ALG,"smartassQ @ %d ramp down: ramp_dir=%d ideal=%d\n",
+				old_freq,ramp_dir,this_smartass->ideal_speed);
+		}
+		else { // ramp_dir==0 ?! Could the timer change its mind about a queued ramp up/down
+		       // before the work task gets to run?
+		       // This may also happen if we refused to ramp up because the nr_running()==1
+			new_freq = old_freq;
+			dprintk(SMARTASS_DEBUG_ALG,"smartassQ @ %d nothing: ramp_dir=%d nr_running=%lu\n",
+				old_freq,ramp_dir,nr_running());
+		}
+
+		// do actual ramp up (returns 0, if frequency change failed):
+		new_freq = target_freq(policy,this_smartass,new_freq,old_freq,relation);
+		if (new_freq)
+			this_smartass->freq_change_time_in_idle =
+				get_cpu_idle_time_us(cpu,&this_smartass->freq_change_time);
+
+		// reset timer:
+		if (new_freq < policy->max)
+			reset_timer(cpu,this_smartass);
+		// if we are maxed out, it is pointless to use the timer
+		// (idle cycles wake up the timer when the timer comes)
+		else if (timer_pending(&this_smartass->timer))
+			del_timer(&this_smartass->timer);
+	}
+}
+
+static ssize_t show_debug_mask(struct kobject *kobj, struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%lu\n", debug_mask);
+}
+
+static ssize_t store_debug_mask(struct kobject *kobj, struct attribute *attr, const char *buf, size_t count)
+{
+	ssize_t res;
+	unsigned long input;
+	res = strict_strtoul(buf, 0, &input);
+	if (res >= 0)
+		debug_mask = input;
+	else return -EINVAL;
+	return count;
+}
+
+static ssize_t show_up_rate_us(struct kobject *kobj, struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%lu\n", up_rate_us);
+}
+
+static ssize_t store_up_rate_us(struct kobject *kobj, struct attribute *attr, const char *buf, size_t count)
+{
+	ssize_t res;
+	unsigned long input;
+	res = strict_strtoul(buf, 0, &input);
+	if (res >= 0 && input >= 0 && input <= 100000000)
+		up_rate_us = input;
+	else return -EINVAL;
+	return count;
+}
+
+static ssize_t show_down_rate_us(struct kobject *kobj, struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%lu\n", down_rate_us);
+}
+
+static ssize_t store_down_rate_us(struct kobject *kobj, struct attribute *attr, const char *buf, size_t count)
+{
+	ssize_t res;
+	unsigned long input;
+	res = strict_strtoul(buf, 0, &input);
+	if (res >= 0 && input >= 0 && input <= 100000000)
+		down_rate_us = input;
+	else return -EINVAL;
+	return count;
+}
+
+static ssize_t show_sleep_ideal_freq(struct kobject *kobj, struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%u\n", sleep_ideal_freq);
+}
+
+static ssize_t store_sleep_ideal_freq(struct kobject *kobj, struct attribute *attr, const char *buf, size_t count)
+{
+	ssize_t res;
+	unsigned long input;
+	res = strict_strtoul(buf, 0, &input);
+	if (res >= 0 && input >= 0) {
+		sleep_ideal_freq = input;
+		if (suspended)
+			smartass_update_min_max_allcpus();
+	}
+	else return -EINVAL;
+	return count;
+}
+
+static ssize_t show_sleep_wakeup_freq(struct kobject *kobj, struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%u\n", sleep_wakeup_freq);
+}
+
+static ssize_t store_sleep_wakeup_freq(struct kobject *kobj, struct attribute *attr, const char *buf, size_t count)
+{
+	ssize_t res;
+	unsigned long input;
+	res = strict_strtoul(buf, 0, &input);
+	if (res >= 0 && input >= 0)
+		sleep_wakeup_freq = input;
+	else return -EINVAL;
+	return count;
+}
+
+static ssize_t show_awake_ideal_freq(struct kobject *kobj, struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%u\n", awake_ideal_freq);
+}
+
+static ssize_t store_awake_ideal_freq(struct kobject *kobj, struct attribute *attr, const char *buf, size_t count)
+{
+	ssize_t res;
+	unsigned long input;
+	res = strict_strtoul(buf, 0, &input);
+	if (res >= 0 && input >= 0) {
+		awake_ideal_freq = input;
+		if (!suspended)
+			smartass_update_min_max_allcpus();
+	}
+	else return -EINVAL;
+	return count;
+}
+
+static ssize_t show_sample_rate_jiffies(struct kobject *kobj, struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%u\n", sample_rate_jiffies);
+}
+
+static ssize_t store_sample_rate_jiffies(struct kobject *kobj, struct attribute *attr, const char *buf, size_t count)
+{
+	ssize_t res;
+	unsigned long input;
+	res = strict_strtoul(buf, 0, &input);
+	if (res >= 0 && input > 0 && input <= 1000)
+		sample_rate_jiffies = input;
+	else return -EINVAL;
+	return count;
+}
+
+static ssize_t show_ramp_up_step(struct kobject *kobj, struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%u\n", ramp_up_step);
+}
+
+static ssize_t store_ramp_up_step(struct kobject *kobj, struct attribute *attr, const char *buf, size_t count)
+{
+	ssize_t res;
+	unsigned long input;
+	res = strict_strtoul(buf, 0, &input);
+	if (res >= 0 && input >= 0)
+		ramp_up_step = input;
+	else return -EINVAL;
+	return count;
+}
+
+static ssize_t show_ramp_down_step(struct kobject *kobj, struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%u\n", ramp_down_step);
+}
+
+static ssize_t store_ramp_down_step(struct kobject *kobj, struct attribute *attr, const char *buf, size_t count)
+{
+	ssize_t res;
+	unsigned long input;
+	res = strict_strtoul(buf, 0, &input);
+	if (res >= 0 && input >= 0)
+		ramp_down_step = input;
+	else return -EINVAL;
+	return count;
+}
+
+static ssize_t show_max_cpu_load(struct kobject *kobj, struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%lu\n", max_cpu_load);
+}
+
+static ssize_t store_max_cpu_load(struct kobject *kobj, struct attribute *attr, const char *buf, size_t count)
+{
+	ssize_t res;
+	unsigned long input;
+	res = strict_strtoul(buf, 0, &input);
+	if (res >= 0 && input > 0 && input <= 100)
+		max_cpu_load = input;
+	else return -EINVAL;
+	return count;
+}
+
+static ssize_t show_min_cpu_load(struct kobject *kobj, struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%lu\n", min_cpu_load);
+}
+
+static ssize_t store_min_cpu_load(struct kobject *kobj, struct attribute *attr, const char *buf, size_t count)
+{
+	ssize_t res;
+	unsigned long input;
+	res = strict_strtoul(buf, 0, &input);
+	if (res >= 0 && input > 0 && input < 100)
+		min_cpu_load = input;
+	else return -EINVAL;
+	return count;
+}
+
+#define define_global_rw_attr(_name)		\
+static struct global_attr _name##_attr =	\
+	__ATTR(_name, 0644, show_##_name, store_##_name)
+
+define_global_rw_attr(debug_mask);
+define_global_rw_attr(up_rate_us);
+define_global_rw_attr(down_rate_us);
+define_global_rw_attr(sleep_ideal_freq);
+define_global_rw_attr(sleep_wakeup_freq);
+define_global_rw_attr(awake_ideal_freq);
+define_global_rw_attr(sample_rate_jiffies);
+define_global_rw_attr(ramp_up_step);
+define_global_rw_attr(ramp_down_step);
+define_global_rw_attr(max_cpu_load);
+define_global_rw_attr(min_cpu_load);
+
+static struct attribute * smartass_attributes[] = {
+	&debug_mask_attr.attr,
+	&up_rate_us_attr.attr,
+	&down_rate_us_attr.attr,
+	&sleep_ideal_freq_attr.attr,
+	&sleep_wakeup_freq_attr.attr,
+	&awake_ideal_freq_attr.attr,
+	&sample_rate_jiffies_attr.attr,
+	&ramp_up_step_attr.attr,
+	&ramp_down_step_attr.attr,
+	&max_cpu_load_attr.attr,
+	&min_cpu_load_attr.attr,
+	NULL,
+};
+
+static struct attribute_group smartass_attr_group = {
+	.attrs = smartass_attributes,
+	.name = "smartass",
+};
+
+static int cpufreq_governor_smartass(struct cpufreq_policy *new_policy,
+		unsigned int event)
+{
+	unsigned int cpu = new_policy->cpu;
+	int rc;
+	struct smartass_info_s *this_smartass = &per_cpu(smartass_info, cpu);
+
+	switch (event) {
+	case CPUFREQ_GOV_START:
+		if ((!cpu_online(cpu)) || (!new_policy->cur))
+			return -EINVAL;
+
+		this_smartass->cur_policy = new_policy;
+
+		this_smartass->enable = 1;
+
+		smartass_update_min_max(this_smartass,new_policy,suspended);
+
+		this_smartass->freq_table = cpufreq_frequency_get_table(cpu);
+		if (!this_smartass->freq_table)
+			printk(KERN_WARNING "Smartass: no frequency table for cpu %d?!\n",cpu);
+
+		smp_wmb();
+
+		// Do not register the idle hook and create sysfs
+		// entries if we have already done so.
+		if (atomic_inc_return(&active_count) <= 1) {
+			rc = sysfs_create_group(cpufreq_global_kobject,
+						&smartass_attr_group);
+			if (rc)
+				return rc;
+
+			pm_idle_old = pm_idle;
+			pm_idle = cpufreq_idle;
+		}
+
+		if (this_smartass->cur_policy->cur < new_policy->max && !timer_pending(&this_smartass->timer))
+			reset_timer(cpu,this_smartass);
+
+		break;
+
+	case CPUFREQ_GOV_LIMITS:
+		smartass_update_min_max(this_smartass,new_policy,suspended);
+
+		if (this_smartass->cur_policy->cur > new_policy->max) {
+			dprintk(SMARTASS_DEBUG_JUMPS,"SmartassI: jumping to new max freq: %d\n",new_policy->max);
+			__cpufreq_driver_target(this_smartass->cur_policy,
+						new_policy->max, CPUFREQ_RELATION_H);
+		}
+		else if (this_smartass->cur_policy->cur < new_policy->min) {
+			dprintk(SMARTASS_DEBUG_JUMPS,"SmartassI: jumping to new min freq: %d\n",new_policy->min);
+			__cpufreq_driver_target(this_smartass->cur_policy,
+						new_policy->min, CPUFREQ_RELATION_L);
+		}
+
+		if (this_smartass->cur_policy->cur < new_policy->max && !timer_pending(&this_smartass->timer))
+			reset_timer(cpu,this_smartass);
+
+		break;
+
+	case CPUFREQ_GOV_STOP:
+		this_smartass->enable = 0;
+		smp_wmb();
+		del_timer(&this_smartass->timer);
+		flush_work(&freq_scale_work);
+		this_smartass->idle_exit_time = 0;
+
+		if (atomic_dec_return(&active_count) <= 1) {
+			sysfs_remove_group(cpufreq_global_kobject,
+					   &smartass_attr_group);
+			pm_idle = pm_idle_old;
+		}
+		break;
+	}
+
+	return 0;
+}
+
+static void smartass_suspend(int cpu, int suspend)
+{
+	struct smartass_info_s *this_smartass = &per_cpu(smartass_info, smp_processor_id());
+	struct cpufreq_policy *policy = this_smartass->cur_policy;
+	unsigned int new_freq;
+
+	if (!this_smartass->enable)
+		return;
+
+	smartass_update_min_max(this_smartass,policy,suspend);
+	if (!suspend) { // resume at max speed:
+		new_freq = validate_freq(policy,sleep_wakeup_freq);
+
+		dprintk(SMARTASS_DEBUG_JUMPS,"SmartassS: awaking at %d\n",new_freq);
+
+		__cpufreq_driver_target(policy, new_freq,
+					CPUFREQ_RELATION_L);
+	} else {
+		// to avoid wakeup issues with quick sleep/wakeup don't change actual frequency when entering sleep
+		// to allow some time to settle down. Instead we just reset our statistics (and reset the timer).
+		// Eventually, the timer will adjust the frequency if necessary.
+
+		this_smartass->freq_change_time_in_idle =
+			get_cpu_idle_time_us(cpu,&this_smartass->freq_change_time);
+
+		dprintk(SMARTASS_DEBUG_JUMPS,"SmartassS: suspending at %d\n",policy->cur);
+	}
+
+	reset_timer(smp_processor_id(),this_smartass);
+}
+
+static void smartass_early_suspend(struct early_suspend *handler) {
+	int i;
+	if (suspended || sleep_ideal_freq==0) // disable behavior for sleep_ideal_freq==0
+		return;
+	suspended = 1;
+	for_each_online_cpu(i)
+		smartass_suspend(i,1);
+}
+
+static void smartass_late_resume(struct early_suspend *handler) {
+	int i;
+	if (!suspended) // already not suspended so nothing to do
+		return;
+	suspended = 0;
+	for_each_online_cpu(i)
+		smartass_suspend(i,0);
+}
+
+static struct early_suspend smartass_power_suspend = {
+	.suspend = smartass_early_suspend,
+	.resume = smartass_late_resume,
+#ifdef CONFIG_MACH_HERO
+	.level = EARLY_SUSPEND_LEVEL_DISABLE_FB + 1,
+#endif
+};
+
+static int __init cpufreq_smartass_init(void)
+{
+	unsigned int i;
+	struct smartass_info_s *this_smartass;
+	debug_mask = 0;
+	up_rate_us = DEFAULT_UP_RATE_US;
+	down_rate_us = DEFAULT_DOWN_RATE_US;
+	sleep_ideal_freq = DEFAULT_SLEEP_IDEAL_FREQ;
+	sleep_wakeup_freq = DEFAULT_SLEEP_WAKEUP_FREQ;
+	awake_ideal_freq = DEFAULT_AWAKE_IDEAL_FREQ;
+	sample_rate_jiffies = DEFAULT_SAMPLE_RATE_JIFFIES;
+	ramp_up_step = DEFAULT_RAMP_UP_STEP;
+	ramp_down_step = DEFAULT_RAMP_DOWN_STEP;
+	max_cpu_load = DEFAULT_MAX_CPU_LOAD;
+	min_cpu_load = DEFAULT_MIN_CPU_LOAD;
+
+	spin_lock_init(&cpumask_lock);
+
+	suspended = 0;
+
+	/* Initalize per-cpu data: */
+	for_each_possible_cpu(i) {
+		this_smartass = &per_cpu(smartass_info, i);
+		this_smartass->enable = 0;
+		this_smartass->cur_policy = 0;
+		this_smartass->ramp_dir = 0;
+		this_smartass->time_in_idle = 0;
+		this_smartass->idle_exit_time = 0;
+		this_smartass->freq_change_time = 0;
+		this_smartass->freq_change_time_in_idle = 0;
+		this_smartass->cur_cpu_load = 0;
+		// intialize timer:
+		init_timer_deferrable(&this_smartass->timer);
+		this_smartass->timer.function = cpufreq_smartass_timer;
+		this_smartass->timer.data = i;
+		work_cpumask_test_and_clear(i);
+	}
+
+	// Scale up is high priority
+	up_wq = alloc_workqueue("ksmartass_up", WQ_HIGHPRI, 1);
+	down_wq = alloc_workqueue("ksmartass_down", 0, 1);
+	if (!up_wq || !down_wq)
+		return -ENOMEM;
+
+	INIT_WORK(&freq_scale_work, cpufreq_smartass_freq_change_time_work);
+
+	register_early_suspend(&smartass_power_suspend);
+
+	return cpufreq_register_governor(&cpufreq_gov_smartass2);
+}
+
+#ifdef CONFIG_CPU_FREQ_DEFAULT_GOV_SMARTASS2
+fs_initcall(cpufreq_smartass_init);
+#else
+module_init(cpufreq_smartass_init);
+#endif
+
+static void __exit cpufreq_smartass_exit(void)
+{
+	cpufreq_unregister_governor(&cpufreq_gov_smartass2);
+	destroy_workqueue(up_wq);
+	destroy_workqueue(down_wq);
+}
+
+module_exit(cpufreq_smartass_exit);
+
+MODULE_AUTHOR ("Erasmux");
+MODULE_DESCRIPTION ("'cpufreq_smartass2' - A smart cpufreq governor");
+MODULE_LICENSE ("GPL");
diff -urNp Kernel/drivers/cpufreq/cpufreq_smartass.c HelloWorld-Renew-v1.0-n7000-jb/drivers/cpufreq/cpufreq_smartass.c
--- Kernel/drivers/cpufreq/cpufreq_smartass.c	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/drivers/cpufreq/cpufreq_smartass.c	2013-04-25 17:38:09.000000000 +0200
@@ -0,0 +1,753 @@
+/*
+ * drivers/cpufreq/cpufreq_smartass.c
+ *
+ * Copyright (C) 2010 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Author: Erasmux
+ *
+ * Based on the interactive governor By Mike Chan (mike@android.com)
+ * which was adaptated to 2.6.29 kernel by Nadlabak (pavel@doshaska.net)
+ *
+ * requires to add
+ * EXPORT_SYMBOL_GPL(nr_running);
+ * at the end of kernel/sched.c
+ *
+ */
+
+#include <linux/cpu.h>
+#include <linux/cpumask.h>
+#include <linux/cpufreq.h>
+#include <linux/sched.h>
+#include <linux/tick.h>
+#include <linux/timer.h>
+#include <linux/workqueue.h>
+#include <linux/moduleparam.h>
+#include <asm/cputime.h>
+#include <linux/earlysuspend.h>
+
+static void (*pm_idle_old)(void);
+static atomic_t active_count = ATOMIC_INIT(0);
+
+struct smartass_info_s {
+	struct cpufreq_frequency_table *freq_table;
+	struct cpufreq_policy *cur_policy;
+	struct timer_list timer;
+	u64 time_in_idle;
+	u64 idle_exit_time;
+	u64 freq_change_time;
+	u64 freq_change_time_in_idle;
+	int cur_cpu_load;
+	unsigned int force_ramp_up;
+	unsigned int enable;
+	int max_speed;
+	int min_speed;
+};
+static DEFINE_PER_CPU(struct smartass_info_s, smartass_info);
+
+/* Workqueues handle frequency scaling */
+static struct workqueue_struct *up_wq;
+static struct workqueue_struct *down_wq;
+static struct work_struct freq_scale_work;
+
+static cpumask_t work_cpumask;
+static unsigned int suspended;
+
+enum {
+	SMARTASS_DEBUG_JUMPS=1,
+	SMARTASS_DEBUG_LOAD=2
+};
+
+/*
+ * Combination of the above debug flags.
+ */
+static unsigned long debug_mask;
+
+/*
+ * The minimum amount of time to spend at a frequency before we can ramp up.
+ */
+#define DEFAULT_UP_RATE_US 12000;
+static unsigned long up_rate_us;
+
+/*
+ * The minimum amount of time to spend at a frequency before we can ramp down.
+ */
+#define DEFAULT_DOWN_RATE_US 24000;
+static unsigned long down_rate_us;
+
+/*
+ * When ramping up frequency with no idle cycles jump to at least this frequency.
+ * Zero disables. Set a very high value to jump to policy max freqeuncy.
+ */
+#define DEFAULT_UP_MIN_FREQ 0
+static unsigned int up_min_freq;
+
+/*
+ * When sleep_max_freq>0 the frequency when suspended will be capped
+ * by this frequency. Also will wake up at max frequency of policy
+ * to minimize wakeup issues.
+ * Set sleep_max_freq=0 to disable this behavior.
+ */
+#define DEFAULT_SLEEP_MAX_FREQ 200000
+static unsigned int sleep_max_freq;
+
+/*
+ * The frequency to set when waking up from sleep.
+ * When sleep_max_freq=0 this will have no effect.
+ */
+#define DEFAULT_SLEEP_WAKEUP_FREQ 800000
+static unsigned int sleep_wakeup_freq;
+
+/*
+ * When awake_min_freq>0 the frequency when not suspended will not
+ * go below this frequency.
+ * Set awake_min_freq=0 to disable this behavior.
+ */
+#define DEFAULT_AWAKE_MIN_FREQ 0
+static unsigned int awake_min_freq;
+
+/*
+ * Sampling rate, I highly recommend to leave it at 2.
+ */
+#define DEFAULT_SAMPLE_RATE_JIFFIES 2
+static unsigned int sample_rate_jiffies;
+
+/*
+ * Freqeuncy delta when ramping up.
+ * zero disables and causes to always jump straight to max frequency.
+ */
+#define DEFAULT_RAMP_UP_STEP 100000
+static unsigned int ramp_up_step;
+
+/*
+ * Freqeuncy delta when ramping down.
+ * zero disables and will calculate ramp down according to load heuristic.
+ */
+#define DEFAULT_RAMP_DOWN_STEP 0
+static unsigned int ramp_down_step;
+
+/*
+ * CPU freq will be increased if measured load > max_cpu_load;
+ */
+#define DEFAULT_MAX_CPU_LOAD 50
+static unsigned long max_cpu_load;
+
+/*
+ * CPU freq will be decreased if measured load < min_cpu_load;
+ */
+#define DEFAULT_MIN_CPU_LOAD 25
+static unsigned long min_cpu_load;
+
+static int cpufreq_governor_smartass(struct cpufreq_policy *policy,
+		unsigned int event);
+
+#ifndef CONFIG_CPU_FREQ_DEFAULT_GOV_SMARTASS
+static
+#endif
+struct cpufreq_governor cpufreq_gov_smartass = {
+	.name = "smartass",
+	.governor = cpufreq_governor_smartass,
+#if defined(CONFIG_ARCH_MSM_SCORPION)
+	.max_transition_latency = 8000000,
+#else
+	.max_transition_latency = 9000000,
+#endif
+	.owner = THIS_MODULE,
+};
+
+static void smartass_update_min_max(struct smartass_info_s *this_smartass, struct cpufreq_policy *policy, int suspend) {
+	if (suspend) {
+		this_smartass->min_speed = policy->min;
+		this_smartass->max_speed = // sleep_max_freq; but make sure it obeys the policy min/max
+			policy->max > sleep_max_freq ? (sleep_max_freq > policy->min ? sleep_max_freq : policy->min) : policy->max;
+	} else {
+		this_smartass->min_speed = // awake_min_freq; but make sure it obeys the policy min/max
+			policy->min < awake_min_freq ? (awake_min_freq < policy->max ? awake_min_freq : policy->max) : policy->min;
+		this_smartass->max_speed = policy->max;
+	}
+}
+
+inline static unsigned int validate_freq(struct smartass_info_s *this_smartass, int freq) {
+	if (freq > this_smartass->max_speed)
+		return this_smartass->max_speed;
+	if (freq < this_smartass->min_speed)
+		return this_smartass->min_speed;
+	return freq;
+}
+
+static void reset_timer(unsigned long cpu, struct smartass_info_s *this_smartass) {
+	this_smartass->time_in_idle = get_cpu_idle_time_us(cpu, &this_smartass->idle_exit_time);
+	mod_timer(&this_smartass->timer, jiffies + sample_rate_jiffies);
+}
+
+static void cpufreq_smartass_timer(unsigned long data)
+{
+	u64 delta_idle;
+	u64 delta_time;
+	int cpu_load;
+	u64 update_time;
+	u64 now_idle;
+	struct smartass_info_s *this_smartass = &per_cpu(smartass_info, data);
+	struct cpufreq_policy *policy = this_smartass->cur_policy;
+
+	now_idle = get_cpu_idle_time_us(data, &update_time);
+
+	if (this_smartass->idle_exit_time == 0 || update_time == this_smartass->idle_exit_time)
+		return;
+
+	delta_idle = cputime64_sub(now_idle, this_smartass->time_in_idle);
+	delta_time = cputime64_sub(update_time, this_smartass->idle_exit_time);
+	//printk(KERN_INFO "smartassT: t=%llu i=%llu\n",cputime64_sub(update_time,this_smartass->idle_exit_time),delta_idle);
+
+	// If timer ran less than 1ms after short-term sample started, retry.
+	if (delta_time < 1000) {
+		if (!timer_pending(&this_smartass->timer))
+			reset_timer(data,this_smartass);
+		return;
+	}
+
+	if (delta_idle > delta_time)
+		cpu_load = 0;
+	else
+		cpu_load = 100 * (unsigned int)(delta_time - delta_idle) / (unsigned int)delta_time;
+
+	if (debug_mask & SMARTASS_DEBUG_LOAD)
+		printk(KERN_INFO "smartassT @ %d: load %d (delta_time %llu)\n",policy->cur,cpu_load,delta_time);
+
+	this_smartass->cur_cpu_load = cpu_load;
+
+	// Scale up if load is above max or if there where no idle cycles since coming out of idle.
+	if (cpu_load > max_cpu_load || delta_idle == 0) {
+		if (policy->cur == policy->max)
+			return;
+
+		if (nr_running() < 1)
+			return;
+
+		if (cputime64_sub(update_time, this_smartass->freq_change_time) < up_rate_us)
+			return;
+
+
+		this_smartass->force_ramp_up = 1;
+		cpumask_set_cpu(data, &work_cpumask);
+		queue_work(up_wq, &freq_scale_work);
+		return;
+	}
+
+	/*
+	 * There is a window where if the cpu utlization can go from low to high
+	 * between the timer expiring, delta_idle will be > 0 and the cpu will
+	 * be 100% busy, preventing idle from running, and this timer from
+	 * firing. So setup another timer to fire to check cpu utlization.
+	 * Do not setup the timer if there is no scheduled work or if at max speed.
+	 */
+	if (policy->cur < this_smartass->max_speed && !timer_pending(&this_smartass->timer) && nr_running() > 0)
+		reset_timer(data,this_smartass);
+
+	if (policy->cur == policy->min)
+		return;
+
+	/*
+	 * Do not scale down unless we have been at this frequency for the
+	 * minimum sample time.
+	 */
+	if (cputime64_sub(update_time, this_smartass->freq_change_time) < down_rate_us)
+		return;
+
+	cpumask_set_cpu(data, &work_cpumask);
+	queue_work(down_wq, &freq_scale_work);
+}
+
+static void cpufreq_idle(void)
+{
+	struct smartass_info_s *this_smartass = &per_cpu(smartass_info, smp_processor_id());
+	struct cpufreq_policy *policy = this_smartass->cur_policy;
+
+	if (!this_smartass->enable) {
+		pm_idle_old();
+		return;
+	}
+
+	if (policy->cur == this_smartass->min_speed && timer_pending(&this_smartass->timer))
+		del_timer(&this_smartass->timer);
+
+	pm_idle_old();
+
+	if (!timer_pending(&this_smartass->timer))
+		reset_timer(smp_processor_id(), this_smartass);
+}
+
+/* We use the same work function to sale up and down */
+static void cpufreq_smartass_freq_change_time_work(struct work_struct *work)
+{
+        unsigned int cpu;
+        int new_freq;
+        unsigned int force_ramp_up;
+        int cpu_load;
+        struct smartass_info_s *this_smartass;
+        struct cpufreq_policy *policy;
+        unsigned int relation = CPUFREQ_RELATION_L;
+        cpumask_t tmp_mask = work_cpumask;
+        for_each_cpu(cpu, &tmp_mask) {
+                this_smartass = &per_cpu(smartass_info, cpu);
+                policy = this_smartass->cur_policy;
+                cpu_load = this_smartass->cur_cpu_load;
+                force_ramp_up = this_smartass->force_ramp_up && nr_running() > 1;
+                this_smartass->force_ramp_up = 0;
+
+                if (force_ramp_up || cpu_load > max_cpu_load) {
+                        if (force_ramp_up && up_min_freq) {
+                                new_freq = up_min_freq;
+                                relation = CPUFREQ_RELATION_L;
+                        } else if (ramp_up_step) {
+                                new_freq = policy->cur + ramp_up_step;
+                                relation = CPUFREQ_RELATION_H;
+                        } else {
+                                new_freq = this_smartass->max_speed;
+                                relation = CPUFREQ_RELATION_H;
+                        }
+                }
+                else if (cpu_load < min_cpu_load) {
+                        if (ramp_down_step)
+                                new_freq = policy->cur - ramp_down_step;
+                        else {
+                                cpu_load += 100 - max_cpu_load; // dummy load.
+                                new_freq = policy->cur * cpu_load / 100;
+                        }
+                        relation = CPUFREQ_RELATION_L;
+                }
+                else new_freq = policy->cur;
+
+                new_freq = validate_freq(this_smartass,new_freq);
+
+                if (new_freq != policy->cur) {
+                        if (debug_mask & SMARTASS_DEBUG_JUMPS)
+                                printk(KERN_INFO "SmartassQ: jumping from %d to %d\n",policy->cur,new_freq);
+
+                        __cpufreq_driver_target(policy, new_freq, relation);
+
+                        this_smartass->freq_change_time_in_idle =
+                                get_cpu_idle_time_us(cpu,&this_smartass->freq_change_time);
+                }
+
+                cpumask_clear_cpu(cpu, &work_cpumask);
+        }
+}
+
+static ssize_t show_debug_mask(struct cpufreq_policy *policy, char *buf)
+{
+	return sprintf(buf, "%lu\n", debug_mask);
+}
+
+static ssize_t store_debug_mask(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+	ssize_t res;
+	unsigned long input;
+	res = strict_strtoul(buf, 0, &input);
+	if (res >= 0)
+		debug_mask = input;
+	return res;
+}
+
+static struct freq_attr debug_mask_attr = __ATTR(debug_mask, 0644,
+		show_debug_mask, store_debug_mask);
+
+static ssize_t show_up_rate_us(struct cpufreq_policy *policy, char *buf)
+{
+	return sprintf(buf, "%lu\n", up_rate_us);
+}
+
+static ssize_t store_up_rate_us(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+	ssize_t res;
+	unsigned long input;
+	res = strict_strtoul(buf, 0, &input);
+	if (res >= 0 && input >= 0 && input <= 100000000)
+		up_rate_us = input;
+	return res;
+}
+
+static struct freq_attr up_rate_us_attr = __ATTR(up_rate_us, 0644,
+		show_up_rate_us, store_up_rate_us);
+
+static ssize_t show_down_rate_us(struct cpufreq_policy *policy, char *buf)
+{
+	return sprintf(buf, "%lu\n", down_rate_us);
+}
+
+static ssize_t store_down_rate_us(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+	ssize_t res;
+	unsigned long input;
+	res = strict_strtoul(buf, 0, &input);
+	if (res >= 0 && input >= 0 && input <= 100000000)
+		down_rate_us = input;
+	return res;
+}
+
+static struct freq_attr down_rate_us_attr = __ATTR(down_rate_us, 0644,
+		show_down_rate_us, store_down_rate_us);
+
+static ssize_t show_up_min_freq(struct cpufreq_policy *policy, char *buf)
+{
+	return sprintf(buf, "%u\n", up_min_freq);
+}
+
+static ssize_t store_up_min_freq(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+	ssize_t res;
+	unsigned long input;
+	res = strict_strtoul(buf, 0, &input);
+	if (res >= 0 && input >= 0)
+		up_min_freq = input;
+	return res;
+}
+
+static struct freq_attr up_min_freq_attr = __ATTR(up_min_freq, 0644,
+		show_up_min_freq, store_up_min_freq);
+
+static ssize_t show_sleep_max_freq(struct cpufreq_policy *policy, char *buf)
+{
+	return sprintf(buf, "%u\n", sleep_max_freq);
+}
+
+static ssize_t store_sleep_max_freq(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+	ssize_t res;
+	unsigned long input;
+	res = strict_strtoul(buf, 0, &input);
+	if (res >= 0 && input >= 0)
+		sleep_max_freq = input;
+	return res;
+}
+
+static struct freq_attr sleep_max_freq_attr = __ATTR(sleep_max_freq, 0644,
+		show_sleep_max_freq, store_sleep_max_freq);
+
+static ssize_t show_sleep_wakeup_freq(struct cpufreq_policy *policy, char *buf)
+{
+	return sprintf(buf, "%u\n", sleep_wakeup_freq);
+}
+
+static ssize_t store_sleep_wakeup_freq(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+	ssize_t res;
+	unsigned long input;
+	res = strict_strtoul(buf, 0, &input);
+	if (res >= 0 && input >= 0)
+		sleep_wakeup_freq = input;
+	return res;
+}
+
+static struct freq_attr sleep_wakeup_freq_attr = __ATTR(sleep_wakeup_freq, 0644,
+		show_sleep_wakeup_freq, store_sleep_wakeup_freq);
+
+static ssize_t show_awake_min_freq(struct cpufreq_policy *policy, char *buf)
+{
+	return sprintf(buf, "%u\n", awake_min_freq);
+}
+
+static ssize_t store_awake_min_freq(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+	ssize_t res;
+	unsigned long input;
+	res = strict_strtoul(buf, 0, &input);
+	if (res >= 0 && input >= 0)
+		awake_min_freq = input;
+	return res;
+}
+
+static struct freq_attr awake_min_freq_attr = __ATTR(awake_min_freq, 0644,
+		show_awake_min_freq, store_awake_min_freq);
+
+static ssize_t show_sample_rate_jiffies(struct cpufreq_policy *policy, char *buf)
+{
+	return sprintf(buf, "%u\n", sample_rate_jiffies);
+}
+
+static ssize_t store_sample_rate_jiffies(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+	ssize_t res;
+	unsigned long input;
+	res = strict_strtoul(buf, 0, &input);
+	if (res >= 0 && input > 0 && input <= 1000)
+		sample_rate_jiffies = input;
+	return res;
+}
+
+static struct freq_attr sample_rate_jiffies_attr = __ATTR(sample_rate_jiffies, 0644,
+		show_sample_rate_jiffies, store_sample_rate_jiffies);
+
+static ssize_t show_ramp_up_step(struct cpufreq_policy *policy, char *buf)
+{
+	return sprintf(buf, "%u\n", ramp_up_step);
+}
+
+static ssize_t store_ramp_up_step(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+	ssize_t res;
+	unsigned long input;
+	res = strict_strtoul(buf, 0, &input);
+	if (res >= 0 && input >= 0)
+		ramp_up_step = input;
+	return res;
+}
+
+static struct freq_attr ramp_up_step_attr = __ATTR(ramp_up_step, 0644,
+		show_ramp_up_step, store_ramp_up_step);
+
+static ssize_t show_ramp_down_step(struct cpufreq_policy *policy, char *buf)
+{
+	return sprintf(buf, "%u\n", ramp_down_step);
+}
+
+static ssize_t store_ramp_down_step(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+	ssize_t res;
+	unsigned long input;
+	res = strict_strtoul(buf, 0, &input);
+	if (res >= 0 && input >= 0)
+		ramp_down_step = input;
+	return res;
+}
+
+static struct freq_attr ramp_down_step_attr = __ATTR(ramp_down_step, 0644,
+		show_ramp_down_step, store_ramp_down_step);
+
+static ssize_t show_max_cpu_load(struct cpufreq_policy *policy, char *buf)
+{
+	return sprintf(buf, "%lu\n", max_cpu_load);
+}
+
+static ssize_t store_max_cpu_load(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+	ssize_t res;
+	unsigned long input;
+	res = strict_strtoul(buf, 0, &input);
+	if (res >= 0 && input > 0 && input <= 100)
+		max_cpu_load = input;
+	return res;
+}
+
+static struct freq_attr max_cpu_load_attr = __ATTR(max_cpu_load, 0644,
+		show_max_cpu_load, store_max_cpu_load);
+
+static ssize_t show_min_cpu_load(struct cpufreq_policy *policy, char *buf)
+{
+	return sprintf(buf, "%lu\n", min_cpu_load);
+}
+
+static ssize_t store_min_cpu_load(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+	ssize_t res;
+	unsigned long input;
+	res = strict_strtoul(buf, 0, &input);
+	if (res >= 0 && input > 0 && input < 100)
+		min_cpu_load = input;
+	return res;
+}
+
+static struct freq_attr min_cpu_load_attr = __ATTR(min_cpu_load, 0644,
+		show_min_cpu_load, store_min_cpu_load);
+
+static struct attribute * smartass_attributes[] = {
+	&debug_mask_attr.attr,
+	&up_rate_us_attr.attr,
+	&down_rate_us_attr.attr,
+	&up_min_freq_attr.attr,
+	&sleep_max_freq_attr.attr,
+	&sleep_wakeup_freq_attr.attr,
+	&awake_min_freq_attr.attr,
+	&sample_rate_jiffies_attr.attr,
+	&ramp_up_step_attr.attr,
+	&ramp_down_step_attr.attr,
+	&max_cpu_load_attr.attr,
+	&min_cpu_load_attr.attr,
+	NULL,
+};
+
+static struct attribute_group smartass_attr_group = {
+	.attrs = smartass_attributes,
+	.name = "smartass",
+};
+
+static int cpufreq_governor_smartass(struct cpufreq_policy *new_policy,
+		unsigned int event)
+{
+	unsigned int cpu = new_policy->cpu;
+	int rc;
+	struct smartass_info_s *this_smartass = &per_cpu(smartass_info, cpu);
+
+	switch (event) {
+	case CPUFREQ_GOV_START:
+		if ((!cpu_online(cpu)) || (!new_policy->cur))
+			return -EINVAL;
+
+		/*
+		 * Do not register the idle hook and create sysfs
+		 * entries if we have already done so.
+		 */
+		if (atomic_inc_return(&active_count) <= 1) {
+			rc = sysfs_create_group(&new_policy->kobj, &smartass_attr_group);
+			if (rc)
+				return rc;
+			pm_idle_old = pm_idle;
+			pm_idle = cpufreq_idle;
+		}
+
+		this_smartass->freq_table = cpufreq_frequency_get_table(new_policy->cpu);
+		this_smartass->cur_policy = new_policy;
+		this_smartass->enable = 1;
+
+		// notice no break here!
+
+	case CPUFREQ_GOV_LIMITS:
+		smartass_update_min_max(this_smartass,new_policy,suspended);
+		if (this_smartass->cur_policy->cur != this_smartass->max_speed) {
+			if (debug_mask & SMARTASS_DEBUG_JUMPS)
+				printk(KERN_INFO "SmartassI: initializing to %d\n",this_smartass->max_speed);
+			__cpufreq_driver_target(new_policy, this_smartass->max_speed, CPUFREQ_RELATION_H);
+		}
+		break;
+
+	case CPUFREQ_GOV_STOP:
+		del_timer(&this_smartass->timer);
+		this_smartass->enable = 0;
+
+		if (atomic_dec_return(&active_count) > 1)
+			return 0;
+		sysfs_remove_group(&new_policy->kobj,
+				&smartass_attr_group);
+
+		pm_idle = pm_idle_old;
+		break;
+	}
+
+	return 0;
+}
+
+static void smartass_suspend(int cpu, int suspend)
+{
+	struct smartass_info_s *this_smartass = &per_cpu(smartass_info, smp_processor_id());
+	struct cpufreq_policy *policy = this_smartass->cur_policy;
+	unsigned int new_freq;
+
+	if (!this_smartass->enable || sleep_max_freq==0) // disable behavior for sleep_max_freq==0
+		return;
+
+	smartass_update_min_max(this_smartass,policy,suspend);
+	if (suspend) {
+		if (policy->cur > this_smartass->max_speed) {
+			new_freq = this_smartass->max_speed;
+
+			if (debug_mask & SMARTASS_DEBUG_JUMPS)
+				printk(KERN_INFO "SmartassS: suspending at %d\n",new_freq);
+
+			__cpufreq_driver_target(policy, new_freq,
+						CPUFREQ_RELATION_H);
+		}
+	} else { // resume at max speed:
+		new_freq = validate_freq(this_smartass,sleep_wakeup_freq);
+
+		if (debug_mask & SMARTASS_DEBUG_JUMPS)
+			printk(KERN_INFO "SmartassS: awaking at %d\n",new_freq);
+
+		__cpufreq_driver_target(policy, new_freq,
+					CPUFREQ_RELATION_L);
+	}
+}
+
+static void smartass_early_suspend(struct early_suspend *handler) {
+	int i;
+	suspended = 1;
+	for_each_online_cpu(i)
+		smartass_suspend(i, 1);
+}
+
+static void smartass_late_resume(struct early_suspend *handler) {
+	int i;
+	suspended = 0;
+	for_each_online_cpu(i)
+		smartass_suspend(i, 0);
+}
+
+static struct early_suspend smartass_power_suspend = {
+	.suspend = smartass_early_suspend,
+	.resume = smartass_late_resume,
+};
+
+static int __init cpufreq_smartass_init(void)
+{
+	unsigned int i;
+	struct smartass_info_s *this_smartass;
+	debug_mask = 0;
+	up_rate_us = DEFAULT_UP_RATE_US;
+	down_rate_us = DEFAULT_DOWN_RATE_US;
+	up_min_freq = DEFAULT_UP_MIN_FREQ;
+	sleep_max_freq = DEFAULT_SLEEP_MAX_FREQ;
+	sleep_wakeup_freq = DEFAULT_SLEEP_WAKEUP_FREQ;
+	awake_min_freq = DEFAULT_AWAKE_MIN_FREQ;
+	sample_rate_jiffies = DEFAULT_SAMPLE_RATE_JIFFIES;
+	ramp_up_step = DEFAULT_RAMP_UP_STEP;
+	ramp_down_step = DEFAULT_RAMP_DOWN_STEP;
+	max_cpu_load = DEFAULT_MAX_CPU_LOAD;
+	min_cpu_load = DEFAULT_MIN_CPU_LOAD;
+
+	suspended = 0;
+
+	/* Initalize per-cpu data: */
+	for_each_possible_cpu(i) {
+		this_smartass = &per_cpu(smartass_info, i);
+		this_smartass->enable = 0;
+		this_smartass->cur_policy = 0;
+		this_smartass->force_ramp_up = 0;
+		this_smartass->max_speed = DEFAULT_SLEEP_WAKEUP_FREQ;
+		this_smartass->min_speed = DEFAULT_AWAKE_MIN_FREQ;
+		this_smartass->time_in_idle = 0;
+		this_smartass->idle_exit_time = 0;
+		this_smartass->freq_change_time = 0;
+		this_smartass->freq_change_time_in_idle = 0;
+		this_smartass->cur_cpu_load = 0;
+		// intialize timer:
+		init_timer_deferrable(&this_smartass->timer);
+		this_smartass->timer.function = cpufreq_smartass_timer;
+		this_smartass->timer.data = i;
+	}
+
+	/* Scale up is high priority */
+        up_wq = create_workqueue("ksmartass_up");
+        down_wq = create_workqueue("ksmartass_down");
+
+        INIT_WORK(&freq_scale_work, cpufreq_smartass_freq_change_time_work);
+
+        register_early_suspend(&smartass_power_suspend);
+
+        return cpufreq_register_governor(&cpufreq_gov_smartass);
+}
+
+#ifdef CONFIG_CPU_FREQ_DEFAULT_GOV_SMARTASS
+pure_initcall(cpufreq_smartass_init);
+#else
+module_init(cpufreq_smartass_init);
+#endif
+
+static void __exit cpufreq_smartass_exit(void)
+{
+	cpufreq_unregister_governor(&cpufreq_gov_smartass);
+	destroy_workqueue(up_wq);
+	destroy_workqueue(down_wq);
+}
+
+module_exit(cpufreq_smartass_exit);
+
+MODULE_AUTHOR ("Erasmux");
+MODULE_DESCRIPTION ("'cpufreq_smartass' - A smart cpufreq governor!");
+MODULE_LICENSE ("GPL");
diff -urNp Kernel/drivers/cpufreq/Kconfig HelloWorld-Renew-v1.0-n7000-jb/drivers/cpufreq/Kconfig
--- Kernel/drivers/cpufreq/Kconfig	2013-02-20 13:36:19.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/drivers/cpufreq/Kconfig	2013-05-01 12:13:06.809106882 +0200
@@ -123,6 +123,42 @@ config CPU_FREQ_DEFAULT_GOV_PEGASUSQ
 	bool "pegasusq"
 	select CPU_FREQ_GOV_PEGASUSQ
 
+config CPU_FREQ_DEFAULT_GOV_HYPER
+	bool "HYPER"
+	select CPU_FREQ_GOV_HYPER
+
+config CPU_FREQ_DEFAULT_GOV_LULZACTIVE
+	bool "lulzactive"
+	select CPU_FREQ_GOV_LULZACTIVE
+	select CPU_FREQ_GOV_PERFORMANCE
+	---help---
+	  Use the CPUFreq governor 'lulzactive' as default.
+
+config CPU_FREQ_DEFAULT_GOV_SMARTASS
+	bool "smartass"
+	select CPU_FREQ_GOV_SMARTASS
+	select CPU_FREQ_GOV_PERFORMANCE
+	help
+	  Use the CPUFreq governor 'smartass' as default.
+
+config CPU_FREQ_DEFAULT_GOV_SMARTASS2
+	bool "smartass2"
+	select CPU_FREQ_GOV_SMARTASS2
+	help
+	  Use the CPUFreq governor 'smartassV2' as default.
+
+config CPU_FREQ_DEFAULT_GOV_LAGFREE
+	bool "lagfree"
+	select CPU_FREQ_GOV_LAGFREE
+	select CPU_FREQ_GOV_PERFORMANCE
+	help
+	  Use the CPUFreq governor 'lagfree' as default. This allows
+	  you to get a full dynamic frequency capable system by simply
+	  loading your cpufreq low-level hardware driver.
+	  Be aware that not all cpufreq drivers support the lagfree
+	  governor. If unsure have a look at the help section of the
+	  driver. Fallback governor will be the performance governor.
+
 endchoice
 
 config CPU_FREQ_GOV_PERFORMANCE
@@ -202,23 +238,6 @@ config CPU_FREQ_GOV_ONDEMAND_FLEXRATE_MA
 	  The maximum number of ondemand sampling whose rate is
 	  overriden by Flexrate for ondemand.
 
-config CPU_FREQ_GOV_INTERACTIVE
-	tristate "'interactive' cpufreq policy governor"
-	help
-	  'interactive' - This driver adds a dynamic cpufreq policy governor
-	  designed for latency-sensitive workloads.
-
-	  This governor attempts to reduce the latency of clock
-	  increases so that the system is more responsive to
-	  interactive workloads.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called cpufreq_interactive.
-
-	  For details, take a look at linux/Documentation/cpu-freq.
-
-	  If in doubt, say N.
-
 config CPU_FREQ_GOV_CONSERVATIVE
 	tristate "'conservative' cpufreq governor"
 	depends on CPU_FREQ
@@ -242,6 +261,23 @@ config CPU_FREQ_GOV_CONSERVATIVE
 
 	  If in doubt, say N.
 
+config CPU_FREQ_GOV_INTERACTIVE
+	tristate "'interactive' cpufreq policy governor"
+	help
+	  'interactive' - This driver adds a dynamic cpufreq policy governor
+	  designed for latency-sensitive workloads.
+
+	  This governor attempts to reduce the latency of clock
+	  increases so that the system is more responsive to
+	  interactive workloads.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called cpufreq_interactive.
+
+	  For details, take a look at linux/Documentation/cpu-freq.
+
+	  If in doubt, say N.
+
 config CPU_FREQ_GOV_ADAPTIVE
 	tristate "'adaptive' cpufreq policy governor"
 	help
@@ -266,6 +302,49 @@ config CPU_FREQ_GOV_ADAPTIVE
 config CPU_FREQ_GOV_PEGASUSQ
 	tristate "'pegasusq' cpufreq policy governor"
 
+config CPU_FREQ_GOV_HYPER
+	tristate "'HYPER' cpufreq governor"
+	depends on CPU_FREQ
+
+config CPU_FREQ_GOV_LULZACTIVE
+	tristate "'lulzactive' cpufreq governor"
+	depends on CPU_FREQ
+	---help---
+	  'lulzactive' - a new interactive governor by Tegrak!
+
+	  If in doubt, say N.
+
+config CPU_FREQ_GOV_SMARTASS
+	tristate "'smartass' cpufreq governor"
+	depends on CPU_FREQ
+	help
+	  'smartass' - a "smart" optimized governor for the hero!
+
+	  If in doubt, say N.
+
+config CPU_FREQ_GOV_SMARTASS2
+	tristate "'smartassV2' cpufreq governor"
+	depends on CPU_FREQ
+	help
+	  'smartassV2' - a "smart" governor
+
+config CPU_FREQ_GOV_LAGFREE
+        tristate "'lagfree' cpufreq governor"
+        depends on CPU_FREQ
+        help
+          'lagfree' - this driver is rather similar to the 'ondemand'
+          governor both in its source code and its purpose, the difference is
+          its optimisation for better suitability in a battery powered
+          environment. The frequency is gracefully increased and decreased
+          rather than jumping to 100% when speed is required.
+
+          To compile this driver as a module, choose M here: the
+          module will be called cpufreq_lagfree.
+
+          For details, take a look at linux/Documentation/cpu-freq.
+
+          If in doubt, say N.
+
 config CPU_FREQ_GOV_SLP
 	tristate "'slp' cpufreq policy governor"
 
diff -urNp Kernel/drivers/cpufreq/Makefile HelloWorld-Renew-v1.0-n7000-jb/drivers/cpufreq/Makefile
--- Kernel/drivers/cpufreq/Makefile	2013-02-20 13:36:19.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/drivers/cpufreq/Makefile	2013-05-01 10:13:20.333086622 +0200
@@ -13,6 +13,11 @@ obj-$(CONFIG_CPU_FREQ_GOV_CONSERVATIVE)
 obj-$(CONFIG_CPU_FREQ_GOV_INTERACTIVE)	+= cpufreq_interactive.o
 obj-$(CONFIG_CPU_FREQ_GOV_ADAPTIVE)	+= cpufreq_adaptive.o
 obj-$(CONFIG_CPU_FREQ_GOV_PEGASUSQ)	+= cpufreq_pegasusq.o
+obj-$(CONFIG_CPU_FREQ_GOV_HYPER)        += cpufreq_HYPER.o
+obj-$(CONFIG_CPU_FREQ_GOV_LULZACTIVE)	+= cpufreq_lulzactive.o
+obj-$(CONFIG_CPU_FREQ_GOV_SMARTASS) 	+= cpufreq_smartass.o
+obj-$(CONFIG_CPU_FREQ_GOV_SMARTASS2)	+= cpufreq_smartass2.o
+obj-$(CONFIG_CPU_FREQ_GOV_LAGFREE)	+= cpufreq_lagfree.o
 
 # CPUfreq cross-arch helpers
 obj-$(CONFIG_CPU_FREQ_TABLE)		+= freq_table.o
diff -urNp Kernel/drivers/j4fs/fsd_common.c HelloWorld-Renew-v1.0-n7000-jb/drivers/j4fs/fsd_common.c
--- Kernel/drivers/j4fs/fsd_common.c	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/drivers/j4fs/fsd_common.c	2013-04-29 16:41:35.142587461 +0200
@@ -0,0 +1,2063 @@
+/*
+ * This software is the confidential and proprietary information
+ * of Samsung Electronics, Inc. ("Confidential Information").  You
+ * shall not disclose such Confidential Information and shall use
+ * it only in accordance with the terms of the license agreement
+ * you entered into with Samsung.
+ */
+/*
+ * Copyright (C) 2008, 2009,  Samsung Electronics Co. Ltd. All Rights Reserved.
+ *       Written by Linux Lab, MITs Development Team, Mobile Communication Division.
+ */
+
+/*
+ * fsd_common.c
+ *
+ * File System Driver
+ *
+ *
+ * 2009.02 - First editing by SungHwan.yun <sunghwan.yun@samsung.com> @LDK@
+ *
+ * 2009.03 - Currently managed by  SungHwan.yun <sunghwan.yun@samsung.com> @LDK@
+ *
+ */
+#include <linux/slab.h>
+#include "j4fs.h"
+
+#ifndef __KERNEL__
+#include <asm/util.h>
+#endif
+
+j4fs_device_info device_info;
+unsigned int j4fs_traceMask=0;
+unsigned int j4fs_PORMask=0;
+unsigned int j4fs_PORCount=0;
+unsigned int j4fs_rw_start=0;
+j4fs_header ro_j4fs_header[J4FS_MAX_RO_FILES_NUMBER];
+int ro_j4fs_header_count=0;
+int j4fs_panic=0;
+
+#ifdef J4FS_TRANSACTION_LOGGING
+unsigned int j4fs_next_sequence=0;
+unsigned int j4fs_transaction_next_offset=0xffffffff;
+#endif
+
+int is_invalid_j4fs_rw_start()
+{
+	if((j4fs_rw_start<device_info.j4fs_offset) ||(j4fs_rw_start>= device_info.j4fs_end) ||
+		(ro_j4fs_header_count>=2 &&  ((ro_j4fs_header[ro_j4fs_header_count-2].link+ro_j4fs_header[ro_j4fs_header_count-1].length)>j4fs_rw_start)) ||
+		(ro_j4fs_header_count==1 && ((device_info.j4fs_offset+ro_j4fs_header[ro_j4fs_header_count-1].length)>j4fs_rw_start)))
+		return 1;
+	else return 0;
+}
+
+/*
+  * This function reads count number of bytes from the file specified by device, type, and ID and places them into 'buffer'.
+  * The file must be opened with the OPEN_READ option. The file read begins at the location of the last read or whatever file offset the special seek option set.
+  * If during the process there is a failure, the actual field indicates how many bytes were transferred and the status will contain a descriptive error code.
+  * parameters :
+  *   j4fs_ctrl->buffer
+  *   j4fs_ctrl->count
+  *   j4fs_ctrl->id
+  *   j4fs_ctrl->index
+  * return
+  *
+  */
+int fsd_read(j4fs_ctrl *ctl)
+{
+	DWORD offset, matching_offset=0xffffffff, len, count, file_length=0xffffffff;
+	int ret=-1;
+	j4fs_header *header;
+	int file_exist=0, i;
+
+#ifdef __KERNEL__
+	BYTE *buf;
+	buf=kmalloc(J4FS_BASIC_UNIT_SIZE,GFP_NOFS);
+#else
+	BYTE buf[J4FS_BASIC_UNIT_SIZE];
+#endif
+
+	T(J4FS_TRACE_FSD,("%s %d\n",__FUNCTION__,__LINE__));
+
+	for(i=0;i<ro_j4fs_header_count;i++)
+	{
+		header = &ro_j4fs_header[i];
+
+		//This j4fs_header cannot be interpreted.
+		if(header->type!=J4FS_FILE_TYPE)
+		{
+			j4fs_panic("This j4fs_header cannot be interpreted. So this j4fs partition is crashed by some abnormal cause.  This should not happen and should be repaired.");
+			goto error1;
+		}
+
+		// This RO file was deleted and RO file should not be deleted. So this j4fs partition is crashed by some abnormal cause.
+		if((header->flags&0x1)!=((header->flags&0x2)>>1))
+		{
+			j4fs_panic("This RO file was deleted and RO file should not be deleted. So this j4fs partition is crashed by some abnormal cause.  This should be repaired.");
+			goto error1;
+		}
+
+		// File ID is dismatched, so read next file.
+		if(ctl->id && ctl->id!=header->id)
+		{
+			continue;
+		}
+
+		// File ID(inode number) is matched
+		#ifdef __KERNEL__
+		if( ((ctl->index + ctl->count + PAGE_SIZE-1)/PAGE_SIZE*PAGE_SIZE)
+			<= ((header->length + PAGE_SIZE-1)/PAGE_SIZE*PAGE_SIZE) )
+		#else
+		if( ((ctl->index + ctl->count + J4FS_BASIC_UNIT_SIZE-1)/J4FS_BASIC_UNIT_SIZE*J4FS_BASIC_UNIT_SIZE)
+			<= ((header->length + J4FS_BASIC_UNIT_SIZE-1)/J4FS_BASIC_UNIT_SIZE*J4FS_BASIC_UNIT_SIZE) )
+		#endif
+		{
+			matching_offset=(i>0)?ro_j4fs_header[i-1].link:device_info.j4fs_offset;
+			file_length=header->length;
+		}
+		else file_exist=1;
+
+		goto got_header;
+
+	}
+
+	if(is_invalid_j4fs_rw_start())
+	{
+		T(J4FS_TRACE_ALWAYS,("%s %d: Error! j4fs_rw_start is invalid(j4fs_rw_start=0x%08x, j4fs_end=0x%08x, ro_j4fs_header_count=0x%08x)\n",
+			__FUNCTION__, __LINE__, j4fs_rw_start, device_info.j4fs_end, ro_j4fs_header_count));
+		j4fs_panic("j4fs_rw_start is invalid");
+		goto error1;
+	}
+
+	// the start address of the RW area of the device (partition)
+	offset=j4fs_rw_start;
+
+	// find object header corresponding to ctl.id in RW area of the device (partition)
+	while(offset!=0xffffffff)
+	{
+		// check the partition range
+		j4fs_check_partition_range(offset);
+
+		// read j4fs_header
+		ret = FlashDevRead(&device_info, offset, J4FS_BASIC_UNIT_SIZE, buf);
+		if (error(ret)) {
+			T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+			goto error1;
+		}
+		header=(j4fs_header *)buf;
+
+		//This j4fs_header cannot be interpreted. It means there are no RW files in this partition(this can happen and this is a normal case) or
+		//this j4fs partition is crashed(this should not happen).
+		if(header->type!=J4FS_FILE_TYPE)
+		{
+			// There are no RW files in this partition and this can happen and this is a normal case.
+			if(offset==j4fs_rw_start) {
+				memset(ctl->buffer,0xff,ctl->count);
+				goto error1;
+			}
+
+			// This j4fs partition is crashed by some abnormal cause. This should not happen and should be repaired.
+			j4fs_panic("this j4fs partition is crashed by some abnormal cause.  This should not happen and should be repaired.");
+			goto error1;
+		}
+
+		// This file was deleted, so read next j4fs_header.
+		if((header->flags&0x1)!=((header->flags&0x2)>>1))
+		{
+			offset=header->link;
+			continue;
+		}
+
+		// File ID is dismatched, so read next file.
+		if(ctl->id && ctl->id!=header->id)
+		{
+			offset=header->link;
+			continue;
+		}
+
+		// File ID is matched. we should read lastest object larger than ctl.index, so go ahead.
+		#ifdef __KERNEL__
+		if( ((ctl->index + ctl->count + PAGE_SIZE-1)/PAGE_SIZE*PAGE_SIZE)
+			<= ((header->length + PAGE_SIZE-1)/PAGE_SIZE*PAGE_SIZE) )
+		#else
+		if( ((ctl->index + ctl->count + J4FS_BASIC_UNIT_SIZE-1)/J4FS_BASIC_UNIT_SIZE*J4FS_BASIC_UNIT_SIZE)
+			<= ((header->length + J4FS_BASIC_UNIT_SIZE-1)/J4FS_BASIC_UNIT_SIZE*J4FS_BASIC_UNIT_SIZE) )
+		#endif
+		{
+			matching_offset=offset;
+			file_length=header->length;
+		}
+		else file_exist=1;
+
+		offset=header->link;
+	}
+
+got_header:
+
+	//There is valid objects coressponding to ctl->id
+	if(matching_offset!=0xffffffff)
+	{
+		T(J4FS_TRACE_FSD,("%s %d\n",__FUNCTION__,__LINE__));
+
+		// We found the wanted file above. Read the data
+		matching_offset+=J4FS_BASIC_UNIT_SIZE;	// j4fs_header takes J4FS_BASIC_UNIT_SIZE
+		matching_offset+=ctl->index;	// consider offset
+		if(ctl->count==0) len=file_length;
+		else len=ctl->count;
+		if(len>file_length) len=file_length;
+		count=0;
+
+		// read data per page size
+		while(len>=device_info.pagesize)
+		{
+			T(J4FS_TRACE_FSD,("%s %d: (offset,count,len)=(0x%08x,%d,%d)\n",__FUNCTION__,__LINE__,matching_offset,count,len));
+
+			ret = FlashDevRead(&device_info, matching_offset, device_info.pagesize, ctl->buffer+count);
+
+			if (error(ret)) {
+				T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+				goto error1;
+			}
+			count+=device_info.pagesize;
+			matching_offset+=device_info.pagesize;
+			len-=device_info.pagesize;
+		}
+
+		// read data less than one page and larger than sector
+		if(len>=512)
+		{
+			T(J4FS_TRACE_FSD,("%s %d: (offset,count,len)=(0x%08x,%d,%d)\n",__FUNCTION__,__LINE__,matching_offset,count,len));
+
+			ret = FlashDevRead(&device_info, matching_offset, len/512*512, ctl->buffer+count);
+
+			if (error(ret)) {
+				T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+				goto error1;
+			}
+			count+=(len/512*512);
+			matching_offset+=(len/512*512);
+			len-=(len/512*512);
+		}
+
+		// read remained data less than sector size(512Bytes)
+		if(len>0)
+		{
+			T(J4FS_TRACE_FSD,("%s %d: (offset,count,len)=(0x%08x,%d,%d)\n",__FUNCTION__,__LINE__,matching_offset,count,len));
+
+			ret = FlashDevRead(&device_info, matching_offset, 512, buf);
+
+			if (error(ret)) {
+				T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+				goto error1;
+			}
+
+			memcpy(ctl->buffer+count, buf, len);
+			count+=len;
+			len=0;
+		}
+
+	#ifdef __KERNEL__
+		kfree(buf);
+	#endif
+		return count;
+	}
+	else//There is no valid object coressponding to ctl->filename.
+	{
+		memset(ctl->buffer,0xff,ctl->count);
+	#ifdef __KERNEL__
+		kfree(buf);
+	#endif
+		if(file_exist) return ctl->count;
+		return J4FS_NO_FILE;
+	}
+
+error1:
+#ifdef __KERNEL__
+	kfree(buf);
+#endif
+	return J4FS_FAIL;
+}
+
+/*
+  * This function writes count number of bytes from buffer to the file specified by device, type, and ID. The file must be opened with
+  * the OPEN_CREATE option. If during the process there is a failure, the actual field indicates how many bytes were transferred and the status
+  * will contain a descriptive error code. The file write begins at the location of the last write.
+  * parameters :
+  *   j4fs_ctrl->buffer
+  *   j4fs_ctrl->count
+  *   j4fs_ctrl->id
+  *   j4fs_ctrl->index
+  */
+int fsd_write(j4fs_ctrl *ctl)
+{
+	DWORD offset, last_object_offset=0xffffffff, last_object_length=0xffffffff, matching_latest_object_length=0xffffffff, buffer_index=0, len1, len2;
+	DWORD matching_latest_offset=0xffffffff, new_header_offset=0xffffffff, is_it_last_object=0;
+	j4fs_header *header = 0;
+	int ret=-1;
+#ifdef J4FS_TRANSACTION_LOGGING
+	j4fs_transaction *transaction;
+#endif
+#ifdef __KERNEL__
+	BYTE *buf;
+	buf=kmalloc(J4FS_BASIC_UNIT_SIZE,GFP_NOFS);
+#else
+	BYTE buf[J4FS_BASIC_UNIT_SIZE];
+#endif
+
+#ifdef J4FS_TRANSACTION_LOGGING
+#ifdef __KERNEL__
+	transaction=kmalloc(J4FS_TRANSACTION_SIZE,GFP_NOFS);
+#else
+	BYTE buf1[J4FS_TRANSACTION_SIZE];
+	transaction=(j4fs_transaction *)buf1;
+#endif
+#endif
+
+	T(J4FS_TRACE_FSD,("%s %d: (ino,index)=(%d,0x%08x)\n",__FUNCTION__,__LINE__,ctl->id,ctl->index));
+
+	if(is_invalid_j4fs_rw_start())
+	{
+		T(J4FS_TRACE_ALWAYS,("%s %d: Error! j4fs_rw_start is invalid(j4fs_rw_start=0x%08x, j4fs_end=0x%08x, ro_j4fs_header_count=0x%08x)\n",
+			__FUNCTION__, __LINE__, j4fs_rw_start, device_info.j4fs_end, ro_j4fs_header_count));
+		j4fs_panic("j4fs_rw_start is invalid");
+		goto error1;
+	}
+
+	// parameter checking
+	if(ctl->index < 0)
+	{
+		T(J4FS_TRACE_ALWAYS,("%s %d: Error! ctl->index is invalid(ctl->index=0x%08x)\n",
+			__FUNCTION__, __LINE__, ctl->index));
+		j4fs_panic("ctl->index is invalid");
+		goto error1;
+	}
+
+	if(ctl->count==0)
+	{
+		T(J4FS_TRACE_ALWAYS,("%s %d: count is zero\n",__FUNCTION__, __LINE__));
+	#ifdef __KERNEL__
+		kfree(buf);
+	#ifdef J4FS_TRANSACTION_LOGGING
+		kfree(transaction);
+	#endif
+	#endif
+		return J4FS_SUCCESS;
+	}
+
+#ifdef J4FS_TRANSACTION_LOGGING
+	// setting transaction variable
+	memset(transaction,0xff,J4FS_TRANSACTION_SIZE);
+	transaction->count=ctl->count;
+	transaction->index=ctl->index;
+	transaction->magic=J4FS_MAGIC;
+#endif
+
+	// the start address of the RW area of the device (partition)
+	offset=j4fs_rw_start;
+
+	// find space(offset) to write this file. offset follows last enry(last_offset,j4fs_header.link==0xffffffff) in the device
+	while(offset!=0xffffffff)
+	{
+		// check the partition range
+		j4fs_check_partition_range(offset);
+
+		// read j4fs_header
+		ret = FlashDevRead(&device_info, offset, J4FS_BASIC_UNIT_SIZE, buf);
+		if (error(ret)) {
+			T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+			goto error1;
+		}
+		header=(j4fs_header *)buf;
+
+		//This j4fs_header cannot be interpreted. It means there are no RW files in this partition(this can happen and this is a normal case) or
+		//this j4fs partition is crashed(this should not happen).
+		if(header->type!=J4FS_FILE_TYPE)
+		{
+			// There are no RW files in this partition or this first j4fs_header is crashed. Before we write data of new file, user of j4fs should write j4fs_header of new file.
+			// So, this case should not happen and/or should be repaired.
+			if(offset==j4fs_rw_start) {
+				j4fs_panic("There are no RW files in this partition or this first RW j4fs_header is crashed. Before we write data of new file, user of j4fs should write j4fs_header of new file. So, this case should not happen and/or should be repaired..");
+				goto error1;
+			}
+
+			// This j4fs partition is crashed by some abnormal cause. This should not happen and should be repaired.
+			j4fs_panic("this j4fs partition is crashed by some abnormal cause.  This should not happen and should be repaired.");
+			goto error1;
+		}
+
+		if(header->link==0xffffffff) last_object_offset=offset;
+
+		// we find ID-matching valid file. Because we should find latest file, go ahead.
+		if((ctl->id==header->id) && ((header->flags&0x1)==((header->flags&0x2)>>1))) matching_latest_offset = offset;
+
+		offset=header->link;
+	}
+
+	// There is no RW files with 'ctl->id' inode number in this partition. Before we write data of new file, user of j4fs should write j4fs_header of new file.
+	if( (matching_latest_offset<j4fs_rw_start) ||(matching_latest_offset>device_info.j4fs_end) ) {
+		T(J4FS_TRACE_ALWAYS,("%s %d: matching_latest_offset is invalid(matching_latest_offset=0x%08x)\n",__FUNCTION__,__LINE__,matching_latest_offset));
+		j4fs_panic("There are no RW files in this partition. Before we write data of new file, user of j4fs should write j4fs_header of new file.");
+		goto error1;
+	}
+
+	// last_object_offset is invalid. last_object_offset should be between j4fs_rw_start and device_info.j4fs_end
+	if( (last_object_offset<j4fs_rw_start) ||(last_object_offset>device_info.j4fs_end) ) {
+		T(J4FS_TRACE_ALWAYS,("%s %d: last_object_offset is invalid(last_object_offset=0x%08x)\n",__FUNCTION__,__LINE__,last_object_offset));
+		j4fs_panic("last_object_offset is invalid. last_object_offset should be between j4fs_rw_start and device_info.j4fs_end");
+		goto error1;
+	}
+
+	if(matching_latest_offset==last_object_offset) is_it_last_object=1;
+	else is_it_last_object=0;
+
+	// when this is a last object in partition (2,3,5,6,8)
+	if(is_it_last_object)
+	{
+		// the length of file which resides at last_object_offset(=matching_latest_offset)
+		matching_latest_object_length=header->length;
+
+		if(matching_latest_object_length < ctl->index)		// j4fs don't support file hole
+		{
+			T(J4FS_TRACE_ALWAYS,("%s %d: j4fs don't support file hole(matching_latest_object_length,ctl->index)=(0x%08x,0x%08x)\n",__FUNCTION__,__LINE__,matching_latest_object_length,ctl->index));
+			j4fs_panic("j4fs don't support file hole");
+			goto error1;
+		}
+		else if(matching_latest_object_length == ctl->index)	// when extend file size(2,3,5,6)
+		{
+			buffer_index=0;
+			offset=matching_latest_offset;
+			offset+=J4FS_BASIC_UNIT_SIZE;	// header
+			offset+=ctl->index;				// data
+
+			// check whether we should reclaim
+			if((offset+ctl->count)>device_info.j4fs_end)
+			{
+				T(J4FS_TRACE_ALWAYS,("%s %d: Reclaim is needed(offset,ctl->count,j4fs_end)=(0x%08x,0x%08x,0x%08x)\n",__FUNCTION__,__LINE__,offset,ctl->count,device_info.j4fs_end));
+				ret=fsd_reclaim();
+
+				if (error(ret)) {
+					T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+
+			#ifdef __KERNEL__
+				kfree(buf);
+			#endif
+				return J4FS_RETRY_WRITE;
+			}
+
+			// write first J4FS_BASIC_UNIT_SIZE-not-aligned data to Storage
+			if(ctl->index % J4FS_BASIC_UNIT_SIZE)
+			{
+				len1 = ctl->index % J4FS_BASIC_UNIT_SIZE;
+				len2=J4FS_BASIC_UNIT_SIZE-len1;
+				if(len2 > ctl->count) len2=ctl->count;
+
+				// read len1'length' data from Stroage
+				ret = FlashDevRead(&device_info, offset-len1, (len1+511)/512*512, buf);
+				if (error(ret)) {
+					T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+				memcpy(buf+len1, ctl->buffer, len2);
+
+				// write (len1+len2)'length' data to Stroage
+				ret = FlashDevWrite(&device_info, offset-len1, (len1+len2+511)/512*512, buf);
+				if (error(ret)) {
+					T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+
+				buffer_index += len2;
+				offset += len2;
+				ctl->count -= len2;
+			}
+
+			// write data per page size
+			while(ctl->count>=device_info.pagesize)
+			{
+				ret = FlashDevWrite(&device_info, offset, device_info.pagesize, ctl->buffer+buffer_index);
+
+				T(J4FS_TRACE_FSD,("%s %d: (buffer_index,offset,ctl->count)=(0x%08x,%d,%d)\n",__FUNCTION__,__LINE__,buffer_index,offset,ctl->count));
+
+				if (error(ret)) {
+					T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+				buffer_index+=device_info.pagesize;
+				offset+=device_info.pagesize;
+				ctl->count-=device_info.pagesize;
+			}
+
+			// write data less than one page and larger than sector
+			if(ctl->count>=512)
+			{
+				ret = FlashDevWrite(&device_info, offset, ctl->count/512*512, ctl->buffer+buffer_index);
+
+				T(J4FS_TRACE_FSD,("%s %d: (buffer_index,offset,ctl->count)=(0x%08x,%d,%d)\n",__FUNCTION__,__LINE__,buffer_index,offset,ctl->count));
+
+				if (error(ret)) {
+					T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+				buffer_index+=(ctl->count/512*512);
+				offset+=(ctl->count/512*512);
+				ctl->count-=(ctl->count/512*512);
+			}
+
+			// write remained data less than sector size(512Bytes)
+			if(ctl->count>0)
+			{
+				memcpy(buf, ctl->buffer+buffer_index, ctl->count);
+				ret = FlashDevWrite(&device_info, offset, 512, buf);
+
+				T(J4FS_TRACE_FSD,("%s %d: (buffer_index,offset,ctl->count)=(0x%08x,%d,%d)\n",__FUNCTION__,__LINE__,buffer_index,offset,ctl->count));
+
+				if (error(ret)) {
+					T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+
+				buffer_index+=ctl->count;
+				offset+=ctl->count;
+				ctl->count=0;
+			}
+
+			// update existing j4fs_header to extend file size
+			// read j4fs_header
+			ret = FlashDevRead(&device_info, matching_latest_offset, J4FS_BASIC_UNIT_SIZE, buf);
+			if (error(ret)) {
+				T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+				goto error1;
+			}
+			header=(j4fs_header *)buf;
+
+		#ifdef J4FS_TRANSACTION_LOGGING
+			// setting transaction variable
+			transaction->sequence=j4fs_next_sequence++;
+			transaction->ino=header->id;
+			strcpy(transaction->filename,header->filename);
+			transaction->opcode=J4FS_LAST_OBJECT_WRITE_EXTEND1;
+			transaction->offset=matching_latest_offset;
+			transaction->b_link=transaction->a_link=header->link;
+			transaction->b_length=header->length;
+			transaction->a_length=header->length+buffer_index;
+
+			ret = FlashDevWrite(&device_info, j4fs_transaction_next_offset, J4FS_TRANSACTION_SIZE, (BYTE *)transaction);
+
+			if (error(ret)) {
+				T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+				goto error1;
+			}
+
+			j4fs_transaction_next_offset+=J4FS_TRANSACTION_SIZE;
+			if(j4fs_transaction_next_offset>=device_info.j4fs_device_end) j4fs_transaction_next_offset=device_info.j4fs_end;
+		#endif
+
+			// update file length
+			header->length += buffer_index;
+
+			ret = FlashDevWrite(&device_info, matching_latest_offset, J4FS_BASIC_UNIT_SIZE, buf);
+
+			if (error(ret)) {
+				T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+				goto error1;
+			}
+
+			goto done;
+		}
+		else if(matching_latest_object_length > ctl->index)	// when update existing data(8)
+		{
+			buffer_index=0;
+			offset=matching_latest_offset;
+			offset+=J4FS_BASIC_UNIT_SIZE;	// header
+			offset+=ctl->index;				// data
+
+			// check whether we should reclaim
+			if((offset+ctl->count)>device_info.j4fs_end)
+			{
+				T(J4FS_TRACE_ALWAYS,("%s %d: Reclaim is needed(offset,ctl->count,j4fs_end)=(0x%08x,0x%08x,0x%08x)\n",__FUNCTION__,__LINE__,offset,ctl->count,device_info.j4fs_end));
+				ret=fsd_reclaim();
+
+				if (error(ret)) {
+					T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+
+			#ifdef __KERNEL__
+				kfree(buf);
+			#ifdef J4FS_TRANSACTION_LOGGING
+				kfree(transaction);
+			#endif
+			#endif
+				return J4FS_RETRY_WRITE;
+			}
+
+			// write first J4FS_BASIC_UNIT_SIZE-not-aligned data to Storage
+			if(ctl->index % J4FS_BASIC_UNIT_SIZE)
+			{
+				len1 = ctl->index % J4FS_BASIC_UNIT_SIZE;
+				len2=J4FS_BASIC_UNIT_SIZE-len1;
+				if(len2 > ctl->count) len2=ctl->count;
+
+				// read len1'length' data from Stroage
+				ret = FlashDevRead(&device_info, offset-len1, (len1+511)/512*512, buf);
+				if (error(ret)) {
+					T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+				memcpy(buf+len1, ctl->buffer, len2);
+
+				// write (len1+len2)'length' data to Stroage
+				ret = FlashDevWrite(&device_info, offset-len1, (len1+len2+511)/512*512, buf);
+				if (error(ret)) {
+					T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+
+				buffer_index += len2;
+				offset += len2;
+				ctl->count -= len2;
+			}
+
+			// write data per page size
+			while(ctl->count>=device_info.pagesize)
+			{
+				ret = FlashDevWrite(&device_info, offset, device_info.pagesize, ctl->buffer+buffer_index);
+
+				T(J4FS_TRACE_FSD,("%s %d: (buffer_index,offset,ctl->count)=(0x%08x,%d,%d)\n",__FUNCTION__,__LINE__,buffer_index,offset,ctl->count));
+
+				if (error(ret)) {
+					T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+				buffer_index+=device_info.pagesize;
+				offset+=device_info.pagesize;
+				ctl->count-=device_info.pagesize;
+			}
+
+			// write data less than one page and larger than sector
+			if(ctl->count>=512)
+			{
+				ret = FlashDevWrite(&device_info, offset, ctl->count/512*512, ctl->buffer+buffer_index);
+
+				T(J4FS_TRACE_FSD,("%s %d: (buffer_index,offset,ctl->count)=(0x%08x,%d,%d)\n",__FUNCTION__,__LINE__,buffer_index,offset,ctl->count));
+
+				if (error(ret)) {
+					T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+				buffer_index+=(ctl->count/512*512);
+				offset+=(ctl->count/512*512);
+				ctl->count-=(ctl->count/512*512);
+			}
+
+			// write remained data less than sector size(512Bytes)
+			if(ctl->count>0)
+			{
+				// read 512B'length' data from Stroage
+				ret = FlashDevRead(&device_info, offset, 512, buf);
+				if (error(ret)) {
+					T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+
+				memcpy(buf, ctl->buffer+buffer_index, ctl->count);
+				ret = FlashDevWrite(&device_info, offset, 512, buf);
+
+				T(J4FS_TRACE_FSD,("%s %d: (buffer_index,offset,ctl->count)=(0x%08x,%d,%d)\n",__FUNCTION__,__LINE__,buffer_index,offset,ctl->count));
+
+				if (error(ret)) {
+					T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+
+				buffer_index+=ctl->count;
+				offset+=ctl->count;
+				ctl->count=0;
+			}
+
+			// update existing j4fs_header to update file size if needed
+			if((offset-matching_latest_offset-J4FS_BASIC_UNIT_SIZE) > matching_latest_object_length)
+			{
+				// read j4fs_header
+				ret = FlashDevRead(&device_info, matching_latest_offset, J4FS_BASIC_UNIT_SIZE, buf);
+				if (error(ret)) {
+					T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+				header=(j4fs_header *)buf;
+
+			#ifdef J4FS_TRANSACTION_LOGGING
+				// setting transaction variable
+				transaction->sequence=j4fs_next_sequence++;
+				transaction->ino=header->id;
+				strcpy(transaction->filename,header->filename);
+				transaction->opcode=J4FS_LAST_OBJECT_WRITE_EXTEND2;
+				transaction->offset=matching_latest_offset;
+				transaction->b_link=transaction->a_link=header->link;
+				transaction->b_length=header->length;
+				transaction->a_length=offset-matching_latest_offset-J4FS_BASIC_UNIT_SIZE;
+
+				ret = FlashDevWrite(&device_info, j4fs_transaction_next_offset, J4FS_TRANSACTION_SIZE, (BYTE *)transaction);
+
+				if (error(ret)) {
+					T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+
+				j4fs_transaction_next_offset+=J4FS_TRANSACTION_SIZE;
+				if(j4fs_transaction_next_offset>=device_info.j4fs_device_end) j4fs_transaction_next_offset=device_info.j4fs_end;
+			#endif
+
+				header->length = offset-matching_latest_offset-J4FS_BASIC_UNIT_SIZE;
+				ret = FlashDevWrite(&device_info, matching_latest_offset, J4FS_BASIC_UNIT_SIZE, buf);
+
+				if (error(ret)) {
+					T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+			}
+			goto done;
+		}
+		else
+		{
+			T(J4FS_TRACE_ALWAYS,("%s %d: we should not come here\n",__FUNCTION__,__LINE__));
+			j4fs_panic("we should not come here");
+			goto error1;
+		}
+	}
+	else if(!is_it_last_object)
+	{
+		// the length of file which resides at last_object_offset
+		last_object_length = header->length;
+
+		// read j4fs_header
+		ret = FlashDevRead(&device_info, matching_latest_offset, J4FS_BASIC_UNIT_SIZE, buf);
+		if (error(ret)) {
+			T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+			goto error1;
+		}
+		header=(j4fs_header *)buf;
+		matching_latest_object_length=header->length;
+
+		if(matching_latest_object_length < ctl->index)		// j4fs don't support file hole
+		{
+			T(J4FS_TRACE_ALWAYS,("%s %d: j4fs don't support file hole(matching_latest_object_length,ctl->index)=(0x%08x,0x%08x)\n",__FUNCTION__,__LINE__,matching_latest_object_length,ctl->index));
+			j4fs_panic("j4fs don't support file hole");
+			goto error1;
+		}
+		else if(matching_latest_object_length >= (ctl->index+ctl->count))	// update not-last object in partition and No extension(7)
+		{
+			buffer_index=0;
+			offset=matching_latest_offset;
+			offset+=J4FS_BASIC_UNIT_SIZE;	// header
+			offset+=ctl->index;				// data
+
+			// check whether we should reclaim
+			if((offset+ctl->count)>device_info.j4fs_end)
+			{
+				T(J4FS_TRACE_ALWAYS,("%s %d: This case should not happen(offset,ctl->count,j4fs_end)=(0x%08x,0x%08x,0x%08x)\n",__FUNCTION__,__LINE__,offset,ctl->count,device_info.j4fs_end));
+				j4fs_panic("This case should not happen");
+				goto error1;
+			}
+
+			// write first J4FS_BASIC_UNIT_SIZE-not-aligned data to Storage
+			if(ctl->index % J4FS_BASIC_UNIT_SIZE)
+			{
+				len1 = ctl->index % J4FS_BASIC_UNIT_SIZE;
+				len2=J4FS_BASIC_UNIT_SIZE-len1;
+				if(len2 > ctl->count) len2=ctl->count;
+
+				// read len1'length' data from Stroage
+				ret = FlashDevRead(&device_info, offset-len1, (len1+511)/512*512, buf);
+				if (error(ret)) {
+					T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+				memcpy(buf+len1, ctl->buffer, len2);
+
+				// write (len1+len2)'length' data to Stroage
+				ret = FlashDevWrite(&device_info, offset-len1, (len1+len2+511)/512*512, buf);
+				if (error(ret)) {
+					T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+
+				buffer_index += len2;
+				offset += len2;
+				ctl->count -= len2;
+			}
+
+			// write data per page size
+			while(ctl->count>=device_info.pagesize)
+			{
+				ret = FlashDevWrite(&device_info, offset, device_info.pagesize, ctl->buffer+buffer_index);
+
+				T(J4FS_TRACE_FSD,("%s %d: (buffer_index,offset,ctl->count)=(0x%08x,%d,%d)\n",__FUNCTION__,__LINE__,buffer_index,offset,ctl->count));
+
+				if (error(ret)) {
+					T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+				buffer_index+=device_info.pagesize;
+				offset+=device_info.pagesize;
+				ctl->count-=device_info.pagesize;
+			}
+
+			// write data less than one page and larger than sector
+			if(ctl->count>=512)
+			{
+				ret = FlashDevWrite(&device_info, offset, ctl->count/512*512, ctl->buffer+buffer_index);
+
+				T(J4FS_TRACE_FSD,("%s %d: (buffer_index,offset,ctl->count)=(0x%08x,%d,%d)\n",__FUNCTION__,__LINE__,buffer_index,offset,ctl->count));
+
+				if (error(ret)) {
+					T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+				buffer_index+=(ctl->count/512*512);
+				offset+=(ctl->count/512*512);
+				ctl->count-=(ctl->count/512*512);
+			}
+
+			// write remained data less than sector size(512Bytes)
+			if(ctl->count>0)
+			{
+				T(J4FS_TRACE_FSD,("%s %d: (buffer_index,offset,ctl->count)=(0x%08x,%d,%d)\n",__FUNCTION__,__LINE__,buffer_index,offset,ctl->count));
+
+				// read 512B'length' data from Stroage
+				ret = FlashDevRead(&device_info, offset, 512, buf);
+				if (error(ret)) {
+					T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+
+				memcpy(buf, ctl->buffer+buffer_index, ctl->count);
+				ret = FlashDevWrite(&device_info, offset, 512, buf);
+
+				if (error(ret)) {
+					T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+
+				buffer_index+=ctl->count;
+				offset+=ctl->count;
+				ctl->count=0;
+			}
+
+			goto done;
+		}
+		else if(matching_latest_object_length < (ctl->index+ctl->count))	// update not-last object in partition and file size is extended(9,11,12,13)
+		{
+			new_header_offset=last_object_offset;
+			new_header_offset+=J4FS_BASIC_UNIT_SIZE;	// header
+			new_header_offset+=last_object_length;			// data
+			new_header_offset=(new_header_offset+J4FS_BASIC_UNIT_SIZE-1)/J4FS_BASIC_UNIT_SIZE*J4FS_BASIC_UNIT_SIZE;	// J4FS_BASIC_UNIT_SIZE Align
+
+			// copy existing 'all data' of 'matching_latest_offset' offset to 'new_header_offset' offset
+			len1=matching_latest_object_length;
+			len1=(len1+J4FS_BASIC_UNIT_SIZE-1)/J4FS_BASIC_UNIT_SIZE*J4FS_BASIC_UNIT_SIZE;	// J4FS_BASIC_UNIT_SIZE Align
+			buffer_index=J4FS_BASIC_UNIT_SIZE;
+
+			// write data per J4FS_BASIC_UNIT_SIZE size
+			while(len1>=J4FS_BASIC_UNIT_SIZE)
+			{
+				T(J4FS_TRACE_FSD,("%s %d: (matching_latest_offset,new_header_offset,buffer_index)=(0x%08x,0x%08x,0x%08x)\n",
+					__FUNCTION__,__LINE__,matching_latest_offset,new_header_offset,buffer_index));
+
+				ret = FlashDevRead(&device_info, matching_latest_offset+buffer_index, J4FS_BASIC_UNIT_SIZE, buf);
+
+				if (error(ret)) {
+					T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+
+				ret = FlashDevWrite(&device_info, new_header_offset+buffer_index, J4FS_BASIC_UNIT_SIZE, buf);
+
+				if (error(ret)) {
+					T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+
+				buffer_index+=J4FS_BASIC_UNIT_SIZE;
+				len1-=J4FS_BASIC_UNIT_SIZE;
+			}
+
+			if(len1!=0)
+			{
+				T(J4FS_TRACE_ALWAYS,("%s %d: This case should not happen(len1)=(0x%08x)\n",__FUNCTION__,__LINE__,len1));
+				j4fs_panic("This case should not happen");
+				goto error1;
+			}
+
+			// copy existing j4fs_header of 'matching_latest_offset' offset to 'new_header_offset' offset
+			T(J4FS_TRACE_FSD,("%s %d: (matching_latest_offset,new_header_offset)=(0x%08x,0x%08x)\n", __FUNCTION__,__LINE__,matching_latest_offset,new_header_offset));
+			ret = FlashDevRead(&device_info, matching_latest_offset, J4FS_BASIC_UNIT_SIZE, buf);
+			if (error(ret)) {
+				T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+				goto error1;
+			}
+			header=(j4fs_header *)buf;
+
+		#ifdef J4FS_TRANSACTION_LOGGING
+			// setting transaction variable
+			transaction->sequence=j4fs_next_sequence++;
+			transaction->ino=header->id;
+			strcpy(transaction->filename,header->filename);
+			transaction->opcode=J4FS_NOLAST_OBJECT_WRITE_EXTEND_STEP1;
+			transaction->offset=new_header_offset;
+			transaction->b_link=header->link;
+			transaction->a_link=0xffffffff;
+			transaction->b_length=transaction->a_length=header->length;
+
+			ret = FlashDevWrite(&device_info, j4fs_transaction_next_offset, J4FS_TRANSACTION_SIZE, (BYTE *)transaction);
+
+			if (error(ret)) {
+				T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+				goto error1;
+			}
+
+			j4fs_transaction_next_offset+=J4FS_TRANSACTION_SIZE;
+			if(j4fs_transaction_next_offset>=device_info.j4fs_device_end) j4fs_transaction_next_offset=device_info.j4fs_end;
+		#endif
+
+			header->link=0xffffffff;
+
+			ret = FlashDevWrite(&device_info, new_header_offset, J4FS_BASIC_UNIT_SIZE, buf);
+			if (error(ret)) {
+				T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+				goto error1;
+			}
+
+			// update the link of last_object_offset to indicate new_header_offset
+			// read j4fs_header
+			ret = FlashDevRead(&device_info, last_object_offset, J4FS_BASIC_UNIT_SIZE, buf);
+			if (error(ret)) {
+				T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+				goto error1;
+			}
+			header=(j4fs_header *)buf;
+
+		#ifdef J4FS_TRANSACTION_LOGGING
+			// setting transaction variable
+			transaction->sequence=j4fs_next_sequence++;
+			transaction->ino=header->id;
+			strcpy(transaction->filename,header->filename);
+			transaction->opcode=J4FS_NOLAST_OBJECT_WRITE_EXTEND_STEP2;
+			transaction->offset=last_object_offset;
+			transaction->b_link=header->link;
+			transaction->a_link=new_header_offset;
+			transaction->b_length=transaction->a_length=header->length;
+
+			ret = FlashDevWrite(&device_info, j4fs_transaction_next_offset, J4FS_TRANSACTION_SIZE, (BYTE *)transaction);
+
+			if (error(ret)) {
+				T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+				goto error1;
+			}
+
+			j4fs_transaction_next_offset+=J4FS_TRANSACTION_SIZE;
+			if(j4fs_transaction_next_offset>=device_info.j4fs_device_end) j4fs_transaction_next_offset=device_info.j4fs_end;
+		#endif
+
+			header->link= new_header_offset;
+			ret = FlashDevWrite(&device_info, last_object_offset, J4FS_BASIC_UNIT_SIZE, buf);
+
+			if (error(ret)) {
+				T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+				goto error1;
+			}
+
+			// write new data(file size is extended)
+			buffer_index=0;
+			offset=new_header_offset;
+			offset+=J4FS_BASIC_UNIT_SIZE;	// header
+			offset+=ctl->index;				// data
+
+			// check whether we should reclaim
+			if((offset+ctl->count)>device_info.j4fs_end)
+			{
+				T(J4FS_TRACE_ALWAYS,("%s %d: Reclaim is needed(offset,ctl->count,j4fs_end)=(0x%08x,0x%08x,0x%08x)\n",__FUNCTION__,__LINE__,offset,ctl->count,device_info.j4fs_end));
+				ret=fsd_reclaim();
+
+				if (error(ret)) {
+					T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+
+			#ifdef __KERNEL__
+				kfree(buf);
+			#endif
+				return J4FS_RETRY_WRITE;
+			}
+
+			// write first J4FS_BASIC_UNIT_SIZE-not-aligned data to Storage
+			if(ctl->index % J4FS_BASIC_UNIT_SIZE)
+			{
+				len1=ctl->index % J4FS_BASIC_UNIT_SIZE;
+				len2=J4FS_BASIC_UNIT_SIZE-len1;
+				if(len2 > ctl->count) len2=ctl->count;
+
+				// read len1'length' data from Stroage
+				ret = FlashDevRead(&device_info, offset-len1, (len1+511)/512*512, buf);
+				if (error(ret)) {
+					T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+				memcpy(buf+len1, ctl->buffer, len2);
+
+				// write (len1+len2)'length' data to Stroage
+				ret = FlashDevWrite(&device_info, offset-len1, (len1+len2+511)/512*512, buf);
+				if (error(ret)) {
+					T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+
+				buffer_index += len2;
+				offset += len2;
+				ctl->count -= len2;
+			}
+
+			// write data per page size
+			while(ctl->count>=device_info.pagesize)
+			{
+				ret = FlashDevWrite(&device_info, offset, device_info.pagesize, ctl->buffer+buffer_index);
+
+				T(J4FS_TRACE_FSD,("%s %d: (buffer_index,offset,ctl->count)=(0x%08x,%d,%d)\n",__FUNCTION__,__LINE__,buffer_index,offset,ctl->count));
+
+				if (error(ret)) {
+					T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+				buffer_index+=device_info.pagesize;
+				offset+=device_info.pagesize;
+				ctl->count-=device_info.pagesize;
+			}
+
+			// write data less than one page and larger than sector
+			if(ctl->count>=512)
+			{
+				ret = FlashDevWrite(&device_info, offset, ctl->count/512*512, ctl->buffer+buffer_index);
+
+				T(J4FS_TRACE_FSD,("%s %d: (buffer_index,offset,ctl->count)=(0x%08x,%d,%d)\n",__FUNCTION__,__LINE__,buffer_index,offset,ctl->count));
+
+				if (error(ret)) {
+					T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+				buffer_index+=(ctl->count/512*512);
+				offset+=(ctl->count/512*512);
+				ctl->count-=(ctl->count/512*512);
+			}
+
+			// write remained data less than sector size(512Bytes)
+			if(ctl->count>0)
+			{
+				memcpy(buf, ctl->buffer+buffer_index, ctl->count);
+				ret = FlashDevWrite(&device_info, offset, 512, buf);
+
+				T(J4FS_TRACE_FSD,("%s %d: (buffer_index,offset,ctl->count)=(0x%08x,%d,%d)\n",__FUNCTION__,__LINE__,buffer_index,offset,ctl->count));
+
+				if (error(ret)) {
+					T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+
+				buffer_index+=ctl->count;
+				offset+=ctl->count;
+				ctl->count=0;
+			}
+
+			// update new_header_offset to update file size extension
+			// read j4fs_header
+			ret = FlashDevRead(&device_info, new_header_offset, J4FS_BASIC_UNIT_SIZE, buf);
+			if (error(ret)) {
+				T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+				goto error1;
+			}
+			header=(j4fs_header *)buf;
+
+		#ifdef J4FS_TRANSACTION_LOGGING
+			// setting transaction variable
+			transaction->sequence=j4fs_next_sequence++;
+			transaction->ino=header->id;
+			strcpy(transaction->filename,header->filename);
+			transaction->opcode=J4FS_NOLAST_OBJECT_WRITE_EXTEND_STEP3;
+			transaction->offset=new_header_offset;
+			transaction->b_link=transaction->a_link=header->link;
+			transaction->b_length=header->length;
+			transaction->a_length=offset-new_header_offset-J4FS_BASIC_UNIT_SIZE;
+
+			ret = FlashDevWrite(&device_info, j4fs_transaction_next_offset, J4FS_TRANSACTION_SIZE, (BYTE *)transaction);
+
+			if (error(ret)) {
+				T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+				goto error1;
+			}
+
+			j4fs_transaction_next_offset+=J4FS_TRANSACTION_SIZE;
+			if(j4fs_transaction_next_offset>=device_info.j4fs_device_end) j4fs_transaction_next_offset=device_info.j4fs_end;
+		#endif
+
+			header->length = offset-new_header_offset-J4FS_BASIC_UNIT_SIZE;
+			ret = FlashDevWrite(&device_info, new_header_offset, J4FS_BASIC_UNIT_SIZE, buf);
+
+			if (error(ret)) {
+				T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+				goto error1;
+			}
+
+			goto done;
+		}
+		else
+		{
+			T(J4FS_TRACE_ALWAYS,("%s %d: we should not come here\n",__FUNCTION__,__LINE__));
+			j4fs_panic("we should not come here");
+			goto error1;
+		}
+	}
+	else
+	{
+		T(J4FS_TRACE_ALWAYS,("%s %d: we should not come here\n",__FUNCTION__,__LINE__));
+		j4fs_panic("we should not come here");
+		goto error1;
+	}
+
+done:
+	T(J4FS_TRACE_FSD,("%s %d: write completed(written=%d)\n",__FUNCTION__,__LINE__,buffer_index));
+
+	fsd_print_meta_data();
+
+#ifdef __KERNEL__
+	kfree(buf);
+#ifdef J4FS_TRANSACTION_LOGGING
+	kfree(transaction);
+#endif
+#endif
+	return buffer_index;
+
+error1:
+#ifdef __KERNEL__
+	kfree(buf);
+#ifdef J4FS_TRANSACTION_LOGGING
+	kfree(transaction);
+#endif
+#endif
+	return J4FS_FAIL;
+}
+
+int fsd_unlink(char *filename)
+{
+	DWORD offset;
+	j4fs_header *header;
+	int ret=-1;
+
+#ifdef __KERNEL__
+	BYTE *buf;
+	buf=kmalloc(J4FS_BASIC_UNIT_SIZE,GFP_NOFS);
+#else
+	BYTE buf[J4FS_BASIC_UNIT_SIZE];
+#endif
+
+	if(filename==NULL) {
+	#ifdef __KERNEL__
+		kfree(buf);
+	#endif
+		return 0;
+	}
+
+	if(is_invalid_j4fs_rw_start())
+	{
+		T(J4FS_TRACE_ALWAYS,("%s %d: Error! j4fs_rw_start is invalid(j4fs_rw_start=0x%08x, j4fs_end=0x%08x, ro_j4fs_header_count=0x%08x)\n",
+			__FUNCTION__, __LINE__, j4fs_rw_start, device_info.j4fs_end, ro_j4fs_header_count));
+		j4fs_panic("j4fs_rw_start is invalid");
+		goto error1;
+	}
+
+	// the start address of the RW area of the device (partition)
+	offset=j4fs_rw_start;
+
+	// find object header corresponding to filename
+	while(offset!=0xffffffff)
+	{
+		// read j4fs_header
+		ret = FlashDevRead(&device_info, offset, J4FS_BASIC_UNIT_SIZE, buf);
+		if (error(ret)) {
+			T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+			goto error1;
+		}
+		header=(j4fs_header *)buf;
+
+		//This j4fs_header cannot be interpreted. It means there are no RW files in this partition(this can happen and this is a normal case) or
+		//this j4fs partition is crashed(this should not happen).
+		if(header->type!=J4FS_FILE_TYPE)
+		{
+			// There are no RW files in this partition or this first j4fs_header is crashed. Before we write data of new file, user of j4fs should write j4fs_header of new file.
+			// So, this case should not happen and/or should be repaired.
+			if(offset==j4fs_rw_start) {
+				j4fs_panic("There are no RW files in this partition or this first RW j4fs_header is crashed. Before we write data of new file, user of j4fs should write j4fs_header of new file. So, this case should not happen and/or should be repaired..");
+				goto error1;
+			}
+
+			// This j4fs partition is crashed by some abnormal cause. This should not happen and should be repaired.
+			j4fs_panic("this j4fs partition is crashed by some abnormal cause.  This should not happen and should be repaired.");
+			goto error1;
+		}
+
+		// This file was deleted, so read next j4fs_header.
+		if((header->flags&0x1)!=((header->flags&0x2)>>1))
+		{
+			offset=header->link;
+			continue;
+		}
+
+		// filename is dismatched, so read next file.
+		if(strcmp(filename,header->filename))
+		{
+			offset=header->link;
+			continue;
+		}
+
+		// this file will be deleted
+		header->flags=0x1;
+
+		ret = FlashDevWrite(&device_info, offset, J4FS_BASIC_UNIT_SIZE, buf);
+		if (error(ret)) {
+			T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+			goto error1;
+		}
+
+		offset=header->link;
+	}
+
+	ret=fsd_reclaim();
+
+	if (error(ret)) {
+		T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+		goto error1;
+	}
+
+#ifdef __KERNEL__
+	kfree(buf);
+#endif
+	return 0;
+
+error1:
+#ifdef __KERNEL__
+	kfree(buf);
+#endif
+	return J4FS_FAIL;
+}
+
+/*
+  * This function will reclaim all unused space on the device specified. Reclaim removes file objects that have been marked deleted and
+  * relocates valid file objects to create the maximum contiguous free space
+  */
+int fsd_reclaim()
+{
+	DWORD offset, rw_start;
+	j4fs_mst *mst;
+	j4fs_header *header;
+	int i;
+	int ret=-1;
+	int first_unused_area_offset=0xffffffff;
+#ifdef J4FS_TRANSACTION_LOGGING
+	j4fs_transaction *transaction;
+#endif
+#ifdef __KERNEL__
+	BYTE *buf_mst, *buf_header, *buf_data;
+	buf_mst=kmalloc(J4FS_BASIC_UNIT_SIZE,GFP_NOFS);
+	buf_header=kmalloc(J4FS_BASIC_UNIT_SIZE,GFP_NOFS);
+	buf_data=kmalloc(J4FS_BASIC_UNIT_SIZE,GFP_NOFS);
+#else
+	BYTE buf_mst[J4FS_BASIC_UNIT_SIZE], buf_header[J4FS_BASIC_UNIT_SIZE], buf_data[J4FS_BASIC_UNIT_SIZE];
+#endif
+
+
+#ifdef J4FS_TRANSACTION_LOGGING
+#ifdef __KERNEL__
+	transaction=kmalloc(J4FS_TRANSACTION_SIZE,GFP_NOFS);
+#else
+	BYTE buf[J4FS_TRANSACTION_SIZE];
+	transaction=(j4fs_transaction *)buf;
+#endif
+#endif
+
+	header=(j4fs_header *)buf_header;
+	mst=(j4fs_mst *)buf_mst;
+
+	// read mst
+	ret = FlashDevRead(&device_info, 0, J4FS_BASIC_UNIT_SIZE, buf_mst);
+	if (error(ret)) {
+		T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+		goto error1;
+	}
+
+	// If MST is not recognized, Initialize MST
+	if(mst->magic!=J4FS_MAGIC)
+	{
+		T(J4FS_TRACE_ALWAYS,("%s %d: MST is not recognized(mst.magic=0x%08x)\n",__FUNCTION__,__LINE__,mst->magic));
+		j4fs_panic("MST is not recognized");
+		goto error1;
+	}
+
+	if((mst->status|J4FS_PANIC_MASK)==J4FS_PANIC)
+	{
+		T(J4FS_TRACE_ALWAYS,("%s %d: j4fs is crashed(mst.status=0x%08x)\n",__FUNCTION__,__LINE__,mst->status));
+		j4fs_panic("j4fs is crashed");
+		goto error1;
+	}
+
+	T(J4FS_TRACE_FSD_RECLAIM,("\n%s %d: Reclaim Starts\n",__FUNCTION__,__LINE__));
+	fsd_print_meta_data();
+
+	// If reclaim is in progress(sudden power-off in progress of reclaim), restart reclaim. This is power-off-recovery(POR)!!!
+	if(mst->status&J4FS_RECLAIM_MOVING_DATA_STEP_1) goto moving_data_step_1;
+	if(mst->status&J4FS_RECLAIM_MOVING_DATA_STEP_2) goto moving_data_step_2;
+	if(mst->status&J4FS_RECLAIM_UPDATE_LINK) goto update_link;
+
+	/**************************************************************************
+	 * This is first reclaim since last reclaim is done successfully(There are no power off in the middle of reclaim)
+	 **************************************************************************/
+
+	if(!mst->rw_start ||(mst->rw_start>= device_info.j4fs_end))
+	{
+		T(J4FS_TRACE_ALWAYS,("%s %d: Error! rw_start is invalid(j4fs_rw_start=0x%08x, j4fs_end=0x%08x)\n", __FUNCTION__, __LINE__, mst->rw_start, device_info.j4fs_end));
+		j4fs_panic("rw_start is invalid");
+		goto error1;
+	}
+
+	// invalidate old valid files
+	fsd_mark_invalid();
+
+	// the start address of the RW area of the device (partition)
+	offset=mst->rw_start;
+
+	while(offset!=0xffffffff)
+	{
+		// read j4fs_header
+		ret = FlashDevRead(&device_info, offset, J4FS_BASIC_UNIT_SIZE, buf_header);
+		if (error(ret)) {
+			T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+			goto error1;
+		}
+
+		//This j4fs_header cannot be interpreted. We have scaned all objects in device(partition)
+		if(header->type!=J4FS_FILE_TYPE) break;
+
+		// This file is invalid(deleted)
+		if((header->flags&0x1)!=((header->flags&0x2)>>1))
+		{
+			if(mst->to==0) mst->to=offset;
+			offset=header->link;
+			continue;
+		}
+		// This file is valid(not deleted, reclaim may start)
+		else
+		{
+			// If this object is first object, just skip it
+			if(offset==device_info.j4fs_offset)
+			{
+				offset=header->link;
+				continue;
+			}
+
+			// If invalid object is not scanned yet, there are no place to copy this valid object
+			if(mst->to==0)
+			{
+				offset=header->link;
+				continue;
+			}
+
+			/**************************************************************************
+			 * Start to copy this valid object to invalid area(to offset)
+			 **************************************************************************/
+			mst->from=offset;
+			offset += J4FS_BASIC_UNIT_SIZE;	// header
+			offset += header->length;	// data
+			offset = (offset+J4FS_BASIC_UNIT_SIZE-1)/J4FS_BASIC_UNIT_SIZE*J4FS_BASIC_UNIT_SIZE;	// J4FS_BASIC_UNIT_SIZE align. offset indicate 'end of this object and beginning of next object'
+			mst->end=offset;
+			mst->copyed=0;
+			mst->status=J4FS_RECLAIM_MOVING_DATA_STEP_1;
+
+			if(header->link==0xffffffff) mst->status|=J4FS_RECLAIM_LAST_OBJECT;
+
+			POR(0x1,("%s %d: Power-off point-1\n",__FUNCTION__,__LINE__),2000);
+
+			// write mst reflected new status(from,end)
+			ret = FlashDevWrite(&device_info, 0, J4FS_BASIC_UNIT_SIZE, buf_mst);
+			if (error(ret)) {
+				T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+				goto error1;
+			}
+
+moving_data_step_1:
+
+			POR(0x2,("%s %d: Power-off point-2\n",__FUNCTION__,__LINE__),2000);
+
+			// copy valid data('from' offset) to invalid area('to' offset)
+			while(mst->from < mst->end)
+			{
+				POR(0x4,("%s %d: Power-off point-4\n",__FUNCTION__,__LINE__),2000);
+
+				// read valid data
+				ret = FlashDevRead(&device_info, mst->from, J4FS_BASIC_UNIT_SIZE, buf_data);
+				if (error(ret)) {
+					T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+
+				POR(0x8,("%s %d: Power-off point-8\n",__FUNCTION__,__LINE__),2000);
+
+				// write valid data
+				ret = FlashDevWrite(&device_info, mst->to, J4FS_BASIC_UNIT_SIZE, buf_data);
+				if (error(ret)) {
+					T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+
+				POR(0x10,("%s %d: Power-off point-10\n",__FUNCTION__,__LINE__),2000);
+
+				// write updated MST status(from,to)
+				mst->from+=J4FS_BASIC_UNIT_SIZE;
+				mst->to+=J4FS_BASIC_UNIT_SIZE;
+				mst->copyed+=J4FS_BASIC_UNIT_SIZE;
+				ret = FlashDevWrite(&device_info, 0, J4FS_BASIC_UNIT_SIZE, buf_mst);
+				if (error(ret)) {
+					T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+
+				POR(0x20,("%s %d: Power-off point-20\n",__FUNCTION__,__LINE__),2000);
+
+			}
+
+			POR(0x40,("%s %d: Power-off point-40\n",__FUNCTION__,__LINE__),2000);
+
+			// write updated MST status(offset,offset_number,from,to)
+			mst->offset[mst->offset_number]=mst->to-mst->copyed;
+			mst->offset_number++;
+			mst->status= (mst->status&J4FS_RECLAIM_LAST_OBJECT)|J4FS_RECLAIM_MOVING_DATA_STEP_2;
+			ret = FlashDevWrite(&device_info, 0, J4FS_BASIC_UNIT_SIZE, buf_mst);
+			if (error(ret)) {
+				T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+				goto error1;
+			}
+
+moving_data_step_2:
+			if(mst->status&J4FS_RECLAIM_LAST_OBJECT) offset=0xffffffff;
+			else offset=mst->end;
+
+			POR(0x80,("%s %d: Power-off point-80\n",__FUNCTION__,__LINE__),2000);
+
+			/**************************************************************************
+			 * End of copying this valid object to invalid area(to offset)
+			 **************************************************************************/
+		}
+	}
+
+	POR(0x100,("%s %d: Power-off point-100\n",__FUNCTION__,__LINE__),2000);
+
+	if(mst->offset_number==0) goto reclaim_done;
+
+	// Adjust j4fs_header.link of valid object
+	// write updated MST status(status)
+	mst->status=J4FS_RECLAIM_UPDATE_LINK;
+	ret = FlashDevWrite(&device_info, 0, J4FS_BASIC_UNIT_SIZE, buf_mst);
+	if (error(ret)) {
+		T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+		goto error1;
+	}
+
+update_link:
+
+	POR(0x200,("%s %d: Power-off point-200\n",__FUNCTION__,__LINE__),2000);
+
+	// Adjust j4fs_header.link of valid objects excluding last object
+	if(mst->offset_number>=2)
+	{
+		for(i=0;i<mst->offset_number-1;i++)
+		{
+			POR(0x400,("%s %d: Power-off point-400\n",__FUNCTION__,__LINE__),2000);
+
+			// read j4fs_header
+			ret = FlashDevRead(&device_info, mst->offset[i], J4FS_BASIC_UNIT_SIZE, buf_header);
+			if (error(ret)) {
+				T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+				goto error1;
+			}
+
+			POR(0x800,("%s %d: Power-off point-800\n",__FUNCTION__,__LINE__),2000);
+
+			header->link=mst->offset[i+1];
+
+			// write j4fs_header
+			ret = FlashDevWrite(&device_info, mst->offset[i], J4FS_BASIC_UNIT_SIZE, buf_header);
+			if (error(ret)) {
+				T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+				goto error1;
+			}
+
+			POR(0x1000,("%s %d: Power-off point-1000\n",__FUNCTION__,__LINE__),2000);
+
+		}
+	}
+
+	POR(0x2000,("%s %d: Power-off point-2000\n",__FUNCTION__,__LINE__),2000);
+
+	// Adjust j4fs_header.link of last valid object
+	if(mst->offset_number>0)
+	{
+		POR(0x4000,("%s %d: Power-off point-4000\n",__FUNCTION__,__LINE__),2000);
+
+		// read j4fs_header
+		ret = FlashDevRead(&device_info, mst->offset[mst->offset_number-1], J4FS_BASIC_UNIT_SIZE, buf_header);
+		if (error(ret)) {
+			T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+			goto error1;
+		}
+
+		POR(0x8000,("%s %d: Power-off point-8000\n",__FUNCTION__,__LINE__),2000);
+
+		header->link=0xffffffff;
+
+		// write j4fs_header
+		ret = FlashDevWrite(&device_info, mst->offset[mst->offset_number-1], J4FS_BASIC_UNIT_SIZE, buf_header);
+		if (error(ret)) {
+			T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+			goto error1;
+		}
+
+		POR(0x10000,("%s %d: Power-off point-10000\n",__FUNCTION__,__LINE__),2000);
+
+		first_unused_area_offset = mst->offset[mst->offset_number-1] + J4FS_BASIC_UNIT_SIZE + header->length;
+		first_unused_area_offset = (first_unused_area_offset + J4FS_BASIC_UNIT_SIZE-1)/J4FS_BASIC_UNIT_SIZE*J4FS_BASIC_UNIT_SIZE;
+
+	}
+
+	POR(0x20000,("%s %d: Power-off point-20000\n",__FUNCTION__,__LINE__),2000);
+
+	// write 'Reclaim Done'
+	rw_start=mst->rw_start;
+	memset(mst,0x0,J4FS_BASIC_UNIT_SIZE);
+	mst->magic=J4FS_MAGIC;
+	mst->status=J4FS_RECLAIM_DONE;
+	mst->rw_start=rw_start;
+
+#ifdef J4FS_TRANSACTION_LOGGING
+	// setting transaction variable
+	memset(transaction,0xff,J4FS_TRANSACTION_SIZE);
+	transaction->magic=J4FS_MAGIC;
+	transaction->sequence=j4fs_next_sequence++;
+	transaction->opcode=J4FS_RECLAIM_STEP2;
+
+	ret = FlashDevWrite(&device_info, j4fs_transaction_next_offset, J4FS_TRANSACTION_SIZE, (BYTE *)transaction);
+
+	if (error(ret)) {
+		T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+		goto error1;
+	}
+
+	j4fs_transaction_next_offset+=J4FS_TRANSACTION_SIZE;
+	if(j4fs_transaction_next_offset>=device_info.j4fs_device_end) j4fs_transaction_next_offset=device_info.j4fs_end;
+#endif
+
+	ret = FlashDevWrite(&device_info, 0, J4FS_BASIC_UNIT_SIZE, buf_mst);
+	if (error(ret)) {
+		T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+		goto error1;
+	}
+
+#ifdef J4FS_RECLAIM_RESET_UNUSED_SPACE
+	// Set 'not used space' to 0xff. This is not mandatory
+	if(first_unused_area_offset!=0xffffffff)
+	{
+		memset(buf_data,0xff,J4FS_BASIC_UNIT_SIZE);
+		for(i=0; i<10*J4FS_BASIC_UNIT_SIZE; i+=J4FS_BASIC_UNIT_SIZE)
+		{
+			T(J4FS_TRACE_FSD_RECLAIM,("%s %d: (first_unused_area_offset=0x%08x,i=0x%08x,j4fs_end=0x%08x)\n",__FUNCTION__,__LINE__,first_unused_area_offset,i,device_info.j4fs_end));
+			ret = FlashDevWrite(&device_info, first_unused_area_offset+i, J4FS_BASIC_UNIT_SIZE, buf_data);
+			if (error(ret)) {
+				T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+				goto error1;
+			}
+		}
+	}
+#endif
+
+reclaim_done:
+	j4fs_rw_start=mst->rw_start;
+
+	// Handle the exception
+	if(!j4fs_rw_start ||(j4fs_rw_start>= device_info.j4fs_end))
+	{
+		T(J4FS_TRACE_ALWAYS,("%s %d: j4fs_rw_start is set to default value(128KB)\n",__FUNCTION__,__LINE__));
+		j4fs_rw_start=device_info.j4fs_offset;
+	}
+
+	if(!ro_j4fs_header_count) fsd_read_ro_header();
+
+#ifdef __KERNEL__
+	kfree(buf_mst);
+	kfree(buf_header);
+	kfree(buf_data);
+#ifdef J4FS_TRANSACTION_LOGGING
+	kfree(transaction);
+#endif
+#endif
+
+	T(J4FS_TRACE_FSD_RECLAIM,("\n%s %d: Reclaim Done\n",__FUNCTION__,__LINE__));
+	fsd_print_meta_data();
+
+	return J4FS_SUCCESS;
+
+error1:
+	T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+
+	// Handle the exception
+	if(!j4fs_rw_start ||(j4fs_rw_start>= device_info.j4fs_end))
+	{
+		T(J4FS_TRACE_ALWAYS,("%s %d: j4fs_rw_start is set to default value(128KB)\n",__FUNCTION__,__LINE__));
+		j4fs_rw_start=device_info.j4fs_offset;
+	}
+
+	if(!ro_j4fs_header_count) fsd_read_ro_header();
+	fsd_print_meta_data();
+
+#ifdef __KERNEL__
+	kfree(buf_mst);
+	kfree(buf_header);
+	kfree(buf_data);
+#ifdef J4FS_TRANSACTION_LOGGING
+	kfree(transaction);
+#endif
+#endif
+	return J4FS_FAIL;
+}
+
+static DWORD valid_offset[128][2];
+// invalidate old valid files
+int fsd_mark_invalid()
+{
+	DWORD offset;
+	j4fs_header *header;
+	int index=0;
+	int i,j;
+	j4fs_mst *mst;
+	int ret=-1;
+
+#ifdef __KERNEL__
+	BYTE *buf;
+	buf=kmalloc(J4FS_BASIC_UNIT_SIZE,GFP_NOFS);
+#else
+	BYTE buf[J4FS_BASIC_UNIT_SIZE];
+#endif
+	memset(valid_offset, 0x00, sizeof(valid_offset));
+
+	mst=(j4fs_mst *)buf;
+
+	// read mst
+	ret = FlashDevRead(&device_info, 0, J4FS_BASIC_UNIT_SIZE, buf);
+	if (error(ret)) {
+		T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+		goto error1;
+	}
+
+	if(mst->magic==J4FS_MAGIC)
+	{
+		// the start address of the RW area of the device (partition)
+		offset=mst->rw_start;
+
+		if(!offset ||(offset>= device_info.j4fs_end))
+		{
+			T(J4FS_TRACE_ALWAYS,("%s %d: Error! rw_start is invalid(j4fs_rw_start=0x%08x, j4fs_end=0x%08x)\n", __FUNCTION__, __LINE__, mst->rw_start, device_info.j4fs_end));
+			j4fs_panic("rw_start is invalid");
+			goto error1;
+		}
+	}
+	else
+	{
+		T(J4FS_TRACE_ALWAYS,("%s %d: Error! MST is invalid\n", __FUNCTION__, __LINE__));
+		j4fs_panic("MST is invalid");
+		goto error1;
+	}
+
+	// trace all RW object header
+	while(offset!=0xffffffff)
+	{
+		// read j4fs_header
+		ret = FlashDevRead(&device_info, offset, J4FS_BASIC_UNIT_SIZE, buf);
+		if (error(ret)) {
+			T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+			goto error1;
+		}
+		header=(j4fs_header *)buf;
+
+		//This j4fs_header cannot be interpreted. It means there are no RW files in this partition(this can happen and this is a normal case) or
+		//this j4fs partition is crashed(this should not happen).
+		if(header->type!=J4FS_FILE_TYPE)
+		{
+			// There are no RW files in this partition or this first j4fs_header is crashed. Before we write data of new file, user of j4fs should write j4fs_header of new file.
+			// So, this case should not happen and/or should be repaired.
+			if(offset==mst->rw_start) {
+				j4fs_panic("There are no RW files in this partition or this first RW j4fs_header is crashed. Before we write data of new file, user of j4fs should write j4fs_header of new file. So, this case should not happen and/or should be repaired..");
+				goto error1;
+			}
+
+			// This j4fs partition is crashed by some abnormal cause. This should not happen and should be repaired.
+			j4fs_panic("this j4fs partition is crashed by some abnormal cause.  This should not happen and should be repaired.");
+			goto error1;
+		}
+
+		// This file was deleted, so read next j4fs_header.
+		if((header->flags&0x1)!=((header->flags&0x2)>>1))
+		{
+			offset=header->link;
+			continue;
+		}
+
+		// This file is valid.
+		valid_offset[index][0]=header->id;
+		valid_offset[index][1]=offset;
+		index++;
+		offset=header->link;
+	}
+
+	T(J4FS_TRACE_FSD_PRINT_META_DATA,("%s %d: index=%d\n",__FUNCTION__,__LINE__,index));
+
+	// Invalidate old files. we exclude last object header because last object header can't decide invalidation of old files
+	for(i=0;i<index-2;i++)
+	{
+		for(j=i+1;j<index-1;j++)
+		{
+			// If inode number is same, invalidate old object
+			if(valid_offset[i][0]==valid_offset[j][0])
+			{
+				//T(J4FS_TRACE_FSD_PRINT_META_DATA,("%s %d\n",__FUNCTION__,__LINE__));
+
+				// read j4fs_header
+				ret = FlashDevRead(&device_info, valid_offset[i][1], J4FS_BASIC_UNIT_SIZE, buf);
+				if (error(ret)) {
+					T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+				header=(j4fs_header *)buf;
+
+				//This j4fs_header cannot be interpreted. It means there are no RW files in this partition(this can happen and this is a normal case) or
+				//this j4fs partition is crashed(this should not happen).
+				if(header->type!=J4FS_FILE_TYPE)
+				{
+					// There are no RW files in this partition or this first j4fs_header is crashed. Before we write data of new file, user of j4fs should write j4fs_header of new file.
+					// So, this case should not happen and/or should be repaired.
+					if(offset==mst->rw_start) {
+						j4fs_panic("There are no RW files in this partition or this first RW j4fs_header is crashed. Before we write data of new file, user of j4fs should write j4fs_header of new file. So, this case should not happen and/or should be repaired..");
+						goto error1;
+					}
+
+					// This j4fs partition is crashed by some abnormal cause. This should not happen and should be repaired.
+					j4fs_panic("this j4fs partition is crashed by some abnormal cause.  This should not happen and should be repaired.");
+					goto error1;
+				}
+
+				// this file will be deleted
+				header->flags=0x1;
+
+				ret = FlashDevWrite(&device_info, valid_offset[i][1], J4FS_BASIC_UNIT_SIZE, buf);
+				if (error(ret)) {
+					T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+					goto error1;
+				}
+				break;
+			}
+		}
+	}
+
+#ifdef __KERNEL__
+	kfree(buf);
+#endif
+
+	return J4FS_SUCCESS;
+
+error1:
+#ifdef __KERNEL__
+	kfree(buf);
+#endif
+	return J4FS_FAIL;
+}
+
+
+int fsd_special(j4fs_ctrl *ctl)
+{
+	return FlashDevSpecial(&device_info,ctl->scmd);
+}
+
+// Read j4fs_header list of RO area
+int fsd_read_ro_header(void)
+{
+	DWORD offset;
+	j4fs_header *header;
+	int i;
+	int ret=-1;
+
+#ifdef __KERNEL__
+	BYTE *buf;
+	buf=kmalloc(J4FS_BASIC_UNIT_SIZE,GFP_NOFS);
+#else
+	BYTE buf[J4FS_BASIC_UNIT_SIZE];
+#endif
+
+	ro_j4fs_header_count=0;
+
+	// the start address of the device (partition)
+	offset=	device_info.j4fs_offset;
+
+	// scanning all j4fs_header of RO area.
+	while(offset<j4fs_rw_start)
+	{
+		// read j4fs_header
+		ret = FlashDevRead(&device_info, offset, J4FS_BASIC_UNIT_SIZE, buf);
+		if (error(ret)) {
+			T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+			goto error1;
+		}
+		header=(j4fs_header *)buf;
+
+		//This j4fs_header cannot be interpreted.
+		if(header->type!=J4FS_FILE_TYPE)
+		{
+			T(J4FS_TRACE_ALWAYS,("%s %d: ERROR! RO file cannot be interpreted. (offset=%d)\n",__FUNCTION__,__LINE__,offset));
+			j4fs_panic("This j4fs_header cannot be interpreted. So this j4fs partition is crashed by some abnormal cause.  This should not happen and should be repaired.");
+			goto error1;
+		}
+
+		// This file was deleted, so read next j4fs_header.
+		if((header->flags&0x1)!=((header->flags&0x2)>>1))
+		{
+			T(J4FS_TRACE_ALWAYS,("%s %d: ERROR! RO file was deleted. (offset,ino,filename)=(%d,%d,%s)\n",__FUNCTION__,__LINE__,offset,header->id,header->filename));
+			offset=header->link;
+			continue;
+		}
+
+		if(ro_j4fs_header_count>=J4FS_MAX_RO_FILES_NUMBER)
+		{
+			T(J4FS_TRACE_ALWAYS,("%s %d: ERROR! Too many ro files\n",__FUNCTION__,__LINE__));
+
+			j4fs_traceMask |= J4FS_TRACE_FSD_PRINT_META_DATA;
+			fsd_print_meta_data();
+			j4fs_traceMask &= ~J4FS_TRACE_FSD_PRINT_META_DATA;
+			goto error1;
+		}
+
+		memcpy(ro_j4fs_header+ro_j4fs_header_count, header, sizeof(j4fs_header));
+		ro_j4fs_header_count++;
+
+		offset=header->link;
+	}
+
+	T(J4FS_TRACE_FSD_PRINT_META_DATA,("\n====================== %s %d ================================\n", __FUNCTION__,__LINE__));
+
+	for(i=0;i<ro_j4fs_header_count;i++)
+	{
+		T(J4FS_TRACE_FSD_PRINT_META_DATA,("%d : (link,type,flags,id,length,filename)=(0x%08x,0x%08x,0x%08x,0x%08x,0x%08x,%s)\n",(i+1),ro_j4fs_header[i].link, ro_j4fs_header[i].type, ro_j4fs_header[i].flags, ro_j4fs_header[i].id, ro_j4fs_header[i].length, ro_j4fs_header[i].filename));
+	}
+
+	T(J4FS_TRACE_FSD_PRINT_META_DATA,("\n====================== %s %d ================================\n", __FUNCTION__,__LINE__));
+#ifdef __KERNEL__
+	kfree(buf);
+#endif
+	return J4FS_SUCCESS;
+
+error1:
+#ifdef __KERNEL__
+	kfree(buf);
+#endif
+	return J4FS_FAIL;
+
+}
+
+#ifdef J4FS_TRANSACTION_LOGGING
+int fsd_initialize_transaction()
+{
+	int i, ret;
+	DWORD sequence=0,offset=0xffffffff;
+	j4fs_transaction *transaction;
+
+#ifdef __KERNEL__
+	BYTE *buf;
+	buf=kmalloc(J4FS_TRANSACTION_SIZE,GFP_NOFS);
+#else
+	BYTE buf[J4FS_TRANSACTION_SIZE];
+#endif
+
+	transaction=(j4fs_transaction *)buf;
+
+	for(i=device_info.j4fs_end+1; i<device_info.j4fs_device_end; i+=J4FS_TRANSACTION_SIZE)
+	{
+		ret = FlashDevRead(&device_info, i, J4FS_TRANSACTION_SIZE, buf);
+		if (error(ret)) {
+			T(J4FS_TRACE_ALWAYS,("%s %d: Error(ret=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+			goto error1;
+		}
+
+		if(transaction->magic!=J4FS_MAGIC) continue;
+		if(sequence<transaction->sequence)
+		{
+			sequence=transaction->sequence;
+			offset=i;
+		}
+	}
+
+	// there are no file system transaction
+	if(offset==0xffffffff)
+	{
+		j4fs_next_sequence=1;
+		j4fs_transaction_next_offset=device_info.j4fs_end+1;
+	}
+	else
+	{
+		j4fs_next_sequence=sequence+1;
+		j4fs_transaction_next_offset=offset+512;
+
+		if(j4fs_transaction_next_offset>=device_info.j4fs_device_end) j4fs_transaction_next_offset=device_info.j4fs_end+1;
+	}
+
+#ifdef __KERNEL__
+	kfree(buf);
+#endif
+	return J4FS_SUCCESS;
+
+error1:
+#ifdef __KERNEL__
+	kfree(buf);
+#endif
+	return J4FS_FAIL;
+}
+#endif
+
+int fsd_panic()
+{
+	j4fs_mst *mst;
+	int ret=-1;
+
+#ifdef __KERNEL__
+	BYTE *buf;
+	buf=kmalloc(J4FS_BASIC_UNIT_SIZE,GFP_NOFS);
+#else
+	BYTE buf[J4FS_BASIC_UNIT_SIZE];
+#endif
+
+	j4fs_panic=1;
+
+	// Marking j4fs panic by writing J4FS_PANIC to mst->status
+	ret = FlashDevRead(&device_info, 0, J4FS_BASIC_UNIT_SIZE, buf);
+	if (error(ret)) {
+		T(J4FS_TRACE_ALWAYS,("%s %d: Error\n",__FUNCTION__,__LINE__));
+		goto error1;
+	}
+
+	mst=(j4fs_mst *)buf;
+	mst->status|=J4FS_PANIC;
+
+	ret = FlashDevWrite(&device_info, 0, J4FS_BASIC_UNIT_SIZE, buf);
+	if (error(ret)) {
+		T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+		goto error1;
+	}
+
+#ifdef __KERNEL__
+	kfree(buf);
+#endif
+	return J4FS_SUCCESS;
+
+error1:
+#ifdef __KERNEL__
+	kfree(buf);
+#endif
+	return J4FS_FAIL;
+}
+
+int fsd_print_meta_data()
+{
+	DWORD offset;
+	j4fs_header *header;
+	j4fs_mst *mst;
+	int i;
+	int ret=-1;
+
+#ifdef __KERNEL__
+	BYTE *buf;
+	buf=kmalloc(4096,GFP_NOFS);
+#else
+	BYTE buf[4096];
+#endif
+
+	if(!(j4fs_traceMask|J4FS_TRACE_FSD_PRINT_META_DATA)) return 0;
+
+	// print MST
+	ret = FlashDevRead(&device_info, 0, J4FS_BASIC_UNIT_SIZE, buf);
+	if (error(ret)) {
+		T(J4FS_TRACE_ALWAYS,("%s %d: Error\n",__FUNCTION__,__LINE__));
+		goto error1;
+	}
+
+	T(J4FS_TRACE_FSD_PRINT_META_DATA,("====================================================================\n"));
+
+	mst=(j4fs_mst *)buf;
+	T(J4FS_TRACE_FSD_PRINT_META_DATA,("(magic,from,to,end,offset_number,status,rw_start)=(0x%08x,0x%08x,0x%08x,0x%08x,0x%08x,0x%08x,0x%08x)\n",
+		mst->magic,mst->from,mst->to,mst->end,mst->offset_number,mst->status,mst->rw_start));
+
+	if(mst->magic==J4FS_MAGIC && mst->offset_number)
+	{
+		T(J4FS_TRACE_FSD_PRINT_META_DATA,("offset: "));
+		for(i=0;i<mst->offset_number;i++)
+			T(J4FS_TRACE_FSD_PRINT_META_DATA,("0x%x ", mst->offset[i]));
+		T(J4FS_TRACE_FSD_PRINT_META_DATA,("\n"));
+	}
+
+	// the start address of the device (partition)
+	offset=	device_info.j4fs_offset;
+
+	i=0;
+	while(1)
+	{
+		// read j4fs_header
+		ret = FlashDevRead(&device_info, offset, J4FS_BASIC_UNIT_SIZE, buf);
+		if (error(ret)) {
+			T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+			goto error1;
+		}
+		header=(j4fs_header *)buf;
+
+		//This j4fs_header cannot be interpreted.
+		if(header->type!=J4FS_FILE_TYPE) break;
+
+		T(J4FS_TRACE_FSD_PRINT_META_DATA,("%d : (link,type,flags,id,length,filename)=(0x%08x,0x%08x,0x%08x,0x%08x,0x%08x,%s)\n",++i,header->link,header->type,header->flags,header->id,header->length,header->filename));
+
+		// this is last enry in the device
+		if(header->link==0xffffffff)
+		{
+			break;
+		}
+		else
+		{
+			offset += J4FS_BASIC_UNIT_SIZE;	// header
+			offset += header->length;	// data
+			offset = (offset+J4FS_BASIC_UNIT_SIZE-1)/J4FS_BASIC_UNIT_SIZE*J4FS_BASIC_UNIT_SIZE;	// 4096 align
+			if(mst->from && offset>=mst->to) offset=mst->from;	// In case of power-off when reclaim(mst-from>0), skip from 'to offset' to 'from offset'
+		}
+	}
+
+	T(J4FS_TRACE_FSD_PRINT_META_DATA,("====================================================================\n"));
+
+#ifdef __KERNEL__
+	kfree(buf);
+#endif
+	return J4FS_SUCCESS;
+
+error1:
+#ifdef __KERNEL__
+	kfree(buf);
+#endif
+	return J4FS_FAIL;
+}
diff -urNp Kernel/drivers/j4fs/j4fs.h HelloWorld-Renew-v1.0-n7000-jb/drivers/j4fs/j4fs.h
--- Kernel/drivers/j4fs/j4fs.h	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/drivers/j4fs/j4fs.h	2013-04-29 16:41:35.142587461 +0200
@@ -0,0 +1,521 @@
+/*
+ * This software is the confidential and proprietary information
+ * of Samsung Electronics, Inc. ("Confidential Information").  You
+ * shall not disclose such Confidential Information and shall use
+ * it only in accordance with the terms of the license agreement
+ * you entered into with Samsung.
+ */
+/*
+ * Copyright (C) 2008, 2009,  Samsung Electronics Co. Ltd. All Rights Reserved.
+ *       Written by Linux Lab, MITs Development Team, Mobile Communication Division.
+ */
+
+/*
+ * J4FS
+ *
+ * Jong Jang Jintae Jongmin File System is based on LFS(Linear File Store)
+ *
+ *
+ * 2009.02 - First editing by SungHwan.yun <sunghwan.yun@samsung.com> @LDK@
+ *
+ * 2009.03 - Currently managed by  SungHwan.yun <sunghwan.yun@samsung.com> @LDK@
+ *
+ * 2009.12 - Version 1.0 Released by SungHwan.yun <sunghwan.yun@samsung.com> @LDK@
+ *
+ * 2011.07 - EMMC Mount Fail Bug Fix (1.1.0p1_b0)
+ */
+
+#ifdef __KERNEL__
+#include <linux/version.h>
+#include <linux/types.h>
+#include <asm/types.h>
+#include <linux/spinlock.h>
+#include <linux/fs.h>
+#include <linux/mount.h>
+#include <linux/buffer_head.h>
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 36))
+#define init_MUTEX(sem)	sema_init(sem, 1)
+#endif
+
+#ifndef BYTE
+#define BYTE __u8
+#endif
+
+#ifndef WORD
+#define WORD __u16
+#endif
+
+#ifndef HWORD
+#define HWORD __u16
+#endif
+
+#ifndef DWORD
+#define DWORD __u32
+#endif
+
+#define PRINT printk
+
+#else
+
+#ifndef BYTE
+#define BYTE unsigned char
+#endif
+
+#ifndef WORD
+#define WORD unsigned int
+#endif
+
+#ifndef HWORD
+#define HWORD unsigned int
+#endif
+
+#ifndef DWORD
+#define DWORD unsigned int
+#endif
+
+#define PRINT printf
+
+#endif
+
+/**********************************************************
+ * This is porting values
+ **********************************************************/
+#define PHYSICAL_PAGE_SIZE		(1 << CONFIG_J4FS_PAGE_SHIFT)
+#define PHYSICAL_BLOCK_SIZE		(PHYSICAL_PAGE_SIZE * 64)
+
+#if defined(CONFIG_J4FS_USE_XSR)
+#define J4FS_USE_XSR
+#undef J4FS_USE_FSR
+#undef J4FS_USE_MOVI
+#elif defined(CONFIG_J4FS_USE_FSR)
+#undef J4FS_USE_XSR
+#define J4FS_USE_FSR
+#undef J4FS_USE_MOVI
+#elif defined(CONFIG_J4FS_USE_MOVI)
+#undef J4FS_USE_XSR
+#undef J4FS_USE_FSR
+#define J4FS_USE_MOVI
+#else
+#error "Check J4FS Interface Type!"
+#endif
+
+#if defined(J4FS_USE_MOVI)
+#define J4FS_PARTITION_ID		21
+#else
+#define J4FS_PARTITION_ID		CONFIG_J4FS_PARTITION_ID
+#endif
+
+#if defined(J4FS_USE_MOVI)
+#define J4FS_BLOCK_COUNT		CONFIG_J4FS_BLOCK_COUNT
+#endif
+
+/*
+ * J4FS Version(J4FS_1.0.0p2_b0)
+ */
+#define J4FS_VER_MAJOR			1
+#define J4FS_VER_MINOR1			0
+#define J4FS_VER_MINOR2			0
+#define J4FS_VER_PATCHLEVEL		2
+#define J4FS_BUILD_NUMBER		0
+
+
+/*
+ * file header(j4fs_header) and data block and media status table(j4fs_mst) size
+ */
+#define J4FS_BASIC_UNIT_SIZE		(1 << CONFIG_J4FS_PAGE_SHIFT)
+#define J4FS_BASIC_UNIT_SIZE_BITS	CONFIG_J4FS_PAGE_SHIFT
+
+/*
+ * File name length
+ */
+#define J4FS_NAME_LEN 128
+
+/*
+ * Max RO file number
+ */
+#define J4FS_MAX_RO_FILES_NUMBER 200
+
+/*
+  * Max file number in J4FS
+ */
+#define J4FS_MAX_FILE_NUM	256
+
+/*
+ * Special inode numbers
+ */
+#define J4FS_BAD_INO		 1	/* Bad blocks inode */
+#define J4FS_ROOT_INO		 2	/* Root inode */
+#define J4FS_BOOT_LOADER_INO	 5	/* Boot loader inode */
+#define J4FS_UNDEL_DIR_INO	 6	/* Undelete directory inode */
+#define J4FS_FIRST_INO	11 /* First non-reserved inode */
+
+/*
+  * Reclaim status
+ */
+#define J4FS_RECLAIM_DONE							0x01230000	// This value should not be zero becaust of POR
+#define J4FS_RECLAIM_MOVING_DATA_STEP_1		0x00000001
+#define J4FS_RECLAIM_MOVING_DATA_STEP_2		0x00000002
+#define J4FS_RECLAIM_UPDATE_LINK					0x00000004
+#define J4FS_RECLAIM_LAST_OBJECT					0x10000000
+#define J4FS_PANIC										0x00005a00
+#define J4FS_PANIC_MASK								0x0000ff00
+
+// Debug
+#define J4FS_TRACE_FSD					0x00000001
+#define J4FS_TRACE_FS						0x00000002
+#define J4FS_TRACE_FS_READ				0x00000004
+#define J4FS_TRACE_LOCK					0x00000008
+#define J4FS_TRACE_FSD_RECLAIM		0x00000010
+#define J4FS_TRACE_FSD_PRINT_META_DATA		0x00000020
+
+#define J4FS_TRACE_ALWAYS		0xF0000000
+
+/*
+ * Define return value
+ */
+#define J4FS_SUCCESS			0x0
+#define J4FS_RETRY_WRITE		0x20000000
+#define J4FS_FAIL					0x40000000
+#define J4FS_NO_FILE			0x40001000
+
+/*
+ * opcode : j4fs transaction for j4fs crash debugging
+ */
+#define J4FS_LAST_OBJECT_CREATE_STEP1							0x1		// 1,4,10
+#define J4FS_LAST_OBJECT_CREATE_STEP2							0x2		// 1,4,10
+#define J4FS_LAST_OBJECT_WRITE_EXTEND1						0x10		// 2,3,5,6
+#define J4FS_LAST_OBJECT_WRITE_EXTEND2						0x20		// 8
+#define J4FS_NOLAST_OBJECT_WRITE_EXTEND_STEP1			0x100		// 9,11,12,13
+#define J4FS_NOLAST_OBJECT_WRITE_EXTEND_STEP2			0x110	// 9,11,12,13
+#define J4FS_NOLAST_OBJECT_WRITE_EXTEND_STEP3			0x120	// 9,11,12,13
+#define J4FS_RECLAIM_STEP1											0x1000	// reclaim
+#define J4FS_RECLAIM_STEP2											0x2000	// reclaim
+
+#define J4FS_RECLAIM_RESET_UNUSED_SPACE
+#define J4FS_TRANSACTION_LOGGING
+
+#undef T
+#define T(mask, p) do { if ((mask) & (j4fs_traceMask | J4FS_TRACE_ALWAYS)) TOUT(p); } while (0)
+#define POR(mask, p, q) do { if (((mask) & (j4fs_PORMask))&&!(--j4fs_PORCount)) {TOUT(p); while(1); }} while (0)
+
+#define error(ret)	(ret>=J4FS_FAIL)
+
+#ifdef __KERNEL__
+#define j4fs_panic(str)		\
+do {							\
+	T(J4FS_TRACE_ALWAYS,("%s %d: "str"\n",__FUNCTION__,__LINE__));	\
+	fsd_panic();		\
+	dump_stack();	\
+} while (0)
+#else
+#define j4fs_panic(str)		\
+do {							\
+	T(J4FS_TRACE_ALWAYS,("%s %d: "str"\n",__FUNCTION__,__LINE__));	\
+	fsd_panic();	\
+} while (0)
+#endif
+
+#ifdef __KERNEL__
+#define j4fs_dump(str)		\
+do {							\
+	T(J4FS_TRACE_ALWAYS,("%s %d: "str"\n",__FUNCTION__,__LINE__));	\
+	dump_stack();	\
+} while (0)
+#else
+#define j4fs_dump(str)		\
+do {							\
+	T(J4FS_TRACE_ALWAYS,("%s %d: "str"\n",__FUNCTION__,__LINE__));	\
+	while(1);	\
+} while (0)
+#endif
+
+
+#define j4fs_check_partition_range(offset)		\
+do {		\
+	if(offset + J4FS_BASIC_UNIT_SIZE > device_info.j4fs_end) {	\
+		T(J4FS_TRACE_ALWAYS,("%s %d: offset overflow(offset=0x%08x, j4fs_end=0x%08x)\n", __FUNCTION__, __LINE__, offset, device_info.j4fs_end));	\
+		j4fs_panic("offset overflow!!");	\
+		goto error1;	\
+	}	\
+} while(0)
+
+
+
+#ifdef __KERNEL__
+/*
+ * Flash data structure of the super block
+ */
+struct j4fs_super_block {
+	unsigned long pad;
+};
+
+/*
+ * Memory data structure of the super block
+ */
+struct j4fs_sb_info {
+	struct j4fs_super_block * s_es;	/* Pointer to the super block in the buffer */
+	unsigned long	s_log_block_size;	/* Block size(0:1024, 1:2048, 3:4096)*/
+	int s_first_ino;
+};
+
+/*
+ * Flash data structure of the inode
+ */
+struct j4fs_inode {
+	__le32 i_link;
+	__le32 i_size;
+	__le32 i_type;
+	__le32 i_offset;
+	__le32 i_flags;
+	__le32 i_stroff;
+	__le32 i_id;
+	__le32	i_length;
+	__u8 i_filename[J4FS_NAME_LEN];
+};
+
+/*
+ * Memory data structure of the inode
+ */
+struct j4fs_inode_info {
+	__le32 i_link;
+	__le32 i_type;
+	__le32 i_flags;
+	__le32 i_id;
+	__le32	i_length;
+	__u8 i_filename[J4FS_NAME_LEN];
+	rwlock_t i_meta_lock;
+	struct inode	vfs_inode;
+};
+
+#endif
+
+
+#define J4FS_INIT				1
+#define J4FS_GET_INFO		2
+#define J4FS_EXIT			4
+
+#ifndef __KERNEL__
+#define J4FS_FORMAT		3
+#endif
+
+#define J4FS_FILE_TYPE		0x12345678
+#define J4FS_MAGIC			0x87654321
+
+/*
+  * device : This field indicates the device(partition) number to be acted upon. Device can also be thought of as a partition. This field is STL partition id.
+  * status : This field provides a mechanism to pass a detailed failure back to the application. Typical functions will place a detailed error in this field
+  *               and return SUCCESS or FAILURE back to the calling function.
+  * buffer  : This field provides a pointer to a memory buffer to translate data either to or from a function
+  * count  : This field indicates the number of bytes transferred. This field is usually used on write operations
+  * actual  : This field indicates whether or not a read or write is possible to a position by comparing the requested source file size with the actual size
+  *              of the target position.
+  * scmd   : This field provides a subcommand for possible use in the future
+  * type    : PCMCIA requires that LFS headers contain a stamp indicating the type of the header. For our implementation, this field has been assigned
+  *              ZERO (0), indicating the 32 byte header above.
+  * id        : This value is unique to each file object. This unique id field is to be used as a file identifier
+  * aux     : This field does not get initialized in the FlashDevMount function. It provides a mechanism to pass extra information to/from the low-level
+  *              function set
+  * index   : file offset to read or write
+ */
+typedef struct {
+	DWORD device;
+	DWORD status;
+	BYTE *buffer;
+	DWORD count;
+	DWORD actual;
+	DWORD scmd;
+	DWORD type;
+	DWORD id;
+	DWORD aux;
+	DWORD index;
+} j4fs_ctrl;
+
+
+/*
+  * we assume j4fs_header is aligned with page size
+  *
+  * link     : This field contains the offset from the start of this header to the next LFS header in the device(partition). If each bit in this field is equal to bit D0
+  *             of the flags field, this is the last entry in the device.
+  * size    : This is the actual size of the LFS header. [Obsoleted]
+  * type   : PCMCIA requires that LFS headers contain a stamp indicating the type of the header. For our implementation, this field has been assigned ZERO
+  *             (0), indicating the 32-byte header above. This type field is assigned to this header to distinguish it from other headers that may exist
+  *             in the device. This prevents the FSD from reading a header it cannot interpret.
+  * offset : This field indicates how far from the start of this header into the entry the file data begins. This allows LFS implementations that use extended
+  *             headers to be compatible with drivers that can't read the extended header.[Obsoleted]
+  * flags   : This is a bit-mapped flags field. Bit D0 indicates the nature of the flash (1 erase or 0 erase). Bit D1 indicates whether or not this file entry is
+  *             valid or deleted: if D1 matches D0 the file is valid, if D1 differs, than that file is deleted
+  * stroff  : This field points to the extended header associated with this file. The actual location of the filename string is determined by adding the value
+  *             in this field to the address of the LFS_HEADER. If this field is zero, there is no filename.[Obsoleted]
+  * id       : This value is unique to each file object. This unique id field is to be used as a file identifier
+  * length : file data length
+  * filename : filename
+*/
+typedef struct {
+	DWORD link;
+	DWORD size;
+	DWORD type;
+	DWORD offset;
+	DWORD flags;
+	DWORD stroff;
+	DWORD id;
+	DWORD length;
+	BYTE filename[J4FS_NAME_LEN];
+} j4fs_header;
+
+
+/*
+  * device  : This field indicates the device (partition) number to be acted upon. Device can also be thought of as a partition. This field is STL partition id.
+  * status  : This field provides a mechanism to pass a detailed failure back to the application. Typical functions will place a detailed error in this field and
+                   return SUCCESS or FAILURE back to the calling function
+  * blocksize : This field should be initialized by the FlashDevMount function and provides a mechanism to allow multiple devices (partitions) with
+  *                  different Intel components (which may have different block sizes). This field should reflect the size of media that will be erased when
+  *                  one block is erased in Bytes.
+  * pagesize  : This field indicates the size of page in Bytes.
+  * numberblocks : This field indicates the number of blocks in the entire media. If their are two flash cards, each would be considered its own media.
+  *                         If the media is an RFA, each RFA is considered its own media
+  * j4fs_offset : This field indicates the beginning address of data area of the device (partition) in Bytes. This address follows the
+  *                     Media Status Table(MST) and MST starts from offset 0.
+  * j4fs_size : This value indicates the size of the device (partition) in Bytes.
+  * j4fs_end : This field indicates the address of the end of the current device(partition) in Bytes. The device(partition) starts from offset 0.
+  * aux : This field does not get initialized in the FlashDevMount function. It provides a mechanism to pass extra information to/from the low-level function set
+  */
+typedef struct {
+	DWORD device;
+	DWORD status;
+	DWORD blocksize;
+	DWORD pagesize;
+	DWORD numberblocks;
+	DWORD j4fs_offset;
+	DWORD j4fs_size;
+	DWORD j4fs_end;
+	DWORD j4fs_device_end;
+	DWORD aux;
+
+#ifdef __KERNEL__
+	struct semaphore grossLock;	/* Gross locking semaphore */
+#endif
+} j4fs_device_info;
+
+
+/*
+  * J4FS Media Status Table(MST)
+  * This structure is used for reclaim including POR. The MST will reserve one block and will be used during initialization and reclaim.
+  * This MST is intended to assist in making the J4FS more robust. It provides memory to store status updates when reclaim is occurring,
+  * so that the system may recover form an unexpected power-off. If (from,to,end) is all 0, no reclaim is needed or reclaim is done.(Initial state)
+       If (from,to,end) is not 0, reclaim is in progress and should reclaim-restart from 'from,to member'
+  * magic : J4FS_MAGIC
+  * from , to(Bytes) : copy from 'from offset' to 'to offset' (4096Bytes data).
+  * end(Bytes) : end offset of 'from offset'.
+  * offset(Bytes) : beginning offsets of new arranged valid files excluding invalid files
+  * offset_number : number of offset array
+  */
+typedef struct {
+	DWORD magic;
+	DWORD from;
+	DWORD to;
+	DWORD end;
+	DWORD copyed;
+	DWORD offset[J4FS_MAX_FILE_NUM];
+	DWORD offset_number;
+	DWORD status;
+	DWORD rw_start;
+} j4fs_mst;
+
+#ifdef J4FS_TRANSACTION_LOGGING
+/*
+  * transaction structure for j4fs crash debugging. size should be 512B.
+  */
+typedef struct {
+	DWORD offset;
+	DWORD opcode;
+	DWORD sequence;
+	DWORD magic;
+
+	DWORD ino;
+	DWORD index;
+	DWORD count;
+	DWORD reserved1;
+
+	DWORD b_link;
+	DWORD b_length;
+	DWORD a_link;
+	DWORD a_length;
+
+	BYTE filename[J4FS_NAME_LEN];
+	BYTE reserved2[336];
+} j4fs_transaction;
+
+#define J4FS_TRANSACTION_SIZE	512
+#endif
+
+extern int j4fs_close(void);
+
+#ifdef __KERNEL__
+extern ino_t j4fs_inode_by_name(struct inode * dir, struct dentry *dentry);
+extern struct inode *j4fs_alloc_inode(struct super_block *sb);
+extern void j4fs_destroy_inode(struct inode *inode);
+extern void j4fs_read_inode (struct inode * inode);
+extern int  j4fs_init(void);
+extern void print_j4fs_inode(struct j4fs_inode *raw_inode);
+extern int j4fs_get_block(struct inode *inode, sector_t iblock, struct buffer_head *bh_result,  int create);
+extern int j4fs_get_blocks(struct inode *inode, sector_t iblock, unsigned long maxblocks, struct buffer_head *bh_result,  int create);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
+extern int j4fs_permission(struct inode *inode, int mask);
+#else
+extern int j4fs_permission(struct inode *inode, int mask, struct nameidata *nd);
+#endif
+
+extern int j4fs_readpage_unlock(struct file *f, struct page *page);
+extern int j4fs_readpage_nolock(struct file *f, struct page *page);
+extern int j4fs_file_write(struct file *f, const char *buf, size_t n,loff_t *pos);
+extern int j4fs_hold_space(int size);
+
+extern void msleep(unsigned int msecs);
+
+extern const struct inode_operations j4fs_file_inode_operations;
+extern const struct file_operations j4fs_file_operations;
+extern const struct inode_operations j4fs_dir_inode_operations;
+extern const struct file_operations j4fs_dir_operations;
+extern const struct address_space_operations j4fs_aops;
+extern const struct super_operations j4fs_sops;
+
+static inline struct j4fs_inode_info *J4FS_I(struct inode *inode)
+{
+	return container_of(inode, struct j4fs_inode_info, vfs_inode);
+}
+#else
+extern int j4fs_test(void);
+extern int j4fs_open(void);
+#endif
+
+
+extern int fsd_open(j4fs_ctrl *);
+extern int fsd_close(j4fs_ctrl *);
+extern int fsd_read(j4fs_ctrl *);
+extern int fsd_write(j4fs_ctrl *);
+extern int fsd_delete(j4fs_ctrl *);
+extern int fsd_special(j4fs_ctrl *);
+extern int fsd_print_meta_data(void);
+extern int fsd_read_ro_header(void);
+extern int fsd_mark_invalid(void);
+extern int fsd_reclaim(void);
+extern int fsd_panic(void);
+extern int is_invalid_j4fs_rw_start(void);
+#ifdef J4FS_TRANSACTION_LOGGING
+extern int fsd_initialize_transaction(void);
+#endif
+
+extern int FlashDevRead(j4fs_device_info *dev_ptr, DWORD offset, DWORD length, BYTE *buffer);
+extern int FlashDevWrite(j4fs_device_info *dev_ptr, DWORD offset, DWORD length, BYTE *buffer);
+extern int FlashDevErase(j4fs_device_info *dev_ptr);
+extern int FlashDevMount(void);
+extern int FlashDevUnmount(void);
+extern int FlashDevSpecial(j4fs_device_info *dev_ptr, DWORD scmd);
+
+#ifdef __KERNEL__
+#define TOUT(p) printk p
+#else
+#define TOUT(p) printf p
+#endif
diff -urNp Kernel/drivers/j4fs/j4fs_kernel.c HelloWorld-Renew-v1.0-n7000-jb/drivers/j4fs/j4fs_kernel.c
--- Kernel/drivers/j4fs/j4fs_kernel.c	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/drivers/j4fs/j4fs_kernel.c	2013-04-29 16:41:35.146587461 +0200
@@ -0,0 +1,1556 @@
+/*
+ * This software is the confidential and proprietary information
+ * of Samsung Electronics, Inc. ("Confidential Information").  You
+ * shall not disclose such Confidential Information and shall use
+ * it only in accordance with the terms of the license agreement
+ * you entered into with Samsung.
+ */
+/*
+ * j4fs_fs.c
+ *
+ * External interface to other kernel subsystems
+ *
+ * COPYRIGHT(C) Samsung Electronics Co.Ltd. 2009-2010 All Right Reserved.
+ *
+ * 2009.02 - First editing by SungHwan.yun <sunghwan.yun@samsung.com> @LDK@
+ *
+ * 2009.03 - Currently managed by  SungHwan.yun <sunghwan.yun@samsung.com> @LDK@
+ *
+ */
+#include <linux/time.h>
+#include <linux/highuid.h>
+#include <linux/pagemap.h>
+#include <linux/quotaops.h>
+#include <linux/module.h>
+#include <linux/writeback.h>
+#include <linux/buffer_head.h>
+#include <linux/mpage.h>
+#include <linux/slab.h>
+#include "j4fs.h"
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 39))
+#include <linux/smp_lock.h>
+#endif
+
+#if defined(J4FS_USE_XSR)
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28))
+#include "./Inc/XsrTypes.h"
+#include "./Inc/STL.h"
+#else
+#include "../../drivers/txsr/Inc/XsrTypes.h"
+#include "../../drivers/txsr/Inc/STL.h"
+#endif
+
+#elif defined(J4FS_USE_FSR)
+
+#include "../../tfsr/Inc/FSR.h"
+#include "../../tfsr/Inc/FSR_STL.h"
+
+#elif defined(J4FS_USE_MOVI)
+#else
+'compile error'
+#endif
+
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 27))
+#define J4FS_USE_WRITE_BEGIN_END 1
+#else
+#define J4FS_USE_WRITE_BEGIN_END 0
+#endif
+
+#define Page_Uptodate(page)	test_bit(PG_uptodate, &(page)->flags)
+
+extern j4fs_device_info device_info;
+extern unsigned int j4fs_traceMask;
+extern unsigned int j4fs_rw_start;
+extern int ro_j4fs_header_count;
+extern unsigned int j4fs_next_sequence;
+extern unsigned int j4fs_transaction_next_offset;
+extern int j4fs_panic;
+
+void j4fs_GrossLock(void)
+{
+	T(J4FS_TRACE_LOCK, ("j4fs locking %p\n", current));
+	down(&device_info.grossLock);
+	T(J4FS_TRACE_LOCK, ("j4fs locked %p\n", current));
+}
+
+void j4fs_GrossUnlock(void)
+{
+	T(J4FS_TRACE_LOCK, ("j4fs unlocking %p\n", current));
+	up(&device_info.grossLock);
+}
+
+int j4fs_readpage(struct file *f, struct page *page)
+{
+	T(J4FS_TRACE_FS_READ,("%s %d\n",__FUNCTION__,__LINE__));
+	return j4fs_readpage_unlock(f, page);
+}
+
+int j4fs_readpage_unlock(struct file *f, struct page *page)
+{
+	int ret = j4fs_readpage_nolock(f, page);
+	unlock_page(page);
+	return ret;
+}
+
+int j4fs_readpage_nolock(struct file *f, struct page *page)
+{
+	/* Lifted from yaffs2 */
+	unsigned char *page_buf;
+	int ret;
+	struct address_space *mapping = page->mapping;
+	struct inode *inode;
+	j4fs_ctrl ctl;
+
+	T(J4FS_TRACE_FS_READ,("%s %d\n",__FUNCTION__,__LINE__));
+
+	BUG_ON(!PageLocked(page));
+
+	if (!mapping) BUG();
+
+	inode = mapping->host;
+
+	if (!inode) BUG();
+
+	page_buf = kmap(page);
+	/* FIXME: Can kmap fail? */
+
+	j4fs_GrossLock();
+
+	ctl.buffer=page_buf;
+	ctl.count=PAGE_CACHE_SIZE;
+	ctl.id=inode->i_ino;
+	ctl.index=page->index << PAGE_CACHE_SHIFT;
+	ret=fsd_read(&ctl);
+
+	j4fs_GrossUnlock();
+
+	if (ret >= 0)
+		ret = 0;
+
+	if (ret) {
+		ClearPageUptodate(page);
+		SetPageError(page);
+	} else {
+		SetPageUptodate(page);
+		ClearPageError(page);
+	}
+
+	flush_dcache_page(page);
+	kunmap(page);
+
+	return ret;
+}
+
+int j4fs_writepage(struct page *page, struct writeback_control *wbc)
+{
+	struct address_space *mapping = page->mapping;
+	loff_t offset = (loff_t) page->index << PAGE_CACHE_SHIFT;
+	struct inode *inode;
+	unsigned long end_index;
+	char *buffer;
+	int nWritten = 0;
+	unsigned nBytes;
+	j4fs_ctrl ctl;
+	int nErr;
+
+	if(j4fs_panic==1) {
+		T(J4FS_TRACE_ALWAYS,("%s %d: j4fs panic\n",__FUNCTION__,__LINE__));
+		return -ENOSPC;
+	}
+
+	T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+
+	if (!mapping) BUG();
+
+	inode = mapping->host;
+
+	if (!inode) BUG();
+
+	if (offset > inode->i_size) {
+		T(J4FS_TRACE_FS,
+			("j4fs_writepage at %08x, inode size = %08x!!!\n",
+			(unsigned)(page->index << PAGE_CACHE_SHIFT),
+			(unsigned)inode->i_size));
+		T(J4FS_TRACE_FS,
+			("                -> don't care!!\n"));
+		unlock_page(page);
+		return 0;
+	}
+
+	end_index = inode->i_size >> PAGE_CACHE_SHIFT;
+
+	/* easy case */
+	if (page->index < end_index)
+		nBytes = PAGE_CACHE_SIZE;
+	else
+		nBytes = inode->i_size & (PAGE_CACHE_SIZE - 1);
+
+	get_page(page);
+
+	buffer = kmap(page);
+
+	j4fs_GrossLock();
+
+	T(J4FS_TRACE_FS,
+		("j4fs_writepage: index=%08x,nBytes=%08x,inode.i_size=%05x\n", (unsigned)(page->index << PAGE_CACHE_SHIFT), nBytes,(int)inode->i_size));
+
+	// write file
+	ctl.buffer=buffer;
+	ctl.count=nBytes;
+	ctl.id=inode->i_ino;
+	ctl.index=offset;
+
+	nErr=fsd_write(&ctl);
+
+	if(nErr==J4FS_RETRY_WRITE) nErr=fsd_write(&ctl);
+
+	T(J4FS_TRACE_FS,
+		("j4fs_writepage: index=%08x,nBytes=%08x,inode.i_size=%05x\n", (unsigned)(page->index << PAGE_CACHE_SHIFT), nBytes,(int)inode->i_size));
+
+	j4fs_GrossUnlock();
+
+	kunmap(page);
+	SetPageUptodate(page);
+	unlock_page(page);
+	put_page(page);
+
+	return (nWritten == nBytes) ? 0 : -ENOSPC;
+
+}
+
+#if (J4FS_USE_WRITE_BEGIN_END > 0)
+int j4fs_write_begin(struct file *filp, struct address_space *mapping,
+				loff_t pos, unsigned len, unsigned flags,
+				struct page **pagep, void **fsdata)
+{
+	struct page *pg = NULL;
+	pgoff_t index = pos >> PAGE_CACHE_SHIFT;
+	uint32_t offset = pos & (PAGE_CACHE_SIZE - 1);
+	uint32_t to = offset + len;
+
+	int ret = 0;
+	int space_held = 0;
+
+	if(j4fs_panic==1) {
+		T(J4FS_TRACE_ALWAYS,("%s %d: j4fs panic\n",__FUNCTION__,__LINE__));
+		return -ENOSPC;
+	}
+
+	T(J4FS_TRACE_FS, ("start j4fs_write_begin\n"));
+
+	if(to>PAGE_CACHE_SIZE) {
+		T(J4FS_TRACE_ALWAYS,("%s %d: page size overflow(pos,index,offset,len,to)=(%lld,%lu,%d,%d,%d)\n",__FUNCTION__,__LINE__,pos,index,offset,len,to));
+		j4fs_panic("page size overflow");
+		return -ENOSPC;
+	}
+
+	/* Get a page */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
+	pg = grab_cache_page_write_begin(mapping, index, flags);
+#else
+	pg = __grab_cache_page(mapping, index);
+#endif
+
+	*pagep = pg;
+	if (!pg) {
+		ret =  -ENOMEM;
+		goto out;
+	}
+
+	/* Get fs space */
+	space_held = j4fs_hold_space(PAGE_CACHE_SIZE);
+
+	if (!space_held) {
+		ret = -ENOSPC;
+		goto out;
+	}
+
+	/* Update page if required */
+	if (!Page_Uptodate(pg) && (offset || to < PAGE_CACHE_SIZE))
+		ret = j4fs_readpage_nolock(filp, pg);
+
+	if (ret)
+		goto out;
+
+	/* Happy path return */
+	T(J4FS_TRACE_FS, ("end j4fs_write_begin - ok\n"));
+
+	return 0;
+
+out:
+	T(J4FS_TRACE_FS, ("end j4fs_write_begin fail returning %d\n", ret));
+
+	if (pg) {
+		unlock_page(pg);
+		page_cache_release(pg);
+	}
+	return ret;
+}
+
+#else
+
+int j4fs_prepare_write(struct file *f, struct page *pg,
+				unsigned offset, unsigned to)
+{
+	if(j4fs_panic==1) {
+		T(J4FS_TRACE_ALWAYS,("%s %d: j4fs panic\n",__FUNCTION__,__LINE__));
+		return -ENOSPC;
+	}
+
+	T(J4FS_TRACE_FS, ("\nj4fs_prepare_write\n"));
+
+	if(to>PAGE_CACHE_SIZE) {
+		T(J4FS_TRACE_ALWAYS,("%s %d: page size overflow(offset,to)=(%d,%d)\n",__FUNCTION__,__LINE__,offset,to));
+		j4fs_panic("page size overflow");
+		return -ENOSPC;
+	}
+
+	if (!Page_Uptodate(pg) && (offset || to < PAGE_CACHE_SIZE))
+		return j4fs_readpage_nolock(f, pg);
+	return 0;
+}
+#endif
+
+#if (J4FS_USE_WRITE_BEGIN_END > 0)
+int j4fs_write_end(struct file *filp, struct address_space *mapping,
+				loff_t pos, unsigned len, unsigned copied,
+				struct page *pg, void *fsdadata)
+{
+	int ret = 0;
+	void *addr, *kva;
+	uint32_t offset_into_page = pos & (PAGE_CACHE_SIZE - 1);
+
+	if(j4fs_panic==1) {
+		T(J4FS_TRACE_ALWAYS,("%s %d: j4fs panic\n",__FUNCTION__,__LINE__));
+		return -ENOSPC;
+	}
+
+	if(offset_into_page+copied > PAGE_CACHE_SIZE) {
+		T(J4FS_TRACE_ALWAYS,("%s %d: page size overflow(offset_into_page,copied)=(%d,%d)\n",__FUNCTION__,__LINE__,offset_into_page, copied));
+		j4fs_panic("page size overflow");
+		return -ENOSPC;
+	}
+
+	kva = kmap(pg);
+	addr = kva + offset_into_page;
+
+	T(J4FS_TRACE_FS,
+		("j4fs_write_end addr %x pos %x nBytes %d\n",
+		(unsigned) addr,
+		(int)pos, copied));
+
+	ret = j4fs_file_write(filp, addr, copied, &pos);
+
+	if (ret != copied) {
+		T(J4FS_TRACE_ALWAYS, ("j4fs_write_end not same size ret %d  copied %d\n", ret, copied));
+		SetPageError(pg);
+		ClearPageUptodate(pg);
+	} else {
+		SetPageUptodate(pg);
+	}
+
+	kunmap(pg);
+
+	unlock_page(pg);
+	page_cache_release(pg);
+	return ret;
+}
+#else
+
+int j4fs_commit_write(struct file *f, struct page *pg, unsigned offset, unsigned to)
+{
+	void *addr, *kva;
+
+	loff_t pos = (((loff_t) pg->index) << PAGE_CACHE_SHIFT) + offset;
+	int nBytes = to - offset;
+	int nWritten;
+
+	unsigned spos = pos;
+	unsigned saddr;
+
+	if(j4fs_panic==1) {
+		T(J4FS_TRACE_ALWAYS,("%s %d: j4fs panic\n",__FUNCTION__,__LINE__));
+		return -ENOSPC;
+	}
+
+	if(offset+nBytes > PAGE_CACHE_SIZE) {
+		T(J4FS_TRACE_ALWAYS,("%s %d: page size overflow(offset,nBytes)=(%d,%d)\n",__FUNCTION__,__LINE__, offset, nBytes));
+		j4fs_panic("page size overflow");
+		return -ENOSPC;
+	}
+
+	kva = kmap(pg);
+	addr = kva + offset;
+
+	saddr = (unsigned) addr;
+
+	T(J4FS_TRACE_FS, ("j4fs_commit_write: (addr,pos,nBytes)=(0x%x, 0x%x, 0x%x)\n", saddr, spos, nBytes));
+
+	nWritten = j4fs_file_write(f, addr, nBytes, &pos);
+
+	if (nWritten != nBytes) {
+		T(J4FS_TRACE_ALWAYS, ("j4fs_commit_write: (nWritten,nBytes)=(0x%x 0x%x)\n", nWritten, nBytes));
+		SetPageError(pg);
+		ClearPageUptodate(pg);
+	} else {
+		SetPageUptodate(pg);
+	}
+
+	kunmap(pg);
+
+	return nWritten == nBytes ? 0 : nWritten;
+}
+#endif
+
+int j4fs_file_write(struct file *f, const char *buf, size_t n, loff_t *pos)
+{
+	int nWritten, ipos;
+	struct inode *inode;
+	j4fs_ctrl ctl;
+
+	if(j4fs_panic==1) {
+		T(J4FS_TRACE_ALWAYS,("%s %d: j4fs panic\n",__FUNCTION__,__LINE__));
+		return -ENOSPC;
+	}
+
+	j4fs_GrossLock();
+
+	inode = f->f_dentry->d_inode;
+
+	if (!S_ISBLK(inode->i_mode) && f->f_flags & O_APPEND)
+		ipos = inode->i_size;
+	else
+		ipos = *pos;
+
+	T(J4FS_TRACE_FS,("j4fs_file_write: %zu bytes to ino %ld at %d\n", n, inode->i_ino, ipos));
+
+	// write file
+	ctl.buffer=(BYTE *)buf;
+	ctl.count=n;
+	ctl.id=inode->i_ino;
+	ctl.index=ipos;
+
+	nWritten=fsd_write(&ctl);
+
+	if(nWritten==J4FS_RETRY_WRITE) nWritten=fsd_write(&ctl);
+
+	if(nWritten==J4FS_RETRY_WRITE || error(nWritten))
+	{
+		T(J4FS_TRACE_ALWAYS,("%s %d: Error(nWritten=0x%x)\n",__FUNCTION__,__LINE__,nWritten));
+		j4fs_GrossUnlock();
+		return -ENOSPC;
+	}
+
+	if (nWritten > 0) {
+		ipos += nWritten;
+		*pos = ipos;
+		if (ipos > inode->i_size) {
+			inode->i_size = ipos;
+			inode->i_blocks = (ipos + 511) >> 9;
+		}
+
+	}
+	j4fs_GrossUnlock();
+	return nWritten == 0 ? -ENOSPC : nWritten;
+}
+
+struct j4fs_inode *j4fs_get_inode(struct super_block *sb, ino_t ino)
+{
+	unsigned int cur_link, latest_matching_offset=0xffffffff;
+	struct j4fs_inode *raw_inode;
+	int nErr;
+	BYTE *buf;
+
+	T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+
+	buf=kmalloc(J4FS_BASIC_UNIT_SIZE,GFP_NOFS);
+
+	if(j4fs_panic==1) {
+		T(J4FS_TRACE_ALWAYS,("%s %d: j4fs panic\n",__FUNCTION__,__LINE__));
+		goto error1;
+	}
+
+	if (ino != J4FS_ROOT_INO && ino < J4FS_FIRST_INO) goto Einval;
+
+	if(ino==J4FS_ROOT_INO) goto error1;
+
+	// read j4fs_header in flash which inode number is ino
+	cur_link=device_info.j4fs_offset;
+	while(cur_link!=0xffffffff)
+	{
+		// check the partition range
+		j4fs_check_partition_range(cur_link);
+
+		nErr = FlashDevRead(&device_info, cur_link, J4FS_BASIC_UNIT_SIZE, buf);
+		if (nErr != 0) {
+			T(J4FS_TRACE_ALWAYS,("%s %d: error(nErr=0x%x)\n",__FUNCTION__,__LINE__,nErr));
+			goto error1;
+		}
+
+		raw_inode = (struct j4fs_inode *)buf;
+
+		//This j4fs_header cannot be interpreted. It means there are no files in this partition(this can happen and this is a normal case) or
+		//this j4fs partition is crashed(this should not happen).
+		if(raw_inode->i_type!=J4FS_FILE_TYPE)
+		{
+			// There are no files in this partition or this first j4fs_header is crashed. So, this case should not happen and/or should be repaired.
+			if(cur_link==device_info.j4fs_offset) {
+				j4fs_panic("There are no files in this partition or this first j4fs_header is crashed. So, this case should not happen and/or should be repaired.");
+				goto error1;
+			}
+
+			// This j4fs partition is crashed by some abnormal cause. This should not happen and should be repaired.
+			j4fs_panic("this j4fs partition is crashed by some abnormal cause.  This should not happen and should be repaired.");
+			goto error1;
+		}
+
+		// check whether this file was deleted
+		if ((raw_inode->i_flags&0x1)==((raw_inode->i_flags&0x2)>>1)) {
+			if(raw_inode->i_id==ino) latest_matching_offset=cur_link;
+		}
+
+		cur_link=raw_inode->i_link;
+	}
+
+	if(latest_matching_offset!=0xffffffff)
+	{
+		nErr = FlashDevRead(&device_info, latest_matching_offset, J4FS_BASIC_UNIT_SIZE, buf);
+		if (nErr != 0) {
+			T(J4FS_TRACE_ALWAYS,("%s %d: error(nErr=0x%x)\n",__FUNCTION__,__LINE__,nErr));
+			goto error1;
+		}
+
+		raw_inode = (struct j4fs_inode *)buf;
+		return raw_inode;
+	}
+
+Einval:
+	T(J4FS_TRACE_ALWAYS,("%s %d: error(bad inode number: %lu)\n",__FUNCTION__,__LINE__,(unsigned long) ino));
+	kfree(buf);
+	return ERR_PTR(-EINVAL);
+
+error1:
+	kfree(buf);
+	return NULL;
+
+}
+
+void j4fs_read_inode (struct inode * inode)
+{
+	struct j4fs_inode_info *ei = J4FS_I(inode);
+	ino_t ino = inode->i_ino;
+	struct j4fs_inode * raw_inode;
+
+	if(j4fs_panic==1) {
+		T(J4FS_TRACE_ALWAYS,("%s %d: j4fs panic\n",__FUNCTION__,__LINE__));
+		return;
+	}
+
+	T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+
+	// root inode
+	if(ino==J4FS_ROOT_INO)
+	{
+		inode->i_size = 0;
+		inode->i_mode=S_IFDIR|S_IWUSR|S_IRUGO|S_IXUGO;
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29))
+	inode->i_uid=current->fsuid;
+	inode->i_gid=current->fsgid;
+#else
+	inode->i_uid=current->cred->fsuid;
+	inode->i_gid=current->cred->fsgid;
+#endif
+
+		strcpy(ei->i_filename,"/");
+		ei->i_link=device_info.j4fs_offset;
+		ei->i_type=J4FS_FILE_TYPE;
+		ei->i_flags=0x3;
+		ei->i_id=J4FS_ROOT_INO;
+		ei->i_length=0;
+
+		inode->i_op = &j4fs_dir_inode_operations;
+		inode->i_mapping->a_ops = &j4fs_aops;
+		inode->i_fop = &j4fs_dir_operations;
+
+		return;
+	}
+
+	raw_inode = j4fs_get_inode(inode->i_sb, ino);
+
+	if (IS_ERR(raw_inode))
+		goto bad_inode;
+
+	inode->i_size = le32_to_cpu(raw_inode->i_length);
+	inode->i_mode=S_IFREG|S_IWUGO|S_IRUGO|S_IXUGO;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29))
+	inode->i_uid=current->fsuid;
+	inode->i_gid=current->fsgid;
+#else
+	inode->i_uid=current->cred->fsuid;
+	inode->i_gid=current->cred->fsgid;
+#endif
+
+	strcpy(ei->i_filename,raw_inode->i_filename);
+	ei->i_link=raw_inode->i_link;
+	ei->i_type=raw_inode->i_type;
+	ei->i_flags=raw_inode->i_flags;
+	ei->i_id=raw_inode->i_id;
+	ei->i_length=raw_inode->i_length;
+
+	if (S_ISREG(inode->i_mode)) {
+		inode->i_op = &j4fs_file_inode_operations;
+		inode->i_mapping->a_ops = &j4fs_aops;
+		inode->i_fop = &j4fs_file_operations;
+	}
+
+	kfree(raw_inode);
+	inode->i_flags |= S_SYNC;
+	return;
+
+bad_inode:
+	make_bad_inode(inode);
+}
+
+// TODO : Consider 'dir'
+ino_t j4fs_inode_by_name(struct inode * dir, struct dentry *dentry)
+{
+	unsigned int cur_link;
+	struct j4fs_inode_info *ei = J4FS_I(dir);
+	struct j4fs_inode *raw_inode;
+	ino_t ino;
+	int nErr;
+	BYTE *buf;
+
+	if(j4fs_panic==1) {
+		T(J4FS_TRACE_ALWAYS,("%s %d: j4fs panic\n",__FUNCTION__,__LINE__));
+		return 0;
+	}
+
+	T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+
+	buf=kmalloc(J4FS_BASIC_UNIT_SIZE,GFP_NOFS);
+
+	cur_link=ei->i_link;
+	while(cur_link!=0xffffffff)
+	{
+		// check the partition range
+		j4fs_check_partition_range(cur_link);
+
+		nErr = FlashDevRead(&device_info, cur_link, J4FS_BASIC_UNIT_SIZE, buf);
+		if (nErr != 0) {
+			T(J4FS_TRACE_ALWAYS,("%s %d: error(nErr=0x%x)\n",__FUNCTION__,__LINE__,nErr));
+			goto error1;
+		}
+
+		raw_inode = (struct j4fs_inode *) buf;
+
+		//This j4fs_header cannot be interpreted. It means there are no files in this partition(this can happen and this is a normal case) or
+		//this j4fs partition is crashed(this should not happen).
+		if(raw_inode->i_type!=J4FS_FILE_TYPE)
+		{
+			// There are no files in this partition or this first j4fs_header is crashed. So, this case should not happen and/or should be repaired.
+			if(cur_link==ei->i_link) {
+				j4fs_panic("There are no files in this partition or this first j4fs_header is crashed. So, this case should not happen and/or should be repaired.");
+				goto error1;
+			}
+
+			// This j4fs partition is crashed by some abnormal cause. This should not happen and should be repaired.
+			j4fs_panic("this j4fs partition is crashed by some abnormal cause.  This should not happen and should be repaired.");
+			goto error1;
+		}
+
+		// check whether this file was deleted
+		if ((raw_inode->i_flags&0x1)==((raw_inode->i_flags&0x2)>>1)) {
+			if(!strcmp(raw_inode->i_filename, dentry->d_name.name))
+			{
+				ino = raw_inode->i_id;
+				kfree(buf);
+				return ino;
+			}
+		}
+
+		cur_link=raw_inode->i_link;
+	}
+
+error1:
+	kfree(buf);
+
+	return 0;
+
+}
+
+static DWORD valid_offset[128][2];
+int j4fs_readdir (struct file * filp, void * dirent, filldir_t filldir)
+{
+	unsigned int curoffs, offset, cur_link;
+	struct inode *inode = filp->f_dentry->d_inode;
+	struct j4fs_inode_info *ei = J4FS_I(inode);
+	struct j4fs_inode *raw_inode;
+	int i,j, nErr;
+	BYTE *buf;
+	int count=0;
+
+	if(j4fs_panic==1) {
+		T(J4FS_TRACE_ALWAYS,("%s %d: j4fs panic\n",__FUNCTION__,__LINE__));
+		return 0;
+	}
+
+	T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+
+	memset(valid_offset, 0x00, sizeof(valid_offset));
+
+	buf=kmalloc(J4FS_BASIC_UNIT_SIZE,GFP_NOFS);
+
+	j4fs_GrossLock();
+
+	offset = filp->f_pos;
+
+	if (offset == 0) {
+		nErr=filldir(dirent, ".", 1, offset, filp->f_dentry->d_inode->i_ino, DT_DIR);
+		if (nErr != 0) {
+			T(J4FS_TRACE_ALWAYS,("%s %d: error(nErr=0x%x)\n",__FUNCTION__,__LINE__,nErr));
+			goto error1;
+		}
+		offset++;
+		filp->f_pos++;
+	}
+
+	if (offset == 1) {
+		nErr=filldir(dirent, "..", 2, offset,filp->f_dentry->d_parent->d_inode->i_ino, DT_DIR);
+		if (nErr != 0) {
+			T(J4FS_TRACE_ALWAYS,("%s %d: error(nErr=0x%x)\n",__FUNCTION__,__LINE__,nErr));
+			goto error1;
+		}
+		offset++;
+		filp->f_pos++;
+	}
+
+	curoffs = 1;
+
+	cur_link=ei->i_link;
+	while(cur_link!=0xffffffff)
+	{
+		// check the partition range
+		j4fs_check_partition_range(cur_link);
+
+		nErr = FlashDevRead(&device_info, cur_link, J4FS_BASIC_UNIT_SIZE, buf);
+		if (nErr != 0) {
+			T(J4FS_TRACE_ALWAYS,("%s %d: error(nErr=0x%x)\n",__FUNCTION__,__LINE__,nErr));
+			goto error1;
+		}
+
+		raw_inode = (struct j4fs_inode *) buf;
+
+		//This j4fs_header cannot be interpreted. It means there are no files in this partition(this can happen and this is a normal case) or
+		//this j4fs partition is crashed(this should not happen).
+		if(raw_inode->i_type!=J4FS_FILE_TYPE)
+		{
+			// There are no files in this partition or this first j4fs_header is crashed. So, this case should not happen and/or should be repaired.
+			if(cur_link==ei->i_link) {
+				j4fs_panic("There are no files in this partition or this first j4fs_header is crashed. So, this case should not happen and/or should be repaired.");
+				goto error1;
+			}
+
+			// This j4fs partition is crashed by some abnormal cause. This should not happen and should be repaired.
+			j4fs_panic("this j4fs partition is crashed by some abnormal cause.  This should not happen and should be repaired.");
+			goto error1;
+		}
+
+		// check whether this file was deleted
+		if ((raw_inode->i_flags&0x1)==((raw_inode->i_flags&0x2)>>1)) {
+			valid_offset[count][0]=raw_inode->i_id;
+			valid_offset[count][1]=cur_link;
+			count++;
+		}
+		cur_link=raw_inode->i_link;
+	}
+
+	// TODO: we exclude last object header because last object header can't decide invalidation of old files. Is it right ???
+	// Add files(latest valid object) to directory entry
+	for(i=0;i<count;i++)
+	{
+		for(j=i+1;j<count;j++)
+		{
+			// If inode number is same, valid_offset[i] is invalid
+			if(valid_offset[i][0]==valid_offset[j][0]) break;
+		}
+
+		// Add latest valid object to directory entry
+		if(j==count)
+		{
+			curoffs++;
+			if(curoffs >= offset)
+			{
+				nErr = FlashDevRead(&device_info, valid_offset[i][1], J4FS_BASIC_UNIT_SIZE, buf);
+				if (nErr != 0) {
+					T(J4FS_TRACE_ALWAYS,("%s %d: error(nErr=0x%x)\n",__FUNCTION__,__LINE__,nErr));
+					goto error1;
+				}
+
+				raw_inode = (struct j4fs_inode *) buf;
+
+				nErr=filldir(dirent, raw_inode->i_filename, strlen(raw_inode->i_filename), offset, raw_inode->i_id, DT_REG);
+
+				if(nErr <0) {
+					T(J4FS_TRACE_ALWAYS,("%s %d: error(nErr=0x%08x,filename=%s, file length=%d)\n",__FUNCTION__,__LINE__,nErr,raw_inode->i_filename, strlen(raw_inode->i_filename)));
+					goto error1;
+				}
+				else
+				{
+					T(J4FS_TRACE_FS,("%s %d: success(filename=%s, file length=%d)\n",__FUNCTION__,__LINE__,raw_inode->i_filename, strlen(raw_inode->i_filename)));
+					offset++;
+					filp->f_pos++;
+				}
+			}
+		}
+	}
+
+error1:
+	kfree(buf);
+	j4fs_GrossUnlock();
+	return 0;
+}
+
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
+int j4fs_permission(struct inode *inode, int mask)
+#else
+int j4fs_permission(struct inode *inode, int mask, struct nameidata *nd)
+#endif
+{
+	return 0;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
+struct inode *j4fs_iget(struct super_block *sb, unsigned long ino)
+{
+	struct inode * inode;
+	inode = iget_locked(sb, ino);
+
+	if (!inode)
+		return ERR_PTR(-ENOMEM);
+
+	if (!(inode->i_state & I_NEW))
+		return inode;
+
+	j4fs_read_inode(inode);
+	unlock_new_inode(inode);
+	return inode;
+}
+#endif
+
+struct dentry *j4fs_lookup(struct inode * dir, struct dentry *dentry, struct nameidata *nd)
+{
+	struct inode * inode;
+	ino_t ino;
+
+	T(J4FS_TRACE_FS,("%s %d:(filename=%s)\n",__FUNCTION__,__LINE__,dentry->d_name.name));
+
+	if (dentry->d_name.len > J4FS_NAME_LEN)
+		return ERR_PTR(-ENAMETOOLONG);
+
+	ino = j4fs_inode_by_name(dir, dentry);
+	inode = NULL;
+	if (ino) {
+	#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
+		inode = j4fs_iget(dir->i_sb, ino);
+	#else
+		inode = iget(dir->i_sb, ino);
+	#endif
+		if (!inode)
+			return ERR_PTR(-EACCES);
+	}
+	return d_splice_alias(inode, dentry);
+}
+
+struct inode *j4fs_new_inode(struct inode *dir, struct dentry *dentry, int mode)
+{
+	struct super_block *sb;
+	struct inode * inode;
+	struct j4fs_inode_info *ei;
+	unsigned int offset, last_object_offset=0xffffffff, new_object_offset=0xffffffff;
+	struct j4fs_inode *raw_inode=0;
+	ino_t ino = J4FS_FIRST_INO-1;
+	int nErr;
+	BYTE *buf;
+
+#ifdef J4FS_TRANSACTION_LOGGING
+	j4fs_transaction *transaction;
+#endif
+
+	if(j4fs_panic==1) {
+		T(J4FS_TRACE_ALWAYS,("%s %d: j4fs panic\n",__FUNCTION__,__LINE__));
+		return NULL;
+	}
+
+	T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+
+	// allocate new inode
+	sb = dir->i_sb;
+	inode = new_inode(sb);
+	if (!inode) {
+		return ERR_PTR(-ENOMEM);
+	}
+
+	buf=kmalloc(J4FS_BASIC_UNIT_SIZE,GFP_NOFS);
+
+#ifdef J4FS_TRANSACTION_LOGGING
+	transaction=kmalloc(J4FS_TRANSACTION_SIZE,GFP_NOFS);
+#endif
+
+	ei = J4FS_I(inode);
+
+	if(is_invalid_j4fs_rw_start())
+	{
+		T(J4FS_TRACE_ALWAYS,("%s %d: Error! j4fs_rw_start is invalid(j4fs_rw_start=0x%08x, j4fs_end=0x%08x, ro_j4fs_header_count=0x%08x)\n",
+			__FUNCTION__, __LINE__, j4fs_rw_start, device_info.j4fs_end, ro_j4fs_header_count));
+		j4fs_panic("j4fs_rw_start is invalid");
+		goto error1;
+	}
+
+	// find existing largest inode number
+	// TODO: 1. RO files --> use ro_j4fs_header buffer
+	offset=device_info.j4fs_offset;
+	while(offset!=0xffffffff)
+	{
+		// check the partition range
+		j4fs_check_partition_range(offset);
+
+		// read j4fs_header
+		nErr = FlashDevRead(&device_info, offset, J4FS_BASIC_UNIT_SIZE, buf);
+		if (nErr != 0) {
+			T(J4FS_TRACE_ALWAYS,("%s %d: error(nErr=0x%x)\n",__FUNCTION__,__LINE__,nErr));
+			goto error1;
+		}
+
+		raw_inode	= (struct j4fs_inode *)buf;
+
+		//This j4fs_header cannot be interpreted. It means there are no files in this partition(this can happen and this is a normal case) or
+		//this j4fs partition is crashed(this should not happen).
+		if(raw_inode->i_type!=J4FS_FILE_TYPE)
+		{
+			// There are no files in this partition or this first j4fs_header is crashed. So, this case should not happen and/or should be repaired.
+			if(offset==device_info.j4fs_offset) {
+				j4fs_panic("There are no files in this partition or this first j4fs_header is crashed. So, this case should not happen and/or should be repaired.");
+				goto error1;;
+			}
+
+			// This j4fs partition is crashed by some abnormal cause. This should not happen and should be repaired.
+			j4fs_panic("this j4fs partition is crashed by some abnormal cause.  This should not happen and should be repaired.");
+			goto error1;
+		}
+
+		// check whether this file was deleted
+		if ((raw_inode->i_flags&0x1)==((raw_inode->i_flags&0x2)>>1)) {
+			if(raw_inode->i_id>ino) ino=raw_inode->i_id;
+		}
+
+		last_object_offset=offset;
+		offset=raw_inode->i_link;
+	}
+
+	// set inode number
+	ino++;
+
+	ei->i_id=ino;
+	inode->i_ino = ino;
+	inode->i_mode=S_IFREG|S_IWUGO|S_IRUGO|S_IXUGO;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29))
+	inode->i_uid=current->fsuid;
+	inode->i_gid=current->fsgid;
+#else
+	inode->i_uid=current->cred->fsuid;
+	inode->i_gid=current->cred->fsgid;
+#endif
+	inode->i_op = &j4fs_file_inode_operations;
+	inode->i_mapping->a_ops = &j4fs_aops;
+	inode->i_fop = &j4fs_file_operations;
+	inode->i_flags |= S_SYNC;
+
+	if(last_object_offset!=0xffffffff)
+	{
+		T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+		new_object_offset=last_object_offset;
+		new_object_offset+=J4FS_BASIC_UNIT_SIZE;	// j4fs_header
+		new_object_offset+=raw_inode->i_length;	// data
+		new_object_offset=(new_object_offset+J4FS_BASIC_UNIT_SIZE-1)/J4FS_BASIC_UNIT_SIZE*J4FS_BASIC_UNIT_SIZE;	// J4FS_BASIC_UNIT_SIZE align
+	}
+	else	//there are no files in this partition, so write first offset of partition
+	{
+		j4fs_panic("There are no files in this partition. There should be one file in j4fs file system at least");
+		goto error1;
+	}
+
+	if((new_object_offset+J4FS_BASIC_UNIT_SIZE-1)>device_info.j4fs_end)
+	{
+		T(J4FS_TRACE_ALWAYS,("%s %d: partition size overflow(new_object_offset=0x%08x, j4fs_end=0x%08x)\n",__FUNCTION__,__LINE__,new_object_offset,device_info.j4fs_end));
+		goto error1;
+	}
+
+#ifdef J4FS_TRANSACTION_LOGGING
+	// setting transaction variable
+	memset(transaction,0xff,J4FS_TRANSACTION_SIZE);
+	transaction->magic=J4FS_MAGIC;
+	transaction->sequence=j4fs_next_sequence++;
+	transaction->ino=ino;
+	memcpy(transaction->filename,dentry->d_name.name,dentry->d_name.len);
+	transaction->filename[dentry->d_name.len]=0;
+	transaction->opcode=J4FS_LAST_OBJECT_CREATE_STEP1;
+	transaction->offset=new_object_offset;
+	transaction->b_link=transaction->a_link=0xffffffff;
+	transaction->b_length=transaction->a_length=0;
+
+	nErr = FlashDevWrite(&device_info, j4fs_transaction_next_offset, J4FS_TRANSACTION_SIZE, (BYTE *)transaction);
+
+	if (error(nErr)) {
+		T(J4FS_TRACE_ALWAYS,("%s %d: error(nErr=0x%x)\n",__FUNCTION__,__LINE__,nErr));
+		goto error1;
+	}
+
+	j4fs_transaction_next_offset+=J4FS_TRANSACTION_SIZE;
+	if(j4fs_transaction_next_offset>=device_info.j4fs_device_end) j4fs_transaction_next_offset=device_info.j4fs_end;
+#endif
+
+	// add new object(j4fs_header)
+	T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+	memset(buf, 0xff, J4FS_BASIC_UNIT_SIZE);
+	raw_inode = (struct j4fs_inode *)buf;
+	raw_inode->i_link=0xffffffff;
+	raw_inode->i_type=J4FS_FILE_TYPE;
+	raw_inode->i_flags=0x3;
+	raw_inode->i_id=ino;
+	raw_inode->i_length=0;
+	memcpy(raw_inode->i_filename, dentry->d_name.name, dentry->d_name.len);
+	raw_inode->i_filename[dentry->d_name.len]=0;
+
+	nErr = FlashDevWrite(&device_info, new_object_offset, J4FS_BASIC_UNIT_SIZE, buf);
+	if (nErr != 0) {
+		T(J4FS_TRACE_ALWAYS,("%s %d: error(nErr=0x%x)\n",__FUNCTION__,__LINE__,nErr));
+		goto error1;
+	}
+
+	// update last_inode
+	if(last_object_offset!=0xffffffff)
+	{
+		T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+		nErr = FlashDevRead(&device_info, last_object_offset, J4FS_BASIC_UNIT_SIZE, buf);
+		if (nErr != 0) {
+			T(J4FS_TRACE_ALWAYS,("%s %d: error(nErr=0x%x)\n",__FUNCTION__,__LINE__,nErr));
+			goto error1;
+		}
+
+		raw_inode = (struct j4fs_inode *)buf;
+
+
+	#ifdef J4FS_TRANSACTION_LOGGING
+		// setting transaction variable
+		memset(transaction,0xff,J4FS_TRANSACTION_SIZE);
+		transaction->magic=J4FS_MAGIC;
+		transaction->sequence=j4fs_next_sequence++;
+		transaction->ino=raw_inode->i_id;
+		strcpy(transaction->filename,raw_inode->i_filename);
+		transaction->opcode=J4FS_LAST_OBJECT_CREATE_STEP2;
+		transaction->offset=last_object_offset;
+		transaction->b_link=raw_inode->i_link;
+		transaction->a_link=new_object_offset;
+		transaction->b_length=transaction->a_length=raw_inode->i_length;
+
+		nErr = FlashDevWrite(&device_info, j4fs_transaction_next_offset, J4FS_TRANSACTION_SIZE, (BYTE *)transaction);
+
+		if (error(nErr)) {
+			T(J4FS_TRACE_ALWAYS,("%s %d: error(nErr=0x%x)\n",__FUNCTION__,__LINE__,nErr));
+			goto error1;
+		}
+
+		j4fs_transaction_next_offset+=J4FS_TRANSACTION_SIZE;
+		if(j4fs_transaction_next_offset>=device_info.j4fs_device_end) j4fs_transaction_next_offset=device_info.j4fs_end;
+	#endif
+
+		raw_inode->i_link=new_object_offset;
+
+		nErr = FlashDevWrite(&device_info, last_object_offset, J4FS_BASIC_UNIT_SIZE, buf);
+		if (nErr != 0) {
+			T(J4FS_TRACE_ALWAYS,("%s %d: error(nErr=0x%x)\n",__FUNCTION__,__LINE__,nErr));
+			goto error1;
+		}
+	}
+
+	kfree(buf);
+	return inode;
+
+error1:
+	kfree(buf);
+#ifdef J4FS_TRANSACTION_LOGGING
+	kfree(transaction);
+#endif
+	return NULL;
+}
+
+
+/*
+ *	Parent is locked.
+ */
+int j4fs_add_link (struct dentry *dentry, struct inode *inode)
+{
+	// write j4fs_header
+	// TODO
+	T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+
+	return 0;
+
+}
+
+int j4fs_add_nondir(struct dentry *dentry, struct inode *inode)
+{
+	int err;
+
+	T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+
+	err= j4fs_add_link(dentry, inode);
+	if (!err) {
+		d_instantiate(dentry, inode);
+		return 0;
+	}
+	inode_dec_link_count(inode);
+	iput(inode);
+	return err;
+}
+
+/*
+ * By the time this is called, we already have created
+ * the directory cache entry for the new file, but it
+ * is so far negative - it has no inode.
+ * This function is call by do_filp_open()->open_namei()->open_namei_create()->vfs_create()->dir->i_op->create()
+ *
+ * If the create succeeds, we fill in the inode information
+ * with d_instantiate().
+ */
+int j4fs_create (struct inode * dir, struct dentry * dentry, int mode, struct nameidata *nd)
+{
+	struct inode * inode;
+	int err=-1;
+
+	if(j4fs_panic==1) {
+		T(J4FS_TRACE_ALWAYS,("%s %d: j4fs panic\n",__FUNCTION__,__LINE__));
+		return err;
+	}
+
+	T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+
+	inode = j4fs_new_inode(dir, dentry, mode);
+
+	if (!IS_ERR(inode)) {
+		inode->i_op = &j4fs_file_inode_operations;
+		inode->i_mapping->a_ops = &j4fs_aops;
+		inode->i_fop = &j4fs_file_operations;
+
+		//mark_inode_dirty(inode);
+		err = j4fs_add_nondir(dentry, inode);
+	}
+	return err;
+}
+
+/* Space holding and freeing is done to ensure we have space available for write_begin/end */
+/* For now we just assume few parallel writes and check against a small number. */
+/* Todo: need to do this with a counter to handle parallel reads better */
+
+int j4fs_hold_space(int size)
+{
+	unsigned int offset, last_object_offset=0xffffffff, new_object_offset=0xffffffff;
+	struct j4fs_inode *raw_inode=NULL;
+	int nErr;
+	BYTE *buf;
+
+	if(j4fs_panic==1) {
+		T(J4FS_TRACE_ALWAYS,("%s %d: j4fs panic\n",__FUNCTION__,__LINE__));
+		return 0;
+	}
+
+	buf=kmalloc(J4FS_BASIC_UNIT_SIZE,GFP_NOFS);
+
+	// find existing largest inode number
+	offset=device_info.j4fs_offset;
+	while(offset!=0xffffffff)
+	{
+		// check the partition range
+		j4fs_check_partition_range(offset);
+
+		// read j4fs_header
+		nErr = FlashDevRead(&device_info, offset, J4FS_BASIC_UNIT_SIZE, buf);
+		if (nErr != 0) {
+			T(J4FS_TRACE_ALWAYS,("%s %d: error(nErr=0x%x)\n",__FUNCTION__,__LINE__,nErr));
+			goto error1;
+		}
+
+		raw_inode = (struct j4fs_inode *)buf;
+
+		//This j4fs_header cannot be interpreted. It means there are no files in this partition(this can happen and this is a normal case) or
+		//this j4fs partition is crashed(this should not happen).
+		if(raw_inode->i_type!=J4FS_FILE_TYPE)
+		{
+			// There are no files in this partition or this first j4fs_header is crashed. So, this case should not happen and/or should be repaired.
+			if(offset==device_info.j4fs_offset) {
+				j4fs_panic("There are no files in this partition or this first j4fs_header is crashed. So, this case should not happen and/or should be repaired.");
+				goto error1;
+			}
+
+			// This j4fs partition is crashed by some abnormal cause. This should not happen and should be repaired.
+			j4fs_panic("this j4fs partition is crashed by some abnormal cause.  This should not happen and should be repaired.");
+			goto error1;
+		}
+
+		last_object_offset=offset;
+		offset=raw_inode->i_link;
+	}
+
+	if(last_object_offset!=0xffffffff)
+	{
+		T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+		new_object_offset=last_object_offset;
+		new_object_offset+=J4FS_BASIC_UNIT_SIZE;	// j4fs_header
+		new_object_offset+=raw_inode->i_length;	// data
+		new_object_offset=(new_object_offset+J4FS_BASIC_UNIT_SIZE-1)/J4FS_BASIC_UNIT_SIZE*J4FS_BASIC_UNIT_SIZE;	// 4096 align
+	}
+
+	kfree(buf);
+	if((new_object_offset+size-1)>device_info.j4fs_end) return 0;
+	else return 1;
+
+error1:
+	kfree(buf);
+	return 0;
+}
+
+int j4fs_fill_super(struct super_block *sb, void *data, int silent)
+{
+	struct j4fs_sb_info * sbi;
+	struct j4fs_super_block * es;
+	struct inode *root;
+#ifndef J4FS_USE_MOVI
+	u32 tmp, len;
+#endif
+	u32 ret;
+
+	T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+
+	sbi = kzalloc(sizeof(*sbi), GFP_NOFS);
+	if (!sbi)
+		return -ENOMEM;
+
+	es=kzalloc(sizeof(*es), GFP_NOFS);
+	if (!es)
+	{
+		kfree(sbi);
+		return -ENOMEM;
+	}
+
+	sb->s_fs_info = sbi;
+	sbi->s_es = es;
+	sbi->s_first_ino=J4FS_FIRST_INO;
+
+	// Block size is J4FS_BASIC_UNIT_SIZE (4096)
+	sb->s_flags = 0;
+	sb->s_maxbytes = 0xffffffff;
+
+	sb->s_blocksize=J4FS_BASIC_UNIT_SIZE;
+	sb->s_blocksize_bits=J4FS_BASIC_UNIT_SIZE_BITS;
+	sb->s_op = &j4fs_sops;
+	sb->s_xattr = NULL;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
+	root=j4fs_iget(sb, J4FS_ROOT_INO);
+#else
+	root = iget(sb, J4FS_ROOT_INO);
+#endif
+
+	sb->s_root = d_alloc_root(root);
+
+	// Set device_info.j4fs_end using STLInfo.nTotalLogScts
+#if defined(J4FS_USE_XSR)
+	ret = STL_IOCtl(0, device_info.device, STL_IOCTL_LOG_SECTS, NULL, sizeof(u32), &tmp, sizeof(u32), &len);
+#elif defined(J4FS_USE_FSR)
+	ret = FSR_STL_IOCtl(0, device_info.device, FSR_STL_IOCTL_LOG_SECTS, NULL, sizeof(u32), &tmp, sizeof(u32), &len);
+#endif
+
+#if defined(J4FS_USE_XSR) || defined(J4FS_USE_FSR)
+	if (ret) {
+		T(J4FS_TRACE_ALWAYS,("%s %d: Error(0x%08x)\n",__FUNCTION__,__LINE__,ret));
+		return -EINVAL;
+	}
+
+	// j4fs transaction(1 block) for fils system crash debugging
+	// J4FS_BASIC_UNIT_SIZE align
+	device_info.j4fs_device_end=((tmp/(J4FS_BASIC_UNIT_SIZE/512))*(J4FS_BASIC_UNIT_SIZE/512))*512-1;
+	device_info.j4fs_end=device_info.j4fs_device_end-PHYSICAL_BLOCK_SIZE;
+#elif defined(J4FS_USE_MOVI)
+	// j4fs transaction(1 block) for fils system crash debugging
+	// J4FS_BASIC_UNIT_SIZE align
+	device_info.j4fs_device_end=(((J4FS_BLOCK_COUNT * 512)/(J4FS_BASIC_UNIT_SIZE/512))*(J4FS_BASIC_UNIT_SIZE/512))*512-1;
+	device_info.j4fs_end=device_info.j4fs_device_end-PHYSICAL_BLOCK_SIZE;
+#endif
+
+	T(J4FS_TRACE_FS,("%s %d: device_info.j4fs_end=0x%08x, device_info.j4fs_device_end=0x%08x\n",__FUNCTION__,__LINE__,device_info.j4fs_end,device_info.j4fs_device_end));
+
+	if (!sb->s_root) {
+		iput(root);
+		T(J4FS_TRACE_ALWAYS,("%s %d: error\n",__FUNCTION__,__LINE__));
+		goto failed;
+	}
+
+	init_MUTEX(&device_info.grossLock);
+
+#ifdef J4FS_TRANSACTION_LOGGING
+	ret=fsd_initialize_transaction();
+
+	if (error(ret)) {
+		T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+		goto failed;
+	}
+
+	T(J4FS_TRACE_FS,("%s %d: j4fs_next_sequence=0x%08x, j4fs_transaction_next_offset=0x%08x\n",__FUNCTION__,__LINE__,j4fs_next_sequence,j4fs_transaction_next_offset));
+#endif
+
+	ret=fsd_reclaim();
+
+	if (error(ret)) {
+		T(J4FS_TRACE_ALWAYS,("%s %d: Error(nErr=0x%08x)\n",__FUNCTION__,__LINE__,ret));
+		goto failed;
+	}
+
+	return 0;
+
+failed:
+	sb->s_fs_info = NULL;
+	kfree(sbi);
+	kfree(es);
+	return -EINVAL;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+static struct dentry *j4fs_mount(struct file_system_type *fs_type, int flags, const char *dev_name, void *data)
+{
+	j4fs_ctrl ctl;
+
+	T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+
+	ctl.scmd=J4FS_INIT;
+	fsd_special(&ctl);
+
+	return mount_bdev(fs_type, flags, dev_name, data, j4fs_fill_super);
+}
+#else
+int j4fs_get_sb(struct file_system_type *fs_type, int flags, const char *dev_name, void *data, struct vfsmount *mnt)
+{
+	j4fs_ctrl ctl;
+
+	T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+
+	ctl.scmd=J4FS_INIT;
+	fsd_special(&ctl);
+
+	return get_sb_bdev(fs_type, flags, dev_name, data, j4fs_fill_super, mnt);
+}
+#endif
+
+void j4fs_kill_sb(struct super_block *sb)
+{
+#if defined(J4FS_USE_MOVI)
+	j4fs_ctrl ctl;
+#endif
+	T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+
+	kill_block_super(sb);
+
+#if defined(J4FS_USE_MOVI)
+	ctl.scmd=J4FS_EXIT;
+	fsd_special(&ctl);
+#endif
+}
+
+struct kmem_cache * j4fs_inode_cachep;
+
+struct inode *j4fs_alloc_inode(struct super_block *sb)
+{
+	struct j4fs_inode_info *ei;
+
+	T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+
+	ei = (struct j4fs_inode_info *)kmem_cache_alloc(j4fs_inode_cachep, GFP_NOFS);
+	if (!ei)
+		return NULL;
+
+	ei->vfs_inode.i_version = 1;
+	return &ei->vfs_inode;
+}
+
+void j4fs_destroy_inode(struct inode *inode)
+{
+	T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+
+	kmem_cache_free(j4fs_inode_cachep, J4FS_I(inode));
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
+void init_once(void *foo)
+#else
+void init_once(struct kmem_cache * cachep, void *foo)
+#endif
+{
+	struct j4fs_inode_info *ei = (struct j4fs_inode_info *) foo;
+
+	T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+
+	rwlock_init(&ei->i_meta_lock);
+	inode_init_once(&ei->vfs_inode);
+}
+
+int init_inodecache(void)
+{
+	j4fs_inode_cachep = kmem_cache_create("j4fs_inode_cache",
+					     sizeof(struct j4fs_inode_info),
+					     0, (SLAB_RECLAIM_ACCOUNT|
+						SLAB_MEM_SPREAD),
+					     init_once);
+	if (j4fs_inode_cachep == NULL)
+		return -ENOMEM;
+	return 0;
+}
+
+void destroy_inodecache(void)
+{
+	kmem_cache_destroy(j4fs_inode_cachep);
+}
+
+struct file_system_type j4fs_fs_type = {
+	.owner		= THIS_MODULE,
+	.name		= "j4fs",
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+	.mount		= j4fs_mount,
+#else
+	.get_sb		= j4fs_get_sb,
+#endif
+	.kill_sb	= j4fs_kill_sb,
+	.fs_flags	= FS_REQUIRES_DEV,
+};
+
+extern ssize_t (*lfs_read_module)(struct file *file, const char __user * buffer, size_t count, loff_t *ppos);
+extern ssize_t (*lfs_write_module)(struct file *file, const char __user * buffer, size_t count, loff_t *ppos);
+extern unsigned int j4fs_PORMask;
+extern unsigned int j4fs_PORCount;
+
+ssize_t lfs_read(struct file *file, const char __user * buffer, size_t count, loff_t *ppos)
+{
+	printk("%s %d: (j4fs_PORMask,j4fs_PORCount)=(%x,%d)\n",__FUNCTION__,__LINE__,j4fs_PORMask, j4fs_PORCount);
+	return 0;
+}
+
+ssize_t lfs_write(struct file *file, const char __user * buffer, size_t count, loff_t *ppos)
+{
+	char kbuf[1024];
+
+	if (copy_from_user(&kbuf, buffer, count))
+		return -EFAULT;
+
+	if (sscanf(kbuf, "%x %d", &j4fs_PORMask, &j4fs_PORCount) != 2)
+		return -EINVAL;
+
+	printk("%s %d: (j4fs_PORMask,j4fs_PORCount)=(%x,%d)\n",__FUNCTION__,__LINE__,j4fs_PORMask, j4fs_PORCount);
+	return -EINVAL;
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
+int j4fs_fsync(struct file *file, int datasync)
+#else
+int j4fs_fsync(struct file *file, struct dentry *dentry, int datasync)
+#endif
+{
+	return 0;
+}
+
+int __init init_j4fs_fs(void)
+{
+	int err;
+
+	T(J4FS_TRACE_ALWAYS,("%s %d: Version %d.%d.%dp%d_b%d\n",__FUNCTION__,__LINE__,
+				J4FS_VER_MAJOR, J4FS_VER_MINOR1, J4FS_VER_MINOR2, J4FS_VER_PATCHLEVEL, J4FS_BUILD_NUMBER));
+
+	err = init_inodecache();
+	if (err)
+		goto out1;
+
+	T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+
+        err = register_filesystem(&j4fs_fs_type);
+	if (err)
+		goto out;
+
+	T(J4FS_TRACE_FS,("%s %d\n",__FUNCTION__,__LINE__));
+
+	return 0;
+out:
+	destroy_inodecache();
+out1:
+	return err;
+}
+
+void __exit exit_j4fs_fs(void)
+{
+	unregister_filesystem(&j4fs_fs_type);
+	destroy_inodecache();
+}
+
+module_init(init_j4fs_fs)
+module_exit(exit_j4fs_fs)
+
+
+const struct address_space_operations j4fs_aops = {
+	.readpage		= j4fs_readpage,
+	.writepage		= j4fs_writepage,
+#if (J4FS_USE_WRITE_BEGIN_END > 0)
+	.write_begin = j4fs_write_begin,
+	.write_end = j4fs_write_end,
+#else
+	.prepare_write = j4fs_prepare_write,
+	.commit_write = j4fs_commit_write,
+#endif
+};
+
+const struct file_operations j4fs_file_operations = {
+	.read		= do_sync_read,
+	.write		= do_sync_write,
+	.aio_read	= generic_file_aio_read,
+	.aio_write	= generic_file_aio_write,
+	.open		= generic_file_open,
+	.llseek		= generic_file_llseek,
+	.fsync		= j4fs_fsync,
+};
+
+const struct file_operations j4fs_dir_operations = {
+	.llseek		= generic_file_llseek,
+	.read		= generic_read_dir,
+	.readdir		= j4fs_readdir,
+};
+
+const struct inode_operations j4fs_file_inode_operations = {
+	.permission = NULL,
+};
+
+const struct inode_operations j4fs_dir_inode_operations = {
+	.create		= j4fs_create,
+	.lookup		= j4fs_lookup,
+	.permission	= NULL,
+};
+
+const struct super_operations j4fs_sops = {
+	.alloc_inode	= j4fs_alloc_inode,
+	.destroy_inode	= j4fs_destroy_inode,
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 28)
+	.read_inode	= j4fs_read_inode,
+#endif
+};
diff -urNp Kernel/drivers/j4fs/Kconfig HelloWorld-Renew-v1.0-n7000-jb/drivers/j4fs/Kconfig
--- Kernel/drivers/j4fs/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/drivers/j4fs/Kconfig	2013-04-29 16:41:35.146587461 +0200
@@ -0,0 +1,53 @@
+menuconfig J4FS
+	tristate "Samsung J4FS"
+	help
+	   Samsung J4FS support.
+
+if J4FS
+
+choice
+	prompt "Select J4FS Interface"
+	default J4FS_USE_FSR
+
+config J4FS_USE_XSR
+	bool "XSR Interface"
+config J4FS_USE_FSR
+	bool "FSR Interface"
+config J4FS_USE_MOVI
+	bool "MOVI Interface"
+
+endchoice
+
+config J4FS_PARTITION_ID
+	int "Select Mount Partition ID"
+	depends on !J4FS_USE_MOVI
+	default 21
+	help
+	   Select Mount Partition ID.
+
+config J4FS_DEVNAME
+	string "Select Mount Partition Path"
+	depends on J4FS_USE_MOVI
+	default "/dev/block/mmcblk0p4"
+	help
+	   Select Mount Partition Path.
+
+config J4FS_PAGE_SHIFT
+	int "J4FS Page Size (11 -> 2048 KB or 12 -> 4096 KB)"
+	depends on J4FS
+	default 12
+	help
+	  Select Page Size.
+          Block Size is calculated by below formala.
+	  Example : Block Size = (Page Size * 64) KB
+
+config J4FS_BLOCK_COUNT
+	int "J4FS Block Count"
+	depends on J4FS_USE_MOVI
+	default 20
+	help
+	  Select Block Count.
+	  Blcok Size is decided by J4FS Page Size.
+	  Example : Blcok Count = (Total Size / Block Size)
+
+endif
diff -urNp Kernel/drivers/j4fs/llid_kernel.c HelloWorld-Renew-v1.0-n7000-jb/drivers/j4fs/llid_kernel.c
--- Kernel/drivers/j4fs/llid_kernel.c	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/drivers/j4fs/llid_kernel.c	2013-04-29 16:41:35.146587461 +0200
@@ -0,0 +1,232 @@
+/*
+ * This software is the confidential and proprietary information
+ * of Samsung Electronics, Inc. ("Confidential Information").  You
+ * shall not disclose such Confidential Information and shall use
+ * it only in accordance with the terms of the license agreement
+ * you entered into with Samsung.
+ */
+/*
+ * llid.c
+ *
+ * Low-Level Interface Driver
+ *
+ * COPYRIGHT(C) Samsung Electronics Co.Ltd. 2009-2010 All Right Reserved.
+ *
+ * 2009.02 - First editing by SungHwan.yun <sunghwan.yun@samsung.com> @LDK@
+ *
+ * 2009.03 - Currently managed by  SungHwan.yun <sunghwan.yun@samsung.com> @LDK@
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include "j4fs.h"
+
+#if defined(J4FS_USE_XSR)
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28))
+#include "./Inc/XsrTypes.h"
+#include "./Inc/STL.h"
+#else
+#include "../../drivers/txsr/Inc/XsrTypes.h"
+#include "../../drivers/txsr/Inc/STL.h"
+#endif
+
+#elif defined(J4FS_USE_FSR)
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28))
+#include "../../tfsr/Inc/FSR.h"
+#include "../../tfsr/Inc/FSR_STL.h"
+#else
+#include "../fsr/Inc/FSR.h"
+#include "../fsr/Inc/FSR_STL.h"
+#endif
+
+#elif defined(J4FS_USE_MOVI)
+/* j4fs device node name */
+#define J4FS_DEVNAME			CONFIG_J4FS_DEVNAME
+static struct file *j4fs_filp;
+
+#else
+'compile error'
+#endif
+
+extern j4fs_device_info device_info;
+extern unsigned int j4fs_traceMask;
+
+/*
+  * Fills the specified buffer with the number of bytes defined by length from the device's absolute physical address
+  * parameters
+  *   offset  : start physical page number
+  *   length  : bytes to write
+  *   buffer  : buffer to write data
+  * return value
+  *   The return code should indicate ERROR (1) or OK(0). If the return code indicates ERROR, the dev_ptr->status field should indicate
+  *   the return error code.
+  */
+int FlashDevRead(j4fs_device_info *dev_ptr, DWORD offset, DWORD length, BYTE *buffer)
+{
+#ifndef J4FS_USE_MOVI
+	DWORD nVol=0;
+	int part_id=dev_ptr->device;
+#endif
+	int ret=-1;
+
+#ifdef J4FS_USE_MOVI
+	mm_segment_t oldfs;
+#endif
+
+#if defined(J4FS_USE_XSR)
+	ret = STL_Read(nVol, part_id, offset/512, length/512, buffer);
+	if (ret != STL_SUCCESS) {
+		T(J4FS_TRACE_ALWAYS,("%s %d: Error(offset,length,j4fs_end,nErr)=(0x%x,0x%x,0x%x,0x%x)\n",__FUNCTION__,__LINE__,offset,length,device_info.j4fs_end,ret));
+		return J4FS_FAIL;
+	}
+#elif defined(J4FS_USE_FSR)
+	ret = FSR_STL_Read(nVol, part_id, offset/512, length/512, buffer, FSR_STL_FLAG_DEFAULT);
+	if (ret != FSR_STL_SUCCESS) {
+		T(J4FS_TRACE_ALWAYS,("%s %d: Error(offset,length,j4fs_end,nErr)=(0x%x,0x%x,0x%x,0x%x)\n",__FUNCTION__,__LINE__,offset,length,device_info.j4fs_end,ret));
+		return J4FS_FAIL;
+	}
+#elif defined(J4FS_USE_MOVI)
+	if (IS_ERR(j4fs_filp)) {
+		printk("J4FS not available\n");
+		return J4FS_FAIL;
+	}
+	j4fs_filp->f_flags |= O_NONBLOCK;
+	oldfs = get_fs(); set_fs(get_ds());
+	ret = j4fs_filp->f_op->llseek(j4fs_filp, offset, SEEK_SET);
+	ret = j4fs_filp->f_op->read(j4fs_filp, buffer, length, &j4fs_filp->f_pos);
+	set_fs(oldfs);
+	j4fs_filp->f_flags &= ~O_NONBLOCK;
+	if (ret < 0) {
+		printk("j4fs_filp->read() failed: %d\n", ret);
+		return J4FS_FAIL;
+	}
+#else
+'compile error'
+#endif
+
+	return J4FS_SUCCESS;
+}
+
+/*
+  * This function writes length bytes of data from a specified buffer to the destination address within the device
+  * parameters
+  *   offset  : start physical page number
+  *   length  : bytes to write
+  *   buffer  : buffer to write data
+  * return value
+  *   The return code should indicate ERROR (1) or OK(0). If the return code indicates ERROR, the dev_ptr->status field should indicate
+  *   the return error code.
+  */
+int FlashDevWrite(j4fs_device_info *dev_ptr, DWORD offset, DWORD length, BYTE *buffer)
+{
+#ifndef J4FS_USE_MOVI
+	DWORD nVol=0;
+	int part_id=dev_ptr->device;
+#endif
+	int ret=-1;
+
+#ifdef J4FS_USE_MOVI
+	mm_segment_t oldfs;
+#endif
+
+#if defined(J4FS_USE_XSR)
+	ret = STL_Write(nVol, part_id, offset/512, length/512, buffer);
+	if (ret != STL_SUCCESS) {
+		T(J4FS_TRACE_ALWAYS,("%s %d: Error(offset,length,j4fs_end,nErr)=(0x%x,0x%x,0x%x,0x%x)\n",__FUNCTION__,__LINE__,offset,length,device_info.j4fs_end,ret));
+		return J4FS_FAIL;
+	}
+#elif defined(J4FS_USE_FSR)
+	ret = FSR_STL_Write(nVol, part_id, offset/512, length/512, buffer, FSR_STL_FLAG_DEFAULT);
+	if (ret != FSR_STL_SUCCESS) {
+		T(J4FS_TRACE_ALWAYS,("%s %d: Error(offset,length,j4fs_end,nErr)=(0x%x,0x%x,0x%x,0x%x)\n",__FUNCTION__,__LINE__,offset,length,device_info.j4fs_end,ret));
+		return J4FS_FAIL;
+	}
+#elif defined(J4FS_USE_MOVI)
+	if (IS_ERR(j4fs_filp)) {
+		printk("J4FS not available\n");
+		return J4FS_FAIL;
+	}
+	j4fs_filp->f_flags |= O_NONBLOCK;
+	oldfs = get_fs(); set_fs(get_ds());
+	ret = j4fs_filp->f_op->llseek(j4fs_filp, offset, SEEK_SET);
+	ret = j4fs_filp->f_op->write(j4fs_filp, buffer, length, &j4fs_filp->f_pos);
+	set_fs(oldfs);
+	j4fs_filp->f_flags &= ~O_NONBLOCK;
+	if (ret < 0) {
+		printk("j4fs_filp->write() failed: %d\n", ret);
+		return J4FS_FAIL;
+	}
+#else
+'compile error'
+#endif
+
+	return J4FS_SUCCESS;
+}
+
+/*
+  * In order to reuse the flash media, an erase command must be provided for the FSD. This command erases a single flash erase-block beginning
+  * at the address specified by the aux field in the DEVICE_INFO structure. The blocksize field of the DEVICE_INFO structure is used to force the aux ptr
+  * to a block boundary.
+  * parameters
+  *   dev_ptr->aux : start block address to be erased
+  */
+int FlashDevErase(j4fs_device_info *dev_ptr)
+{
+	// TODO
+	return J4FS_SUCCESS;
+}
+
+int FlashDevSpecial(j4fs_device_info *dev_ptr, DWORD scmd)
+{
+	switch(scmd)
+	{
+		case J4FS_INIT:
+			// Initialize the internal FSD structures to use a device
+			FlashDevMount();
+
+			break;
+
+		case J4FS_GET_INFO:
+			break;
+
+		case J4FS_EXIT:
+			FlashDevUnmount();
+
+		default:
+			break;
+	}
+
+	return J4FS_SUCCESS;
+}
+
+int FlashDevMount()
+{
+	DWORD media_status_table_size=1;		//  Media Status Table occupys 1 block
+
+#ifdef J4FS_USE_MOVI
+	j4fs_filp = filp_open(J4FS_DEVNAME, O_RDWR|O_SYNC, 0);
+	if (IS_ERR(j4fs_filp)) {
+		printk("FlashDevMount : filp_open() failed~!: %ld\n", PTR_ERR(j4fs_filp));
+		return J4FS_FAIL;
+	}
+	printk("FlashDevMount : filp_open() OK....!\n");
+#endif
+
+	device_info.device=J4FS_PARTITION_ID;
+	device_info.blocksize=PHYSICAL_BLOCK_SIZE;
+	device_info.pagesize=PHYSICAL_PAGE_SIZE;
+	device_info.j4fs_offset=media_status_table_size*device_info.blocksize;	 // j4fs_offset follows the Media Status Table.
+	return J4FS_SUCCESS;
+}
+
+int FlashDevUnmount()
+{
+#ifdef J4FS_USE_MOVI
+	filp_close(j4fs_filp, NULL);
+	printk("FlashDevUnmount : filp_close() OK....!\n");
+#endif
+
+	return J4FS_SUCCESS;
+}
diff -urNp Kernel/drivers/j4fs/Makefile HelloWorld-Renew-v1.0-n7000-jb/drivers/j4fs/Makefile
--- Kernel/drivers/j4fs/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/drivers/j4fs/Makefile	2013-04-29 16:41:35.146587461 +0200
@@ -0,0 +1,31 @@
+##############################################################################
+# COPYRIGHT(C)	: Samsung Electronics Co.Ltd, 2006-2011 ALL RIGHTS RESERVED
+# 2009.02 - Currently managed by  JongMinKim <jm45.kim@samsung.com> , SungHwanYun <sunghwan.yun@samsung.com>
+##############################################################################
+# VERSION&DATE	: Version 1.00	2009/02
+##############################################################################
+
+MOD_NAME = j4fs
+
+ifneq ($(KERNELRELEASE), )
+
+EXTRA_CFLAGS +=  -I$(PRJROOT)/modules/include -I$(KDIR)/drivers/tfsr/Inc -I$(KDIR)/include -I$(KDIR)/include/linux -I$(KDIR)/include/asm -D__KERNEL
+
+obj-m := $(MOD_NAME).o
+
+$(MOD_NAME)-y := j4fs_kernel.o llid_kernel.o fsd_common.o
+
+else
+
+all:
+	@$(MAKE) -C $(KDIR) \
+		SUBDIRS=$(CURDIR) modules
+
+clean:
+	rm -f *.o *.ko *.mod.c *~ .*.cmd
+
+install:
+	@$(MAKE) --no-print-directory -C $(KDIR) \
+		SUBDIRS=$(CURDIR) modules_install
+
+endif
diff -urNp Kernel/drivers/Kconfig HelloWorld-Renew-v1.0-n7000-jb/drivers/Kconfig
--- Kernel/drivers/Kconfig	2013-02-21 05:35:59.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/drivers/Kconfig	2013-04-29 16:41:35.150587461 +0200
@@ -163,4 +163,6 @@ source "drivers/felica/Kconfig"
 # Authentec
 source "drivers/interceptor/Kconfig"
+source "drivers/j4fs/Kconfig"

 endmenu
diff -urNp Kernel/drivers/Makefile HelloWorld-Renew-v1.0-n7000-jb/drivers/Makefile
--- Kernel/drivers/Makefile	2013-02-21 05:37:27.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/drivers/Makefile	2013-04-30 18:54:45.426398311 +0200
@@ -148,6 +148,4 @@ obj-$(CONFIG_FELICA) += felica/
 
 obj-$(CONFIG_AUTHENTEC_VPNCLIENT_INTERCEPTOR) += interceptor/
 
+obj-$(CONFIG_J4FS)		+= j4fs/


diff -urNp Kernel/drivers/media/video/samsung/mali/Makefile HelloWorld-Renew-v1.0-n7000-jb/drivers/media/video/samsung/mali/Makefile
--- Kernel/drivers/media/video/samsung/mali/Makefile	2013-02-20 13:36:26.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/drivers/media/video/samsung/mali/Makefile	2013-04-29 16:41:35.150587461 +0200
@@ -115,7 +115,7 @@ DEFINES += -DMALI_POWER_MGMT_TEST_SUITE=
 DEFINES += -DMALI_MAJOR_PREDEFINE=$(USING_MALI_MAJOR_PREDEFINE)
 DEFINES += -DMALI_DVFS_ENABLED=$(USING_MALI_DVFS_ENABLED)
 DEFINES += -DUSING_MALI_PMM_EARLYSUSPEND=$(USING_MALI_PMM_EARLYSUSPEND)
-DEFINES += -DMALI_STATE_TRACKING=1
+DEFINES += -DMALI_STATE_TRACKING=0
 DEFINES += -DMALI_OS_MEMORY_KERNEL_BUFFER_SIZE_IN_MB=$(OS_MEMORY_KERNEL_BUFFER_SIZE_IN_MB)
 DEFINES += -DMALI_TRACEPOINTS_ENABLED=$(USING_TRACEPOINTS)
 DEFINES += -DMALI_REBOOTNOTIFIER
diff -urNp Kernel/drivers/media/video/samsung/mali/platform/mali_platform.h HelloWorld-Renew-v1.0-n7000-jb/drivers/media/video/samsung/mali/platform/mali_platform.h
--- Kernel/drivers/media/video/samsung/mali/platform/mali_platform.h	2013-02-20 13:36:26.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/drivers/media/video/samsung/mali/platform/mali_platform.h	2013-04-25 22:14:56.000000000 +0200
@@ -19,7 +19,7 @@
 #include "mali_osk.h"
 
 #ifdef CONFIG_CPU_EXYNOS4210
-#define MALI_DVFS_STEPS 2
+#define MALI_DVFS_STEPS 3
 #else
 #define MALI_DVFS_STEPS 5
 #endif
diff -urNp Kernel/drivers/media/video/samsung/mali/platform/orion-m400/mali_platform_dvfs.c HelloWorld-Renew-v1.0-n7000-jb/drivers/media/video/samsung/mali/platform/orion-m400/mali_platform_dvfs.c
--- Kernel/drivers/media/video/samsung/mali/platform/orion-m400/mali_platform_dvfs.c	2013-02-20 13:36:26.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/drivers/media/video/samsung/mali/platform/orion-m400/mali_platform_dvfs.c	2013-05-01 23:36:32.107401837 +0200
@@ -63,13 +63,15 @@ typedef struct mali_dvfs_staycount{
 }mali_dvfs_staycount_table;
 
 mali_dvfs_staycount_table mali_dvfs_staycount[MALI_DVFS_STEPS]={
-	/*step 0*/{1},
-	/*step 1*/{1},};
+		/*step 0*/{1},
+		/*step 1*/{1},
+		/*step 2*/{1} };
 
 /*dvfs threshold*/
 mali_dvfs_threshold_table mali_dvfs_threshold[MALI_DVFS_STEPS]={
-	/*step 0*/{((int)((255*0)/100)), ((int)((255*85)/100))},
-	/*step 1*/{((int)((255*75)/100)), ((int)((255*100)/100))} };
+		/*step 0*/{((int)((255*0)/100))   ,((int)((255*30)/100))},
+		/*step 1*/{((int)((255*30)/100))  ,((int)((255*60)/100))},
+		/*step 2*/{((int)((255*50)/100))  ,((int)((255*100)/100))} };
 
 /*dvfs status*/
 mali_dvfs_currentstatus maliDvfsStatus;
@@ -77,8 +79,10 @@ int mali_dvfs_control=0;
 
 /*dvfs table*/
 mali_dvfs_table mali_dvfs[MALI_DVFS_STEPS]={
-	/*step 0*/{160  ,1000000    , 950000},
-	/*step 1*/{267  ,1000000    ,1000000} };
+			/* more pixels to push and bigger battery */
+			/*step 0*/{133  ,1000000    , 950000},
+			/*step 1*/{267  ,1000000    ,1000000},
+			/*step 2*/{400  ,1000000    ,1100000} };
 
 #ifdef EXYNOS4_ASV_ENABLED
 
@@ -86,24 +90,24 @@ mali_dvfs_table mali_dvfs[MALI_DVFS_STEP
 #define ASV_5_LEVEL	5
 
 static unsigned int asv_3d_volt_5_table[ASV_5_LEVEL][MALI_DVFS_STEPS] = {
-	/* L3(160MHz), L2(266MHz) */
-	{1000000, 1100000},	/* S */
-	{1000000, 1100000},	/* A */
-	{ 950000, 1000000},	/* B */
-	{ 950000, 1000000},	/* C */
-	{ 950000,  950000},	/* D */
+	/* L3 (133MHz) L2(267MHz), L1(400MHz) */
+	{1000000, 1100000, 1150000},    /* S */
+        {1000000, 1100000, 1150000},    /* A */
+        { 950000, 1000000, 1100000},    /* B */
+        { 950000, 1000000, 1050000},    /* C */
+        { 950000,  950000, 1000000},    /* D */
 };
 
 static unsigned int asv_3d_volt_8_table[ASV_8_LEVEL][MALI_DVFS_STEPS] = {
-	/* L3(160MHz), L2(266MHz)) */
-	{1000000, 1100000},	/* SS */
-	{1000000, 1100000},	/* A1 */
-	{1000000, 1100000},	/* A2 */
-	{ 950000, 1000000},	/* B1 */
-	{ 950000, 1000000},	/* B2 */
-	{ 950000, 1000000},	/* C1 */
-	{ 950000, 1000000},	/* C2 */
-	{ 950000,  950000},	/* D1 */
+	/* L3(133MHz), L2(267MHz)), L1(400MHz) */
+        {1000000, 1100000, 1150000},    /* SS */
+        {1000000, 1100000, 1150000},    /* A1 */
+        {1000000, 1100000, 1150000},    /* A2 */
+        { 950000, 1000000, 1100000},    /* B1 */
+        { 950000, 1000000, 1100000},    /* B2 */
+        { 950000, 1000000, 1050000},    /* C1 */
+        { 950000, 1000000, 1050000},    /* C2 */
+        { 950000,  950000, 1000000},    /* D1 */
 };
 #endif
 
@@ -186,7 +190,7 @@ static void mali_platform_wating(u32 mse
 		read_val = _mali_osk_mem_ioread32(clk_register_map, 0x00);
 		if ((read_val & 0x8000)==0x0000) break;
 
-		_mali_osk_time_ubusydelay(100); // 1000 -> 100 : 20101218
+		_mali_osk_time_ubusydelay(5000); //SpeedMod: 5ms // 1000 -> 100 : 20101218
 	}
 	/* _mali_osk_time_ubusydelay(msec*1000);*/
 }
@@ -215,20 +219,52 @@ static unsigned int decideNextStatus(uns
 #if MALI_GPU_BOTTOM_LOCK
 		if (_mali_osk_atomic_read(&bottomlock_status) > 0)
 			level = 1;	/* or bigger */
-		else if (utilization > mali_dvfs_threshold[maliDvfsStatus.currentStep].upthreshold)
-#else
-		if (utilization > mali_dvfs_threshold[maliDvfsStatus.currentStep].upthreshold)
-#endif
-			level=1;
-		else if (utilization < mali_dvfs_threshold[maliDvfsStatus.currentStep].downthreshold)
-			level=0;
 		else
-			level = maliDvfsStatus.currentStep;
-	} else	{
-		if ((mali_dvfs_control > 0) && (mali_dvfs_control < mali_dvfs[1].clock))
+#endif
+		switch(maliDvfsStatus.currentStep)
+		{
+			case 0:
+				if( utilization > mali_dvfs_threshold[maliDvfsStatus.currentStep].upthreshold)
+					level=1;
+				else
+					level = maliDvfsStatus.currentStep;
+				break;
+			case 1:
+				if( utilization > mali_dvfs_threshold[maliDvfsStatus.currentStep].upthreshold)
+					level=2;
+				else if( utilization <
+					 (mali_dvfs_threshold[maliDvfsStatus.currentStep].downthreshold*mali_dvfs[maliDvfsStatus.currentStep-1].clock)/
+					 mali_dvfs[maliDvfsStatus.currentStep].clock)
+					level=0;
+				else
+					level = maliDvfsStatus.currentStep;
+				break;
+			case 2:
+				if( utilization > mali_dvfs_threshold[maliDvfsStatus.currentStep].upthreshold)
+					level=2;
+				else if( utilization <
+					 (mali_dvfs_threshold[maliDvfsStatus.currentStep].downthreshold*mali_dvfs[maliDvfsStatus.currentStep-1].clock)/
+					 mali_dvfs[maliDvfsStatus.currentStep].clock)
+					level=1;
+				else
+					level = maliDvfsStatus.currentStep;
+				break;
+		}
+	}
+	else
+	{
+		if((mali_dvfs_control == 1)||(( mali_dvfs_control > 3) && (mali_dvfs_control < mali_dvfs[0].clock+1)))
+		{
 			level=0;
-		else
+		}
+		else if((mali_dvfs_control == 2)||(( mali_dvfs_control > mali_dvfs[0].clock) && (mali_dvfs_control < mali_dvfs[1].clock+1)))
+		{
 			level=1;
+		}
+		else
+		{
+			level=2;
+		}
 	}
 
 	return level;
diff -urNp Kernel/drivers/misc/fsync_control.c HelloWorld-Renew-v1.0-n7000-jb/drivers/misc/fsync_control.c
--- Kernel/drivers/misc/fsync_control.c	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/drivers/misc/fsync_control.c	2013-04-29 23:10:52.862653313 +0200
@@ -0,0 +1,110 @@
+/* drivers/misc/fsync_control.c
+ *
+ * Copyright 2012  Ezekeel
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+
+#define FSYNCCONTROL_VERSION 1
+
+static bool fsync_enabled = true;
+
+bool fsynccontrol_fsync_enabled()
+{
+    return fsync_enabled;
+}
+EXPORT_SYMBOL(fsynccontrol_fsync_enabled);
+
+static ssize_t fsynccontrol_status_read(struct device * dev, struct device_attribute * attr, char * buf)
+{
+    return sprintf(buf, "%u\n", (fsync_enabled ? 1 : 0));
+}
+
+static ssize_t fsynccontrol_status_write(struct device * dev, struct device_attribute * attr, const char * buf, size_t size)
+{
+    unsigned int data;
+
+    if(sscanf(buf, "%u\n", &data) == 1) 
+        {
+            if (data == 1) 
+                {
+                    pr_info("%s: FSYNCCONTROL fsync enabled\n", __FUNCTION__);
+
+                    fsync_enabled = true;
+
+                } 
+            else if (data == 0) 
+                {
+                    pr_info("%s: FSYNCCONTROL fsync disabled\n", __FUNCTION__);
+
+                    fsync_enabled = false;
+                } 
+            else 
+                {
+                    pr_info("%s: invalid input range %u\n", __FUNCTION__, data);
+                }
+        } 
+    else 
+        {
+            pr_info("%s: invalid input\n", __FUNCTION__);
+        }
+
+    return size;
+}
+
+static ssize_t fsynccontrol_version(struct device * dev, struct device_attribute * attr, char * buf)
+{
+    return sprintf(buf, "%u\n", FSYNCCONTROL_VERSION);
+}
+
+static DEVICE_ATTR(fsync_enabled, S_IRUGO | S_IWUGO, fsynccontrol_status_read, fsynccontrol_status_write);
+static DEVICE_ATTR(version, S_IRUGO , fsynccontrol_version, NULL);
+
+static struct attribute *fsynccontrol_attributes[] = 
+    {
+        &dev_attr_fsync_enabled.attr,
+        &dev_attr_version.attr,
+        NULL
+    };
+
+static struct attribute_group fsynccontrol_group = 
+    {
+        .attrs  = fsynccontrol_attributes,
+    };
+
+static struct miscdevice fsynccontrol_device = 
+    {
+        .minor = MISC_DYNAMIC_MINOR,
+        .name = "fsynccontrol",
+    };
+
+static int __init fsynccontrol_init(void)
+{
+    int ret;
+
+    pr_info("%s misc_register(%s)\n", __FUNCTION__, fsynccontrol_device.name);
+
+    ret = misc_register(&fsynccontrol_device);
+
+    if (ret) 
+        {
+            pr_err("%s misc_register(%s) fail\n", __FUNCTION__, fsynccontrol_device.name);
+            return 1;
+        }
+
+    if (sysfs_create_group(&fsynccontrol_device.this_device->kobj, &fsynccontrol_group) < 0) 
+        {
+            pr_err("%s sysfs_create_group fail\n", __FUNCTION__);
+            pr_err("Failed to create sysfs group for device (%s)!\n", fsynccontrol_device.name);
+        }
+
+    return 0;
+}
+
+device_initcall(fsynccontrol_init);
diff -urNp Kernel/drivers/misc/Kconfig HelloWorld-Renew-v1.0-n7000-jb/drivers/misc/Kconfig
--- Kernel/drivers/misc/Kconfig	2013-02-20 13:36:27.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/drivers/misc/Kconfig	2013-04-29 23:06:16.474652534 +0200
@@ -751,4 +751,10 @@ config SLP_PROCESS_MON
 	  Providing monitoring important processes. Users can register the process
 	  with sysfs.
 
+config FSYNC_CONTROL
+	bool "Support for FSync Control"
+	default y
+	help
+	..Say Y here to enable FSync Control
+
 endif # MISC_DEVICES
diff -urNp Kernel/drivers/misc/Makefile HelloWorld-Renew-v1.0-n7000-jb/drivers/misc/Makefile
--- Kernel/drivers/misc/Makefile	2013-02-20 13:36:27.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/drivers/misc/Makefile	2013-04-29 23:08:53.698652977 +0200
@@ -69,6 +69,7 @@ obj-$(CONFIG_MFD_MAX77693)	+= max77693-m
 obj-$(CONFIG_STMPE811_ADC)	+= stmpe811-adc.o
 obj-$(CONFIG_JACK_MON)		+= jack.o
 obj-$(CONFIG_UART_SELECT)	+= uart_select.o
+obj-$(CONFIG_FSYNC_CONTROL)     += fsync_control.o
 obj-$(CONFIG_WIMAX_CMC)         += max8893.o
 ifeq ($(CONFIG_MUIC_DET_JACK),y)
 obj-$(CONFIG_SEC_DEV_JACK)	+= sec_jack_muic.o
diff -urNp Kernel/drivers/mmc/host/mshci.c HelloWorld-Renew-v1.0-n7000-jb/drivers/mmc/host/mshci.c
--- Kernel/drivers/mmc/host/mshci.c	2013-02-20 13:36:28.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/drivers/mmc/host/mshci.c	2013-04-29 16:41:35.154587461 +0200
@@ -2040,7 +2040,8 @@ int mshci_add_host(struct mshci_host *ho
 	mmc->ops = &mshci_ops;
 	mmc->f_min = 400000;
 	mmc->f_max = host->max_clk;
-	mmc->caps |= MMC_CAP_SDIO_IRQ | MMC_CAP_ERASE;
+	//SpeedMod: Disable TRIM to fix hard brick bug 
+	mmc->caps |= MMC_CAP_SDIO_IRQ; // | MMC_CAP_ERASE;
 
 	mmc->caps |= MMC_CAP_4_BIT_DATA;
 
diff -urNp Kernel/drivers/mmc/host/sdhci.c HelloWorld-Renew-v1.0-n7000-jb/drivers/mmc/host/sdhci.c
--- Kernel/drivers/mmc/host/sdhci.c	2013-02-20 13:36:28.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/drivers/mmc/host/sdhci.c	2013-04-29 16:41:35.154587461 +0200
@@ -2636,7 +2636,8 @@ int sdhci_add_host(struct sdhci_host *ho
 	else
 		mmc->max_discard_to = (1 << 27) / host->timeout_clk;
 
-	mmc->caps |= MMC_CAP_SDIO_IRQ | MMC_CAP_ERASE;
+	//SpeedMod: Disable TRIM to fix hard brick bug
+	mmc->caps |= MMC_CAP_SDIO_IRQ; // | MMC_CAP_ERASE;
 
 	if (host->quirks & SDHCI_QUIRK_MULTIBLOCK_READ_ACMD12)
 		host->flags |= SDHCI_AUTO_CMD12;
diff -urNp Kernel/drivers/net/wireless/bcmdhd/dhd_linux.c HelloWorld-Renew-v1.0-n7000-jb/drivers/net/wireless/bcmdhd/dhd_linux.c
--- Kernel/drivers/net/wireless/bcmdhd/dhd_linux.c	2013-02-20 13:36:32.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/drivers/net/wireless/bcmdhd/dhd_linux.c	2013-05-02 00:10:13.459407536 +0200
@@ -4005,7 +4005,9 @@ dhd_preinit_ioctls(dhd_pub_t *dhd)
 #endif /* BLOCK_IPV6_PACKET */
 #if defined(PASS_IPV4_SUSPEND)
 	dhd->pktfilter_count = 5;
+	/* This filter actually permits all multicast. Disable */ 
 	dhd->pktfilter[4] = "104 0 0 0 0xFFFFFF 0x01005E";
+	dhd->pktfilter[4] = NULL;
 #endif
 #endif /* GAN_LITE_NAT_KEEPALIVE_FILTER */
 #ifdef PASS_ARP_PACKET
diff -urNp Kernel/drivers/power/sec_battery_u1.c HelloWorld-Renew-v1.0-n7000-jb/drivers/power/sec_battery_u1.c
--- Kernel/drivers/power/sec_battery_u1.c	2013-02-20 13:36:33.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/drivers/power/sec_battery_u1.c	2013-04-29 16:41:35.158587461 +0200
@@ -1496,7 +1496,7 @@ static int sec_bat_enable_charging_main(
 		switch (info->cable_type) {
 		case CABLE_TYPE_USB:
 			val_type.intval = POWER_SUPPLY_STATUS_CHARGING;
-			val_chg_current.intval = 450;	/* mA */
+			val_chg_current.intval = 650; //450;	/* mA */
 			break;
 		case CABLE_TYPE_AC:
 			val_type.intval = POWER_SUPPLY_STATUS_CHARGING;
@@ -1504,7 +1504,7 @@ static int sec_bat_enable_charging_main(
 			break;
 		case CABLE_TYPE_MISC:
 			val_type.intval = POWER_SUPPLY_STATUS_CHARGING;
-			val_chg_current.intval = 450;	/* mA */
+			val_chg_current.intval = 650; //450;	/* mA */
 			break;
 		default:
 			dev_err(info->dev, "%s: Invalid func use\n", __func__);
@@ -1585,7 +1585,7 @@ static int sec_bat_enable_charging_sub(s
 			switch (info->cable_type) {
 			case CABLE_TYPE_USB:
 				val_type.intval = POWER_SUPPLY_STATUS_CHARGING;
-				val_chg_current.intval = 450;	/* mA */
+				val_chg_current.intval = 650; //450;	/* mA */
 				break;
 			case CABLE_TYPE_AC:
 				val_type.intval = POWER_SUPPLY_STATUS_CHARGING;
@@ -1600,7 +1600,7 @@ static int sec_bat_enable_charging_sub(s
 				break;
 			case CABLE_TYPE_MISC:
 				val_type.intval = POWER_SUPPLY_STATUS_CHARGING;
-				val_chg_current.intval = 450;	/* mA */
+				val_chg_current.intval = 650; //450;	/* mA */
 				break;
 			default:
 				dev_err(info->dev, "%s: Invalid func use\n",
@@ -2810,7 +2810,7 @@ static ssize_t sec_bat_store(struct devi
 					switch (info->cable_type) {
 					case CABLE_TYPE_USB:
 					case CABLE_TYPE_MISC:
-						value.intval = 450;	/* mA */
+						value.intval = 650; //450;	/* mA */
 						break;
 					case CABLE_TYPE_AC:
 						value.intval = 650;	/* mA */
diff -urNp Kernel/drivers/samsung/Kconfig HelloWorld-Renew-v1.0-n7000-jb/drivers/samsung/Kconfig
--- Kernel/drivers/samsung/Kconfig	2013-02-20 13:36:34.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/drivers/samsung/Kconfig	2013-04-29 16:41:35.158587461 +0200
@@ -7,6 +7,13 @@ menuconfig FM_RADIO
 	help
 	  Say Y to enable FM Radio Driver
 
+menuconfig J4FS
+	tristate "Samsung J4FS support"
+	depends on SAMSUNG_MODULES
+	default m
+	help
+	  Say Y to enable Samsung J4FS support.
+
 menuconfig FM_SI4709
 	tristate "Si4709 FM radio"
 	depends on FM_RADIO
diff -urNp Kernel/drivers/video/samsung/mdnie_table_q1.h HelloWorld-Renew-v1.0-n7000-jb/drivers/video/samsung/mdnie_table_q1.h
--- Kernel/drivers/video/samsung/mdnie_table_q1.h	2013-02-20 13:36:43.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/drivers/video/samsung/mdnie_table_q1.h	2013-04-29 16:41:35.162587461 +0200
@@ -11,11 +11,11 @@ static const unsigned short tune_dynamic
 	0x002d, 0x1900, /*DNR bypass 0x0a08 */
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
-	0x003a, 0x000d, /*HDTR DE CS */
-	0x003b, 0x03ff, /*DE SHARPNESS */
-	0x003c, 0x0000, /*NOISE LEVEL */
+	0x003a, 0x0009, /*HDTR DE CS */
+
+
 	0x003f, 0x00a0, /*CS GAIN */
-	0x0042, 0x0000, /*DE TH (MAX DIFF) */
+
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0x0000, /*gc R */
 	0x00ca, 0xffff, /*rm R */
@@ -65,11 +65,11 @@ static const unsigned short tune_dynamic
 	0x002d, 0x1900, /*DNR bypass 0x0a08 */
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
-	0x003a, 0x000d, /*HDTR DE CS */
-	0x003b, 0x0030, /*DE SHARPNESS */
-	0x003c, 0x0000, /*NOISE LEVEL */
+	0x003a, 0x0009, /*HDTR DE CS */
+
+
 	0x003f, 0x00a0, /*CS GAIN */
-	0x0042, 0x0000, /*DE TH (MAX DIFF) */
+
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0x0000, /*gc R */
 	0x00ca, 0xffff, /*rm R */
@@ -119,11 +119,11 @@ static const unsigned short tune_dynamic
 	0x002d, 0x1900, /*DNR bypass 0x0a08 */
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
-	0x003a, 0x000d, /*HDTR DE CS */
-	0x003b, 0x03ff, /*DE SHARPNESS */
-	0x003c, 0x0000, /*NOISE LEVEL */
+	0x003a, 0x0009, /*HDTR DE CS */
+
+
 	0x003f, 0x00a0, /*CS GAIN */
-	0x0042, 0x0000, /*DE TH (MAX DIFF) */
+
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0x0000, /*gc R */
 	0x00ca, 0xffff, /*rm R */
@@ -173,11 +173,11 @@ static const unsigned short tune_dynamic
 	0x002d, 0x19ff,	/*DNR dirnumTh decon7Th */
 	0x002e, 0xff16,	/*DNR decon5Th maskTh */
 	0x002f, 0x0000,	/*DNR blTh */
-	0x003a, 0x000d, /*HDTR DE CS */
-	0x003b, 0x03ff, /*DE SHARPNESS */
-	0x003c, 0x0000, /*NOISE LEVEL */
+	0x003a, 0x0009, /*HDTR DE CS */
+
+
 	0x003f, 0x0100, /*CS GAIN */
-	0x0042, 0x0000, /*DE TH (MAX DIFF) */
+
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0x0000, /*gc R */
 	0x00ca, 0xffff, /*rm R */
@@ -380,9 +380,9 @@ static const unsigned short tune_movie_v
 	0x002d, 0x19ff, /*DNR dirnumTh decon7Th */
 	0x002e, 0xff16, /*DNR decon5Th maskTh */
 	0x002f, 0x0000, /*DNR blTh */
-	0x003a, 0x000d, /*HDTR DE CS */
-	0x003b, 0x0000, /*DE SHARPNESS */
-	0x003c, 0x0000, /*NOISE LEVEL */
+	0x003a, 0x0009, /*HDTR DE CS */
+
+
 	0x003f, 0x0030, /*CS GAIN */
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0xa4aa, /*gc R */
@@ -433,11 +433,11 @@ static const unsigned short tune_standar
 	0x002d, 0x1900, /*DNR bypass 0x0a08 */
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
-	0x003a, 0x000d, /*HDTR DE CS */
-	0x003b, 0x0300, /*DE SHARPNESS */
-	0x003c, 0x0000, /*NOISE LEVEL */
+	0x003a, 0x0009, /*HDTR DE CS */
+
+
 	0x003f, 0x0030, /*CS GAIN */
-	0x0042, 0x0000, /*DE TH (MAX DIFF) */
+
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0x0000, /*gc R */
 	0x00ca, 0xffff, /*rm R */
@@ -487,11 +487,11 @@ static const unsigned short tune_standar
 	0x002d, 0x1900, /*DNR bypass 0x0a08 */
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
-	0x003a, 0x000d, /*HDTR DE CS */
-	0x003b, 0x0000, /*DE SHARPNESS */
-	0x003c, 0x0000, /*NOISE LEVEL */
+	0x003a, 0x0009, /*HDTR DE CS */
+
+
 	0x003f, 0x0030, /*CS GAIN */
-	0x0042, 0x0000, /*DE TH (MAX DIFF) */
+
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0x0000, /*gc R */
 	0x00ca, 0xffff, /*rm R */
@@ -541,11 +541,11 @@ static const unsigned short tune_standar
 	0x002d, 0x1900, /*DNR bypass 0x0a08 */
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
-	0x003a, 0x000d, /*HDTR DE CS */
-	0x003b, 0x0300, /*DE SHARPNESS */
-	0x003c, 0x0000, /*NOISE LEVEL */
+	0x003a, 0x0009, /*HDTR DE CS */
+
+
 	0x003f, 0x0030, /*CS GAIN */
-	0x0042, 0x0000, /*DE TH (MAX DIFF) */
+
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0x0000, /*gc R */
 	0x00ca, 0xffff, /*rm R */
@@ -595,11 +595,11 @@ static const unsigned short tune_standar
 	0x002d, 0x19ff, /*DNR dirnumTh decon7Th */
 	0x002e, 0xff16, /*DNR decon5Th maskTh */
 	0x002f, 0x0000, /*DNR blTh */
-	0x003a, 0x000d, /*HDTR DE CS */
-	0x003b, 0x03f8, /*DE SHARPNESS */
-	0x003c, 0x0000, /*NOISE LEVEL */
+	0x003a, 0x0009, /*HDTR DE CS */
+
+
 	0x003f, 0x00a0, /*CS GAIN */
-	0x0042, 0x0000, /*DE TH (MAX DIFF) */
+
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0x0000, /*gc R */
 	0x00ca, 0xffff, /*rm R */
@@ -649,11 +649,11 @@ static const unsigned short tune_natural
 	0x002d, 0x1900, /*DNR bypass 0x0a08 */
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
-	0x003a, 0x000d, /*HDTR DE CS */
-	0x003b, 0x0300, /*DE SHARPNESS */
-	0x003c, 0x0000, /*NOISE LEVEL */
+	0x003a, 0x0009, /*HDTR DE CS */
+
+
 	0x003f, 0x0180, /*CS GAIN */
-	0x0042, 0x0000, /*DE TH (MAX DIFF) */
+
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0xa4aa, /*gc R */
 	0x00ca, 0xd5fe, /*rm R */
@@ -703,11 +703,11 @@ static const unsigned short tune_natural
 	0x002d, 0x1900, /*DNR bypass 0x0a08 */
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
-	0x003a, 0x000d, /*HDTR DE CS */
-	0x003b, 0x0000, /*DE SHARPNESS */
-	0x003c, 0x0000, /*NOISE LEVEL */
+	0x003a, 0x0009, /*HDTR DE CS */
+
+
 	0x003f, 0x0180, /*CS GAIN */
-	0x0042, 0x0000, /*DE TH (MAX DIFF) */
+
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0xa4aa, /*gc R */
 	0x00ca, 0xd5fe, /*rm R */
@@ -757,11 +757,11 @@ static const unsigned short tune_natural
 	0x002d, 0x1900, /*DNR bypass 0x0a08 */
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
-	0x003a, 0x000d, /*HDTR DE CS */
-	0x003b, 0x0300, /*DE SHARPNESS */
-	0x003c, 0x0000, /*NOISE LEVEL */
+	0x003a, 0x0009, /*HDTR DE CS */
+
+
 	0x003f, 0x0180, /*CS GAIN */
-	0x0042, 0x0000, /*DE TH (MAX DIFF) */
+
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0xa4aa, /*gc R */
 	0x00ca, 0xd5fe, /*rm R */
@@ -811,11 +811,11 @@ static const unsigned short tune_natural
 	0x002d, 0x19ff, /*DNR dirnumTh decon7Th */
 	0x002e, 0xff16, /*DNR decon5Th maskTh */
 	0x002f, 0x0000, /*DNR blTh */
-	0x003a, 0x000d, /*HDTR DE CS */
-	0x003b, 0x03f8, /*DE SHARPNESS */
-	0x003c, 0x0000, /*NOISE LEVEL */
+	0x003a, 0x0009, /*HDTR DE CS */
+
+
 	0x003f, 0x0180, /*CS GAIN */
-	0x0042, 0x0000, /*DE TH (MAX DIFF) */
+
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0xa4aa, /*gc R */
 	0x00ca, 0xd5fe, /*rm R */
@@ -865,11 +865,11 @@ static const unsigned short tune_camera[
 	0x002d, 0x1900, /*DNR bypass 0x0a08 */
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
-	0x003a, 0x000d, /*HDTR DE CS */
-	0x003b, 0x0030, /*DE SHARPNESS */
-	0x003c, 0x0000, /*NOISE LEVEL */
+	0x003a, 0x0009, /*HDTR DE CS */
+
+
 	0x003f, 0x0030, /*CS GAIN */
-	0x0042, 0x0000, /*DE TH (MAX DIFF) */
+
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0x0000, /*gc R */
 	0x00ca, 0xffff, /*rm R */
@@ -919,11 +919,11 @@ static const unsigned short tune_camera_
 	0x002d, 0x1900, /*DNR bypass 0x0a08 */
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
-	0x003a, 0x000d, /*HDTR DE CS */
-	0x003b, 0x0030, /*DE SHARPNESS */
-	0x003c, 0x0000, /*NOISE LEVEL */
+	0x003a, 0x0009, /*HDTR DE CS */
+
+
 	0x003f, 0x0030, /*CS GAIN */
-	0x0042, 0x0000, /*DE TH (MAX DIFF) */
+
 	0x0054, 0x6050, /*OVE LIGHTNESS CHROMA */
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0x0000, /*gc R */
diff -urNp Kernel/drivers/video/samsung/mdnie_table_u1.h HelloWorld-Renew-v1.0-n7000-jb/drivers/video/samsung/mdnie_table_u1.h
--- Kernel/drivers/video/samsung/mdnie_table_u1.h	2013-02-20 13:36:43.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/drivers/video/samsung/mdnie_table_u1.h	2013-04-29 16:41:35.162587461 +0200
@@ -12,10 +12,10 @@ static const unsigned short tune_dynamic
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
 	0x003A, 0x000D, /*HDTR DE CS */
-	0x003B, 0x03ff, /*DE SHARPNESS */
+	0x003B, 0x0000, /*DE SHARPNESS */
 	0x003C, 0x0000, /*NOISE LEVEL */
 	0x003F, 0x012c, /*CS GAIN  */
-	0x0042, 0x0020, /*DE TH (MAX DIFF) */
+	0x0042, 0x003f, /*DE TH (MAX DIFF) */
 	0x0049, 0x0400, /*pcc skin */
 	0x004a, 0x7a00,
 	0x004b, 0x008f,
@@ -70,11 +70,11 @@ static const unsigned short tune_dynamic
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
 	0x003A, 0x000d, /*HDTR DE_off CS : de on = d ,  de off = 9 */
-	0x003B, 0x0001, /*DE SHARPNESS(0~1023)  off */
+	0x003B, 0x0000, /*DE SHARPNESS(0~1023)  off */
 	0x003C, 0x0000, /*NOISE LEVEL */
 	0x003F, 0x012c, /*CS GAIN 300 */
-	0x003B, 0x0001, /*DE SHARPNESS(0~1023)  off */
-	0x0042, 0x0030, /*DE TH (MAX DIFF) */
+	0x003B, 0x0000, /*DE SHARPNESS(0~1023)  off */
+	0x0042, 0x003f, /*DE TH (MAX DIFF) */
 	0x004d, 0x0100, /*pcc strength */
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0x0000, /*gc R */
@@ -126,10 +126,10 @@ static const unsigned short tune_dynamic
 	0x002e, 0x1005, /*DNR bypass 0x1010 */
 	0x002f, 0x0400, /*DNR bypass 0x0400 */
 	0x003A, 0x000D, /*HDTR DE CS  de on = d ,  de off = 9 */
-	0x003B, 0x03ff, /*DE SHARPNESS */
+	0x003B, 0x0000, /*DE SHARPNESS */
 	0x003C, 0x0000, /*NOISE LEVEL */
 	0x003F, 0x012c, /*CS GAIN  */
-	0x0042, 0x0020, /*DE TH (MAX DIFF) */
+	0x0042, 0x003f, /*DE TH (MAX DIFF) */
 	0x0049, 0x0400, /*pcc skin */
 	0x004a, 0x7a00, /*7300 */
 	0x004b, 0x008F, /*008f */
@@ -184,10 +184,10 @@ static const unsigned short tune_dynamic
 	0x002e, 0xff16, /*DNR decon5Th maskTh */
 	0x002f, 0x0000, /*DNR blTh */
 	0x003a, 0x000d, /*HDTR DE CS */
-	0x003b, 0x03ff, /*DE SHARPNESS */
+	0x003b, 0x0000, /*DE SHARPNESS */
 	0x003c, 0x0000, /*NOISE LEVEL */
 	0x003f, 0x0100, /*CS GAIN */
-	0x0042, 0x0000, /*DE TH (MAX DIFF) */
+	0x0042, 0x003f, /*DE TH (MAX DIFF) */
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0x0000, /*gc R */
 	0x00ca, 0xffff, /*rm R */
@@ -238,9 +238,9 @@ static const unsigned short tune_movie_g
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
 	0x003A, 0x000D, /*HDTR DE CS */
-	0x003B, 0x0001, /*DE SHARPNESS */
+	0x003B, 0x0000, /*DE SHARPNESS */
 	0x003C, 0x0000, /*NOISE LEVEL */
-	0x003F, 0x0032, /*CS GAIN 300 */
+	0x003F, 0x000f, /*CS GAIN 300 */
 	0x0042, 0x003f, /*DE TH (MAX DIFF) */
 	0x0049, 0x0400, /*pcc skin */
 	0x004a, 0x7a00,
@@ -296,10 +296,10 @@ static const unsigned short tune_movie_u
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
 	0x003A, 0x000d, /*HDTR DE_off CS : de on = d ,  de off = 9 */
-	0x003B, 0x0001, /*DE SHARPNESS(0~1023)  off */
+	0x003B, 0x0000, /*DE SHARPNESS(0~1023)  off */
 	0x003C, 0x0000, /*NOISE LEVEL */
-	0x003F, 0x0032, /*CS GAIN 50 */
-	0x0042, 0x0030, /*DE TH (MAX DIFF) */
+	0x003F, 0x000f, /*CS GAIN 50 */
+	0x0042, 0x003f, /*DE TH (MAX DIFF) */
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0xb6bc, /*gc R */
 	0x00ca, 0xd4ff, /*rm R */
@@ -350,9 +350,9 @@ static const unsigned short tune_movie_v
 	0x002e, 0x1005, /*DNR bypass 0x1010 */
 	0x002f, 0x0400, /*DNR bypass 0x0400 */
 	0x003A, 0x000D, /*HDTR DE CS  de on = d ,  de off = 9 */
-	0x003B, 0x0001, /*DE SHARPNESS */
+	0x003B, 0x0000, /*DE SHARPNESS */
 	0x003C, 0x0000, /*NOISE LEVEL */
-	0x003F, 0x0032, /*CS GAIN 300 */
+	0x003F, 0x000f, /*CS GAIN 300 */
 	0x0042, 0x003f, /*DE TH (MAX DIFF) */
 	0x0049, 0x0400, /*pcc skin */
 	0x004a, 0x7a00, /*7300 */
@@ -410,7 +410,7 @@ static const unsigned short tune_movie_v
 	0x003a, 0x000d, /*HDTR DE CS */
 	0x003b, 0x0000, /*DE SHARPNESS */
 	0x003c, 0x0000, /*NOISE LEVEL */
-	0x003f, 0x0030, /*CS GAIN */
+	0x003F, 0x000f, /*CS GAIN */
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0xb6bc, /*gc R */
 	0x00ca, 0xd4ff, /*rm R */
@@ -462,14 +462,14 @@ static const unsigned short tune_standar
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
 	0x003A, 0x000D, /*HDTR DE CS */
-	0x003B, 0x03ff, /*DE SHARPNESS */
+	0x003B, 0x0000, /*DE SHARPNESS */
 	0x003C, 0x0000, /*NOISE LEVEL */
-	0x003F, 0x0032, /*CS GAIN  */
-	0x0042, 0x0020, /*DE TH (MAX DIFF) */
+	0x003F, 0x000f, /*CS GAIN  */
+	0x0042, 0x003f, /*DE TH (MAX DIFF) */
 	0x0049, 0x0400, /*pcc skin */
 	0x004a, 0x7a00,
 	0x004b, 0x008f,
-	0x004d, 0x0100, /*pcc strength */
+	0x004d, 0x0000, /*pcc strength */
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0x0000, /*gc R */
 	0x00ca, 0xffff, /*rm R */
@@ -520,10 +520,10 @@ static const unsigned short tune_standar
 	0x002e, 0x0000,	/*DNR bypass 0x1010 */
 	0x002f, 0x0fff,	/*DNR bypass 0x0400 */
 	0x003A, 0x000d,	/*HDTR DE_off CS : de on = d ,  de off = 9 */
-	0x003B, 0x0001,	/*DE SHARPNESS(0~1023)  off */
+	0x003B, 0x0000,	/*DE SHARPNESS(0~1023)  off */
 	0x003C, 0x0000,	/*NOISE LEVEL */
-	0x003F, 0x001e,	/*CS GAIN 30 */
-	0x0042, 0x0030,	/*DE TH (MAX DIFF) */
+	0x003F, 0x000f,	/*CS GAIN 30 */
+	0x0042, 0x003f,	/*DE TH (MAX DIFF) */
 	0x00c8, 0x0000,	/*kb R	SCR */
 	0x00c9, 0x0000,	/*gc R */
 	0x00ca, 0xffff,	/*rm R */
@@ -574,14 +574,14 @@ static const unsigned short tune_standar
 	0x002e, 0x1005, /*DNR bypass 0x1010 */
 	0x002f, 0x0400, /*DNR bypass 0x0400 */
 	0x003A, 0x000D, /*HDTR DE CS  de on = d ,  de off = 9 */
-	0x003B, 0x03ff, /*DE SHARPNESS */
+	0x003B, 0x0000, /*DE SHARPNESS */
 	0x003C, 0x0000, /*NOISE LEVEL */
-	0x003F, 0x0032, /*CS GAIN  */
-	0x0042, 0x0020, /*DE TH (MAX DIFF) */
+	0x003F, 0x000f, /*CS GAIN  */
+	0x0042, 0x003f, /*DE TH (MAX DIFF) */
 	0x0049, 0x0400, /*pcc skin */
 	0x004a, 0x7a00, /*7300 */
 	0x004b, 0x008F, /*008f */
-	0x004d, 0x0100, /*pcc strength */
+	0x004d, 0x0000, /*pcc strength */
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0x0000, /*gc R */
 	0x00ca, 0xffff, /*rm R */
@@ -632,10 +632,10 @@ static const unsigned short tune_standar
 	0x002e, 0xff16, /*DNR decon5Th maskTh */
 	0x002f, 0x0000, /*DNR blTh */
 	0x003a, 0x000d, /*HDTR DE CS */
-	0x003b, 0x03f8, /*DE SHARPNESS */
+	0x003b, 0x0000, /*DE SHARPNESS */
 	0x003c, 0x0000, /*NOISE LEVEL */
-	0x003f, 0x00a0, /*CS GAIN */
-	0x0042, 0x0000, /*DE TH (MAX DIFF) */
+	0x003F, 0x000f, /*CS GAIN */
+	0x0042, 0x003f, /*DE TH (MAX DIFF) */
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0x0000, /*gc R */
 	0x00ca, 0xffff, /*rm R */
@@ -686,14 +686,14 @@ static const unsigned short tune_natural
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
 	0x003A, 0x000D, /*HDTR DE CS */
-	0x003B, 0x03ff, /*DE SHARPNESS */
+	0x003B, 0x0000, /*DE SHARPNESS */
 	0x003C, 0x0000, /*NOISE LEVEL */
 	0x003F, 0x0180, /*CS GAIN  */
-	0x0042, 0x0020, /*DE TH (MAX DIFF) */
+	0x0042, 0x003f, /*DE TH (MAX DIFF) */
 	0x0049, 0x0400, /*pcc skin */
 	0x004a, 0x7a00,
 	0x004b, 0x008f,
-	0x004d, 0x0100, /*pcc strength */
+	0x004d, 0x0000, /*pcc strength */
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0xb6bc, /*gc R */
 	0x00ca, 0xd4ff, /*rm R */
@@ -744,10 +744,10 @@ static const unsigned short tune_natural
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
 	0x003A, 0x000d, /*HDTR DE_off CS : de on = d ,  de off = 9 */
-	0x003B, 0x0001, /*DE SHARPNESS(0~1023)  off */
+	0x003B, 0x0000, /*DE SHARPNESS(0~1023)  off */
 	0x003C, 0x0000, /*NOISE LEVEL */
 	0x003F, 0x0180, /*CS GAIN 30 */
-	0x0042, 0x0030, /*DE TH (MAX DIFF) */
+	0x0042, 0x003f, /*DE TH (MAX DIFF) */
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0xb6bc, /*gc R */
 	0x00ca, 0xd4ff, /*rm R */
@@ -798,14 +798,14 @@ static const unsigned short tune_natural
 	0x002e, 0x1005, /*DNR bypass 0x1010 */
 	0x002f, 0x0400, /*DNR bypass 0x0400 */
 	0x003A, 0x000D, /*HDTR DE CS  de on = d ,  de off = 9 */
-	0x003B, 0x03ff, /*DE SHARPNESS */
+	0x003B, 0x0000, /*DE SHARPNESS */
 	0x003C, 0x0000, /*NOISE LEVEL */
 	0x003F, 0x0180, /*CS GAIN  */
-	0x0042, 0x0020, /*DE TH (MAX DIFF) */
+	0x0042, 0x003f, /*DE TH (MAX DIFF) */
 	0x0049, 0x0400, /*pcc skin */
 	0x004a, 0x7a00, /*7300 */
 	0x004b, 0x008F, /*008f */
-	0x004d, 0x0100, /*pcc strength */
+	0x004d, 0x0000, /*pcc strength */
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0xb6bc, /*gc R */
 	0x00ca, 0xd4ff, /*rm R */
@@ -856,10 +856,10 @@ static const unsigned short tune_natural
 	0x002e, 0xff16, /*DNR decon5Th maskTh */
 	0x002f, 0x0000, /*DNR blTh */
 	0x003a, 0x000d, /*HDTR DE CS */
-	0x003b, 0x03f8, /*DE SHARPNESS */
+	0x003b, 0x0000, /*DE SHARPNESS */
 	0x003c, 0x0000, /*NOISE LEVEL */
 	0x003f, 0x0180, /*CS GAIN */
-	0x0042, 0x0000, /*DE TH (MAX DIFF) */
+	0x0042, 0x003f, /*DE TH (MAX DIFF) */
 	0x00c8, 0x0000, /*kb R	SCR */
 	0x00c9, 0xb6bc, /*gc R */
 	0x00ca, 0xd4ff, /*rm R */
@@ -927,7 +927,7 @@ static const unsigned short tune_camera_
 	0x002e, 0x0000, /*DNR bypass 0x1010 */
 	0x002f, 0x0fff, /*DNR bypass 0x0400 */
 	0x003A, 0x000D, /*HDTR DE CS */
-	0x003B, 0x03ff, /*DE SHARPNESS */
+	0x003B, 0x0000, /*DE SHARPNESS */
 	0x003C, 0x0000, /*NOISE LEVEL */
 	0x003F, 0x0100, /*CS GAIN */
 	0x0042, 0x003f, /*DE TH (MAX DIFF) */
diff -urNp Kernel/fs/sync.c HelloWorld-Renew-v1.0-n7000-jb/fs/sync.c
--- Kernel/fs/sync.c	2013-02-20 13:36:52.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/fs/sync.c	2013-04-29 23:24:35.734655633 +0200
@@ -21,6 +21,10 @@
 #define VALID_FLAGS (SYNC_FILE_RANGE_WAIT_BEFORE|SYNC_FILE_RANGE_WRITE| \
 			SYNC_FILE_RANGE_WAIT_AFTER)
 
+#ifdef CONFIG_FSYNC_CONTROL
+extern bool fsynccontrol_fsync_enabled();
+#endif
+
 /*
  * Do the filesystem syncing work. For simple filesystems
  * writeback_inodes_sb(sb) just dirties buffers with inodes so we have to
@@ -139,6 +143,11 @@ SYSCALL_DEFINE1(syncfs, int, fd)
 	int ret;
 	int fput_needed;
 
+#ifdef CONFIG_FSYNC_CONTROL
+	if (!fsynccontrol_fsync_enabled())
+	    return 0;
+#endif
+
 	file = fget_light(fd, &fput_needed);
 	if (!file)
 		return -EBADF;
@@ -168,6 +177,11 @@ int vfs_fsync_range(struct file *file, l
 	struct address_space *mapping = file->f_mapping;
 	int err, ret;
 
+#ifdef CONFIG_FSYNC_CONTROL
+	if (!fsynccontrol_fsync_enabled())
+	    return 0;
+#endif
+
 	if (!file->f_op || !file->f_op->fsync) {
 		ret = -EINVAL;
 		goto out;
@@ -200,6 +214,11 @@ EXPORT_SYMBOL(vfs_fsync_range);
  */
 int vfs_fsync(struct file *file, int datasync)
 {
+#ifdef CONFIG_FSYNC_CONTROL
+	if (!fsynccontrol_fsync_enabled())
+	    return 0;
+#endif
+
 	return vfs_fsync_range(file, 0, LLONG_MAX, datasync);
 }
 EXPORT_SYMBOL(vfs_fsync);
@@ -209,6 +228,11 @@ static int do_fsync(unsigned int fd, int
 	struct file *file;
 	int ret = -EBADF;
 
+#ifdef CONFIG_FSYNC_CONTROL
+	if (!fsynccontrol_fsync_enabled())
+	    return 0;
+#endif
+
 	file = fget(fd);
 	if (file) {
 		ret = vfs_fsync(file, datasync);
@@ -219,11 +243,21 @@ static int do_fsync(unsigned int fd, int
 
 SYSCALL_DEFINE1(fsync, unsigned int, fd)
 {
+#ifdef CONFIG_FSYNC_CONTROL
+	if (!fsynccontrol_fsync_enabled())
+	    return 0;
+#endif
+
 	return do_fsync(fd, 0);
 }
 
 SYSCALL_DEFINE1(fdatasync, unsigned int, fd)
 {
+#ifdef CONFIG_FSYNC_CONTROL
+	if (!fsynccontrol_fsync_enabled())
+	    return 0;
+#endif
+
 	return do_fsync(fd, 1);
 }
 
@@ -237,6 +271,11 @@ SYSCALL_DEFINE1(fdatasync, unsigned int,
  */
 int generic_write_sync(struct file *file, loff_t pos, loff_t count)
 {
+#ifdef CONFIG_FSYNC_CONTROL
+	if (!fsynccontrol_fsync_enabled())
+	    return 0;
+#endif
+
 	if (!(file->f_flags & O_DSYNC) && !IS_SYNC(file->f_mapping->host))
 		return 0;
 	return vfs_fsync_range(file, pos, pos + count - 1,
@@ -301,6 +340,11 @@ SYSCALL_DEFINE(sync_file_range)(int fd,
 	int fput_needed;
 	umode_t i_mode;
 
+#ifdef CONFIG_FSYNC_CONTROL
+	if (!fsynccontrol_fsync_enabled())
+	    return 0;
+#endif
+
 	ret = -EINVAL;
 	if (flags & ~VALID_FLAGS)
 		goto out;
diff -urNp Kernel/include/config/auto.conf HelloWorld-Renew-v1.0-n7000-jb/include/config/auto.conf
--- Kernel/include/config/auto.conf	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/include/config/auto.conf	2013-05-01 12:14:22.501107096 +0200
@@ -0,0 +1,984 @@
+#
+# Automatically generated make config: don't edit
+# Linux/arm 3.0.31-1103517 Kernel Configuration
+#
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_EXYNOS4_SETUP_I2C5=y
+CONFIG_SCSI_DMA=y
+CONFIG_KERNEL_GZIP=y
+CONFIG_BROADCOM_WIFI_RESERVED_MEM=y
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_RFS_ACCEL=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_TVOUT=16384
+CONFIG_CRC32=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_NF_NAT_PROTO_SCTP=y
+CONFIG_HAVE_AOUT=y
+CONFIG_VFP=y
+CONFIG_IR_JVC_DECODER=y
+CONFIG_AEABI=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_BLK_DEV_DM=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_FLATMEM_MANUAL=y
+CONFIG_FB_S5P_S6E8AA0=y
+CONFIG_SAMSUNG_MFC_DRIVERS=y
+CONFIG_BT_RFCOMM=y
+CONFIG_USB_S5P_HSIC1=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_PEGASUSQ=y
+CONFIG_INOTIFY_USER=y
+CONFIG_EXYNOS4_SETUP_FIMD0=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_CRYPTO_MD4=y
+CONFIG_SERIAL_S5PV210=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_EXYNOS4_SETUP_CSIS=y
+CONFIG_EXPERIMENTAL=y
+CONFIG_ANDROID_PMEM_MEMSIZE_PMEM=4096
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_RC_CORE=y
+CONFIG_PM_WATCHDOG_TIMEOUT=y
+CONFIG_BINFMT_MISC=y
+CONFIG_SEC_THERMISTOR=y
+CONFIG_NETFILTER_XT_MATCH_HELPER=y
+CONFIG_SSB_POSSIBLE=y
+CONFIG_S3C_ADC=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_CPU_FREQ_GOV_HYPER=y
+CONFIG_NET_SCH_FIFO=y
+CONFIG_FSNOTIFY=y
+CONFIG_LEDS_MAX8997=y
+CONFIG_INET6_TUNNEL=y
+CONFIG_FM_RADIO=y
+CONFIG_EXYNOS4_SETUP_FIMC3=y
+CONFIG_USB_SUSPEND=y
+CONFIG_BT_MGMT=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_FIB_RULES=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_IP6_NF_MANGLE=y
+CONFIG_SENSORS_CORE=y
+CONFIG_IPV6=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_USB_DEVICEFS=y
+CONFIG_FB_BGRA_ORDER=y
+CONFIG_NF_NAT_PROTO_GRE=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_CHARGER_MAX8997_U1=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+CONFIG_S3C_GPIO_CFG_S3C24XX=y
+CONFIG_IR_NEC_DECODER=y
+CONFIG_HOTPLUG_CPU=y
+CONFIG_WLAN=y
+CONFIG_SAMSUNG_MHL=y
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+CONFIG_EXYNOS4_LOWPWR_IDLE=y
+CONFIG_ARM_PLD_SIZE=32
+CONFIG_S3C_DEV_RTC=y
+CONFIG_VIDEO_MFC5X=y
+CONFIG_HAVE_ARM_SCU=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG=y
+CONFIG_SERIAL_SAMSUNG=y
+CONFIG_J4FS_PAGE_SHIFT=11
+CONFIG_XFRM_IPCOMP=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_NETFILTER_NETLINK_QUEUE=y
+CONFIG_MSDOS_FS=y
+CONFIG_TUN=y
+CONFIG_CFG80211=y
+CONFIG_TREE_PREEMPT_RCU=y
+CONFIG_BT_BCM4330=y
+CONFIG_DM_CRYPT=y
+CONFIG_SERIAL_8250=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_IOMMU_SUPPORT=y
+CONFIG_HID_BELKIN=y
+CONFIG_VIDEO_IR_I2C=y
+CONFIG_EXYNOS4_SETUP_I2C6=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+CONFIG_USB=y
+CONFIG_SWITCH_GPIO=y
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMD=32000
+CONFIG_CRYPTO_HMAC=y
+CONFIG_USB_DUN_SUPPORT=y
+CONFIG_CPU_FREQ_GOV_SMARTASS2=y
+CONFIG_VIDEO_FIMC_MIPI=y
+CONFIG_HDMI_HPD=y
+CONFIG_BRANCH_PROFILE_NONE=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_IP6_NF_TARGET_LOG=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_ARM_ERRATA_751472=y
+CONFIG_HID_CHERRY=y
+CONFIG_S3C_ADDR_BASE=0xFB000000
+CONFIG_EXYNOS4_MSHC_8BIT=y
+CONFIG_HID_SUNPLUS=y
+CONFIG_HID_PICOLCD=y
+CONFIG_BCMA_POSSIBLE=y
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_S3C_DEV_I2C8_EMUL=y
+CONFIG_SND_SOC=y
+CONFIG_SYNC=y
+CONFIG_MALI_UMP_R2P4_LSI=y
+CONFIG_EXYNOS4_MSHC_DDR=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+CONFIG_WIFI_CONTROL_FUNC=y
+CONFIG_TIMERFD=y
+CONFIG_HID_THRUSTMASTER=y
+CONFIG_CRYPTO_AUTHENC=y
+CONFIG_NET_EMATCH_STACK=32
+CONFIG_BOUNCE=y
+CONFIG_SHMEM=y
+CONFIG_MIGRATION=y
+CONFIG_MMC_BLOCK_MINORS=8
+CONFIG_EXYNOS4_SETUP_SDHCI=y
+CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE=y
+CONFIG_CRYPTO_DES=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_S5P_DEV_TVOUT=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NET_CLS_U32=y
+CONFIG_SEC_DEV_JACK=y
+CONFIG_ARM_GIC=y
+CONFIG_SERIO=y
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_NET_EMATCH_U32=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_EPEN_WACOM_G5SP=y
+CONFIG_NF_CONNTRACK_SANE=y
+CONFIG_ANDROID_PMEM_MEMSIZE_PMEM_CAM=0
+CONFIG_NF_CT_PROTO_DCCP=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_USB_G_ANDROID=y
+CONFIG_ARM_ERRATA_764369=y
+CONFIG_CRYPTO_TWOFISH_COMMON=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_EXYNOS_DEV_PD=y
+CONFIG_CMA_SIZE_SEL_MBYTES=y
+CONFIG_S3C_DEV_HSMMC2=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_USB_DEVICE_CLASS=y
+CONFIG_ANDROID_TIMED_GPIO=y
+CONFIG_ARM=y
+CONFIG_ARM_L1_CACHE_SHIFT=5
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_S5P_MEM_CMA=y
+CONFIG_CRYPTO_MANAGER_TESTS=y
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMC3=7168
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+CONFIG_ARM_CPU_TOPOLOGY=y
+CONFIG_IP_NF_TARGET_LOG=y
+CONFIG_LTO=y
+CONFIG_HAS_WAKELOCK=y
+CONFIG_HDMI_SWITCH_HPD=y
+CONFIG_S3C_PL330_DMA=y
+CONFIG_USB_STORAGE=y
+CONFIG_EXYNOS4_SETUP_I2C3=y
+CONFIG_STANDALONE=y
+CONFIG_SCHED_MC=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_IR_LIRC_CODEC=y
+CONFIG_MMC_EMBEDDED_SDIO=y
+CONFIG_ARCH_HAS_CPUFREQ=y
+CONFIG_ASHMEM=y
+CONFIG_BLOCK=y
+CONFIG_HAVE_IDE=y
+CONFIG_HID_APPLE=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_IP_NF_ARP_MANGLE=y
+CONFIG_SND_SOC_MC1N2=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_BCM4330=y
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_BUG=y
+CONFIG_PM=y
+CONFIG_SPI=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_SWITCH=y
+CONFIG_SAMSUNG_PRODUCT_SHIP=y
+CONFIG_DEVKMEM=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_NTFS_RW=y
+CONFIG_TEXTSEARCH_KMP=y
+CONFIG_VT=y
+CONFIG_USE_LEGACY_MFC=y
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_EXYNOS_MEM=y
+CONFIG_BT_SCO=y
+CONFIG_POWER_SUPPLY=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=y
+CONFIG_V4L_USB_DRIVERS=y
+CONFIG_WEXT_CORE=y
+CONFIG_GENERIC_IRQ_CHIP=y
+CONFIG_NLS=y
+CONFIG_S3C_MEM=y
+CONFIG_HID_MAGICMOUSE=y
+CONFIG_S3C_DEV_I2C14_EMUL=y
+CONFIG_I2C_GPIO=y
+CONFIG_MFD_SUPPORT=y
+CONFIG_USB_S3C_OTGD=y
+CONFIG_VIDEO_FIMG2D=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_INPUT_GPIO=y
+CONFIG_SENSORS_GP2A_ANALOG=y
+CONFIG_SPI_BITBANG=y
+CONFIG_USE_TVOUT_CMA=y
+CONFIG_IP6_NF_IPTABLES=y
+CONFIG_CPU_FREQ_GOV_LULZACTIVE=y
+CONFIG_ARCH_SKIP_SECONDARY_CALIBRATE=y
+CONFIG_HID_CYPRESS=y
+CONFIG_ACCESSORY=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_CRYPTO_WORKQUEUE=y
+CONFIG_HID_KENSINGTON=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_CPU_FREQ_TABLE=y
+CONFIG_BCMDHD_FW_PATH="/system/etc/firmware/fw_bcmdhd.bin"
+CONFIG_TEXTSEARCH_BM=y
+CONFIG_HID_ZYDACRON=y
+CONFIG_PPP_MPPE=y
+CONFIG_S5P_DEV_MFC=y
+CONFIG_RFKILL=y
+CONFIG_NETDEVICES=y
+CONFIG_NET_KEY=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_S3C_DEV_I2C5=y
+CONFIG_INITRAMFS_ROOT_GID=0
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_EVENTFD=y
+CONFIG_SAMSUNG_DEV_ADC=y
+CONFIG_FS_POSIX_ACL=y
+CONFIG_IPV6_SIT=y
+CONFIG_SND_SOC_SAMSUNG=y
+CONFIG_XFRM=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_HAVE_S3C_RTC=y
+CONFIG_J4FS_USE_MOVI=y
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_NF_CONNTRACK_BROADCAST=y
+CONFIG_ECRYPT_FS=y
+CONFIG_IR_RC5_SZ_DECODER=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_EXYNOS4_SETUP_MSHCI=y
+CONFIG_SND_SOC_SAMSUNG_I2S_SEC=y
+CONFIG_NF_NAT_PROTO_DCCP=y
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMC0=12288
+CONFIG_IOMMU_EXYNOS4_API=y
+CONFIG_ANDROID_LOW_MEMORY_KILLER=y
+CONFIG_VIDEOBUF2_CMA_PHYS=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_BATTERY_SEC_U1=y
+CONFIG_PHONET=y
+CONFIG_SCSI_WAIT_SCAN=m
+CONFIG_FM_SI4709=m
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_EXYNOS4_SETUP_MIPI_DSI=y
+CONFIG_MMC_UNSAFE_RESUME=y
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_NETFILTER_ADVANCED=y
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_VIDEO_FIMC=y
+CONFIG_VIDEO_M5MO=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_IP_NF_MANGLE=y
+CONFIG_EXYNOS4_SETUP_FB_S5P=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_HID_ZEROPLUS=y
+CONFIG_J4FS=m
+CONFIG_NETFILTER_XT_MATCH_LENGTH=y
+CONFIG_FAT_FS=y
+CONFIG_TEXTSEARCH_FSM=y
+CONFIG_TARGET_LOCALE_EUR=y
+CONFIG_HIGHMEM=y
+CONFIG_IP6_NF_RAW=y
+CONFIG_EXYNOS4_SETUP_TVOUT=y
+CONFIG_INET_TUNNEL=y
+CONFIG_FB_S5P_NR_BUFFERS=2
+CONFIG_MMC_BLOCK_BOUNCE=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_MFD_CORE=y
+CONFIG_RTC_DRV_S3C=y
+CONFIG_CPU_CP15_MMU=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_STOP_MACHINE=y
+CONFIG_CPU_FREQ=y
+CONFIG_BUSFREQ_QOS_1280X800=y
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_LINK_DEVICE_HSIC=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_NLS_ASCII=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_SENSORS_K3G=y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_SND_USB=y
+CONFIG_VIDEOBUF2_MEMOPS=y
+CONFIG_RD_GZIP=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_EXYNOS4210_1400MHZ_SUPPORT=y
+CONFIG_LBDAF=y
+CONFIG_HID_ROCCAT=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_CRYPTO_MD5=y
+CONFIG_DEBUG_USER=y
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+CONFIG_BINFMT_ELF=y
+CONFIG_SCSI_PROC_FS=y
+CONFIG_HOTPLUG=y
+CONFIG_INET6_AH=y
+CONFIG_CPU_CP15=y
+CONFIG_S3C24XX_PWM=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_KEYS=y
+CONFIG_NETFILTER_XT_MARK=y
+CONFIG_NETFILTER_XTABLES=y
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_KEYS_DEBUG_PROC_KEYS=y
+CONFIG_EXYNOS4_SETUP_FIMC2=y
+CONFIG_J4FS_DEVNAME="/dev/block/mmcblk0p4"
+CONFIG_EXYNOS4_SETUP_MFC=y
+CONFIG_PM_SLEEP_SMP=y
+CONFIG_CRYPTO_HW=y
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_JPEG=20480
+CONFIG_HID_GREENASIA=y
+CONFIG_S3C_DEV_I2C9_EMUL=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_SPI_MASTER=y
+CONFIG_HID_ROCCAT_COMMON=y
+CONFIG_INPUT_WACOM=y
+CONFIG_NET_ACT_GACT=y
+CONFIG_HID_GYRATION=y
+CONFIG_MUIC_MAX8997=y
+CONFIG_NETFILTER_XT_TARGET_TPROXY=y
+CONFIG_EARLYSUSPEND=y
+CONFIG_USB_HOST_NOTIFY=y
+CONFIG_CRC16=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NET_CLS=y
+CONFIG_CPU_HAS_PMU=y
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_TMPFS=y
+CONFIG_ANON_INODES=y
+CONFIG_FUTEX=y
+CONFIG_SENSORS_BMP180=y
+CONFIG_VIDEO_IMPROVE_STREAMOFF=y
+CONFIG_VMSPLIT_3G=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_USB_HID=y
+CONFIG_IOSCHED_SIO=y
+CONFIG_ANDROID=y
+CONFIG_NET_SCH_INGRESS=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_IPV6_NDISC_NODETYPE=y
+CONFIG_IOSCHED_ROW=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_SYSVIPC=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_EXYNOS4_SETUP_I2C7=y
+CONFIG_MODULES=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_USB_GADGET=y
+CONFIG_SOUND=y
+CONFIG_SENSORS_K3DH=y
+CONFIG_S3C_BOOT_UART_FORCE_FIFO=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_UNIX=y
+CONFIG_HAVE_CLK=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_ARM_ERRATA_743622=y
+CONFIG_ARCH_EXYNOS4=y
+CONFIG_XPS=y
+CONFIG_S6E8AA0_AMS529HA01=y
+CONFIG_INET_ESP=y
+CONFIG_HID_QUANTA=y
+CONFIG_NF_CONNTRACK_IPV6=y
+CONFIG_MD=y
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_GPIO_PLAT_SAMSUNG=y
+CONFIG_EXYNOS4_CPUFREQ=y
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_MFC1=28672
+CONFIG_MEDIA_TUNER=y
+CONFIG_MISC_DEVICES=y
+CONFIG_SAMSUNG_DEV_TS1=y
+CONFIG_INPUT_UINPUT=y
+CONFIG_PM_OPP=y
+CONFIG_KEYBOARD_ATKBD=y
+CONFIG_NF_NAT=y
+CONFIG_CPU_IDLE=y
+CONFIG_S3C_DEV_I2C16_EMUL=y
+CONFIG_REGULATOR=y
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_EFI_PARTITION=y
+CONFIG_S3C_DEV_ADC=y
+CONFIG_CSI_C=y
+CONFIG_S5P_DEV_FIMD0=y
+CONFIG_LOG_BUF_SHIFT=18
+CONFIG_PANEL_U1=y
+CONFIG_EXTRA_FIRMWARE=""
+CONFIG_CACHE_L2X0=y
+CONFIG_CPU_FREQ_GOV_INTERACTIVE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_VFAT_FS=y
+CONFIG_S3C_GPIO_CFG_S3C64XX=y
+CONFIG_S5P_DEV_USB_EHCI=y
+CONFIG_CPU_RMAP=y
+CONFIG_SND_HWDEP=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_WAKELOCK=y
+CONFIG_NF_NAT_IRC=y
+CONFIG_MEDIA_TUNER_CUSTOMISE=y
+CONFIG_USB_EHCI_S5P=y
+CONFIG_PLAT_SAMSUNG=y
+CONFIG_INPUT_MISC=y
+CONFIG_CPU_PABRT_V7=y
+CONFIG_SUSPEND=y
+CONFIG_CRYPTO_CBC=y
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+CONFIG_BUSFREQ_L2_160M=y
+CONFIG_EXYNOS4_SETUP_MSHCI_GPIO=y
+CONFIG_RTC_CLASS=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_TMPFS_XATTR=y
+CONFIG_S3C_DEV_I2C11_EMUL=y
+CONFIG_BCMDHD_NVRAM_PATH="/system/etc/wifi/bcmdhd.cal"
+CONFIG_INITRAMFS_ROOT_UID=0
+CONFIG_UMP_MEM_SIZE=1024
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_NF_NAT_TFTP=y
+CONFIG_OUTER_CACHE=y
+CONFIG_SERIAL_SAMSUNG_UARTS_4=y
+CONFIG_NO_IOPORT=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_SLUB=y
+CONFIG_S3C_DEV_I2C1=y
+CONFIG_PM_SLEEP=y
+CONFIG_I2C=y
+CONFIG_FRAME_POINTER=y
+CONFIG_BT_HIDP=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_CRYPTO_ECB=y
+CONFIG_VIDEO_FIMC_DMA_AUTO=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_DEBUG_FS=y
+CONFIG_BASE_FULL=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+CONFIG_MACH_Q1_BD=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_VIDEO_TVOUT=y
+CONFIG_VIDEO_SAMSUNG=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_FW_LOADER=y
+CONFIG_KALLSYMS=y
+CONFIG_SW_SYNC_USER=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_SIGNALFD=y
+CONFIG_REGULATOR_MAX8997=y
+CONFIG_IP_NF_TARGET_REJECT_SKERR=y
+CONFIG_EXT4_FS=y
+CONFIG_TV_FB=y
+CONFIG_CRYPTO_SHA1=y
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+CONFIG_IPV6_PRIVACY=y
+CONFIG_USB_GADGET_DUALSPEED=y
+CONFIG_HAS_IOMEM=y
+CONFIG_PPPOPNS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_NETFILTER_XT_TARGET_TRACE=y
+CONFIG_CMA_BEST_FIT=y
+CONFIG_HAVE_PWM=y
+CONFIG_EPOLL=y
+CONFIG_SND_PCM=y
+CONFIG_PM_RUNTIME=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_S3C_GPIO_TRACK=y
+CONFIG_IR_SONY_DECODER=y
+CONFIG_NETFILTER_XT_MATCH_COMMENT=y
+CONFIG_HDMI_EARJACK_MUTE=y
+CONFIG_NET=y
+CONFIG_INPUT_EVDEV=y
+CONFIG_MOTOR_DRV_MAX8997=y
+CONFIG_SND_JACK=y
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+CONFIG_S5P_GPIO_DRVSTR=y
+CONFIG_HAVE_SPARSE_IRQ=y
+CONFIG_EXT2_FS=y
+CONFIG_HID_DRAGONRISE=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+CONFIG_EXYNOS4_SETUP_SDHCI_GPIO=y
+CONFIG_VFPv3=y
+CONFIG_CPU_EXYNOS4210=y
+CONFIG_PACKET=y
+CONFIG_ARM_ERRATA_753970=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_MFD_MAX8997=y
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_INET=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_FREEZER=y
+CONFIG_BT=y
+CONFIG_RFKILL_PM=y
+CONFIG_NET_CLS_ACT=y
+CONFIG_EXYNOS_PM_HOTPLUG=y
+CONFIG_HID_WACOM=y
+CONFIG_RTC_LIB=y
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_CRYPTO_AES=y
+CONFIG_GPIOLIB=y
+CONFIG_VIDEO_MFC_MAX_INSTANCE=4
+CONFIG_S5PV310_HI_ARMCLK_THAN_1_2GHZ=y
+CONFIG_VIDEO_JPEG=y
+CONFIG_EXT4_USE_FOR_EXT23=y
+CONFIG_BT_HCIUART_H4=y
+CONFIG_SWP_EMULATE=y
+CONFIG_IP6_NF_TARGET_REJECT_SKERR=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NETFILTER=y
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_LIRC=y
+CONFIG_BT_BNEP=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_PN544=y
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMC1=32768
+CONFIG_PREEMPT_RCU=y
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_S5P_DEV_MIPI_DSI=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_ANDROID_PMEM_MEMSIZE_PMEM_GPU1=4
+CONFIG_SERIAL_SAMSUNG_UARTS=4
+CONFIG_NO_HZ=y
+CONFIG_RTC_INTF_ALARM=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_BATTERY_MAX17042_FUELGAUGE_U1=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+CONFIG_EXYNOS4_SETUP_USB_PHY=y
+CONFIG_INET6_ESP=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_I2C_S3C2410=y
+CONFIG_IP6_NF_FILTER=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_SERIO_LIBPS2=y
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=y
+CONFIG_ANDROID_PARANOID_NETWORK=y
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_USB_PRINTER=y
+CONFIG_CPU_V7=y
+CONFIG_FB_S5P=y
+CONFIG_TOUCHSCREEN_ATMEL_MXT540E=y
+CONFIG_PANIC_TIMEOUT=1
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_MMC_MSHCI=y
+CONFIG_EXYNOS4_DEV_MSHC=y
+CONFIG_CFG80211_DEFAULT_PS=y
+CONFIG_SMP=y
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_ANDROID_TIMED_OUTPUT=y
+CONFIG_LIBCRC32C=y
+CONFIG_IOSCHED_VR=y
+CONFIG_CRYPTO_SHA256=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_SND_SAMSUNG_I2S=y
+CONFIG_INET_TCP_DIAG=y
+CONFIG_HID_SONY=y
+CONFIG_HW_CONSOLE=y
+CONFIG_DEVMEM=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_EZKEY=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_SAMSUNG_CLKSRC=y
+CONFIG_NEON=y
+CONFIG_GENERIC_ACL=y
+CONFIG_COMPAT_BRK=y
+CONFIG_LOCALVERSION=""
+CONFIG_MACH_NO_WESTBRIDGE=y
+CONFIG_CRYPTO=y
+CONFIG_WITH_DVFS_POLICY=y
+CONFIG_SCHED_DEBUG=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_S3C_DEV_I2C7=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_CMDLINE="console=ttySAC2,115200 consoleblank=0"
+CONFIG_SPI_GPIO=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_FB_S5P_DEFAULT_WINDOW=2
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_VIDEO_SAMSUNG_V4L2=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_ALIGNMENT_TRAP=y
+CONFIG_FSYNC_CONTROL=y
+CONFIG_SCSI_MOD=y
+CONFIG_EXYNOS4_SETUP_FIMC1=y
+CONFIG_CPU_FREQ_GOV_LAGFREE=y
+CONFIG_SERIAL_SAMSUNG_CONSOLE=y
+CONFIG_CRYPTO_CRC32C=y
+CONFIG_ARCH_HAS_OPP=y
+CONFIG_SERIAL_CORE=y
+CONFIG_FUSE_FS=y
+CONFIG_VIDEO_TVOUT_2CH_AUDIO=y
+CONFIG_UID16=y
+CONFIG_EMBEDDED=y
+CONFIG_HID_MICROSOFT=y
+CONFIG_SMB328_CHARGER=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_SAMSUNG_IRQ_UART=y
+CONFIG_NF_DEFRAG_IPV6=y
+CONFIG_VIDEO_DEV=y
+CONFIG_EXYNOS_MCT=y
+CONFIG_HAS_DMA=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_BT_L2CAP=y
+CONFIG_VIDEO_MALI400MP_UMP=y
+CONFIG_VIDEO_MALI400MP_DVFS=y
+CONFIG_SCSI=y
+CONFIG_GPIO_EXYNOS4=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_NF_NAT_PPTP=y
+CONFIG_SAMSUNG_GPIO_EXTRA=0
+CONFIG_HID_CHICONY=y
+CONFIG_HID=y
+CONFIG_SENSORS_AK8975C=y
+CONFIG_USB_S3C_OTG_HOST=y
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_JBD2=y
+CONFIG_INET6_IPCOMP=y
+CONFIG_IPV6_TUNNEL=y
+CONFIG_S5P_DEV_JPEG=y
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_EHCI_IRQ_DISTRIBUTION=y
+CONFIG_MISC_FILESYSTEMS=y
+CONFIG_USB_CDFS_SUPPORT=y
+CONFIG_FTRACE=y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=y
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_HID_TOPSEED=y
+CONFIG_NF_NAT_H323=y
+CONFIG_AUDIO_SAMSUNG_MEMSIZE_SRP=1024
+CONFIG_HID_A4TECH=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+CONFIG_CHR_DEV_SG=y
+CONFIG_CPU_FREQ_GOV_SMARTASS=y
+CONFIG_SAMSUNG_DEV_TS=y
+CONFIG_VIDEO_S5K5BAFX=y
+CONFIG_VIBETONZ=y
+CONFIG_NF_NAT_AMANDA=y
+CONFIG_CACHE_PL310=y
+CONFIG_USB_S5P_HSIC0=y
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_CRYPTO_ARC4=y
+CONFIG_S5P_DEV_FIMG2D=y
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_MFC0=18432
+CONFIG_SLHC=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_NET_SCH_HTB=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_S5P_DEV_CSIS=y
+CONFIG_EXYNOS4_MSHC_MPLL_40MHZ=y
+CONFIG_RT_MUTEXES=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_HID_ORTEK=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_I2C_ALGOBIT=y
+CONFIG_MMC_BLOCK=y
+CONFIG_EXPERT=y
+CONFIG_EXYNOS4_CPUIDLE=y
+CONFIG_WIRELESS=y
+CONFIG_WEXT_PROC=y
+CONFIG_SMB136_CHARGER_Q1=y
+CONFIG_PERF_USE_VMALLOC=y
+CONFIG_UMTS_MODEM_XMM6260=y
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+CONFIG_FRAME_WARN=1024
+CONFIG_RCU_CPU_STALL_VERBOSE=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_INITRAMFS_SOURCE="/home/ali/android/kernel/Ramdisks/initramfs"
+CONFIG_CGROUPS=y
+CONFIG_MMC=y
+CONFIG_VIDEO_MFC_MEM_PORT_COUNT=2
+CONFIG_S5P_DEV_USBGADGET=y
+CONFIG_FB_S5P_MIPI_DSIM=y
+CONFIG_HID_LOGITECH=y
+CONFIG_PPPOLAC=y
+CONFIG_WTL_ENCRYPTION_FILTER=y
+CONFIG_FB_S5P_MDNIE=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_FB_EARLYSUSPEND=y
+CONFIG_HZ=200
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+CONFIG_RTC_DRV_MAX8997=y
+CONFIG_GENERIC_LOCKBREAK=y
+CONFIG_ARM_PATCH_PHYS_VIRT=y
+CONFIG_DEFAULT_IOSCHED="noop"
+CONFIG_IPV6_MIP6=y
+CONFIG_NLATTR=y
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_MACH_U1=y
+CONFIG_PM_RUNTIME_CLK=y
+CONFIG_NR_CPUS=2
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_MMC_SDHCI=y
+CONFIG_NETFILTER_XT_CONNMARK=y
+CONFIG_HID_KYE=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_SYSFS=y
+CONFIG_BUSFREQ=y
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_OUTER_CACHE_SYNC=y
+CONFIG_ARM_THUMB=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_MMC_SDHCI_S3C_DMA=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_ARM_ERRATA_754322=y
+CONFIG_FB=y
+CONFIG_I2C_COMPAT=y
+CONFIG_CPU_32v7=y
+CONFIG_EXYNOS4_SETUP_I2C1=y
+CONFIG_MSDOS_PARTITION=y
+CONFIG_BT_HCIUART=y
+CONFIG_HAVE_OPROFILE=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_HID_PETALYNX=y
+CONFIG_CMA_SIZE_MBYTES=16
+CONFIG_NET_ACT_MIRRED=y
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_SMP_ON_UP=y
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_RPS=y
+CONFIG_INET6_XFRM_TUNNEL=y
+CONFIG_MMC_SDHCI_S3C=y
+CONFIG_VIDEO_MEDIA=y
+CONFIG_IP_MULTICAST=y
+CONFIG_WAKELOCK_STAT=y
+CONFIG_INPUT_KEYCHORD=y
+CONFIG_HAS_EARLYSUSPEND=y
+CONFIG_CPU_32v6K=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_BUSFREQ_QOS=y
+CONFIG_USB_ANDROID_SAMSUNG_MTP=y
+CONFIG_TICK_ONESHOT=y
+CONFIG_NF_NAT_PROTO_UDPLITE=y
+CONFIG_CGROUP_DEBUG=y
+CONFIG_SW_SYNC=y
+CONFIG_VIDEO_FIXED_MINOR_RANGES=y
+CONFIG_ANDROID_LOGGER=m
+CONFIG_HW_RANDOM=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_CRYPTO_FIPS_INTEG_OFFSET=0x20000000
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_DEFAULT_NOOP=y
+CONFIG_DEBUG_S3C_UART=1
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_SND_SOC_U1_MC1N2=y
+CONFIG_VIDEOBUF2_CORE=y
+CONFIG_NTFS_FS=y
+CONFIG_ARCH_EXYNOS=y
+CONFIG_VIDEO_FIMG2D3X=y
+CONFIG_BASE_SMALL=0
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_COMPACTION=y
+CONFIG_S5P_DEV_FIMD_S5P=y
+CONFIG_SND_SOC_USE_EXTERNAL_MIC_BIAS=y
+CONFIG_PROC_FS=y
+CONFIG_RC_MAP=y
+CONFIG_SCSI_LOWLEVEL=y
+CONFIG_J4FS_BLOCK_COUNT=20
+CONFIG_HID_PANTHERLORD=y
+CONFIG_SND=y
+CONFIG_FLATMEM=y
+CONFIG_IR_RC6_DECODER=y
+CONFIG_S3C_DEV_HSMMC3=y
+CONFIG_FB_S5P_SPLASH_SCREEN=y
+CONFIG_IOVMM=y
+CONFIG_SEC_MODEM_U1=y
+CONFIG_S3C_GPIO_PULL_UPDOWN=y
+CONFIG_S3C_DEV_I2C3=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SYSCTL=y
+CONFIG_LOCAL_TIMERS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_PL310_ERRATA_727915=y
+CONFIG_CIFS=y
+CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMC2=25600
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PPP_ASYNC=y
+CONFIG_UID_STAT=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_RTC_INTF_ALARM_DEV=y
+CONFIG_CMA_AREAS=7
+CONFIG_SAMSUNG_PD=y
+CONFIG_S3C_GPIO_SPACE=0
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=y
+CONFIG_HID_ELECOM=y
+CONFIG_SND_TIMER=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_BLK_DEV=y
+CONFIG_SAMSUNG_ANALOG_UART_SWITCH=1
+CONFIG_TRACING_SUPPORT=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+CONFIG_JACK_RESELECTOR_SUPPORT=y
+CONFIG_NET_SCHED=y
+CONFIG_SAMSUNG_WORKAROUND_HPD_GLANCE=y
+CONFIG_PPP=y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_INET_DIAG=y
+CONFIG_NF_NAT_FTP=y
+CONFIG_HID_ROCCAT_KONE=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+CONFIG_ELF_CORE=y
+CONFIG_TEXTSEARCH=y
+CONFIG_WLAN_REGION_CODE=100
+CONFIG_USB_SUPPORT=y
+CONFIG_NETFILTER_XT_MATCH_QTAGUID=y
+CONFIG_PL330=y
+CONFIG_STAGING=y
+CONFIG_DMA_CMA=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_CPU_FREQ_GOV_PEGASUSQ=y
+CONFIG_CFG80211_WEXT=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_IR_RC5_DECODER=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+CONFIG_KEYBOARD_CYPRESS_TOUCH=y
+CONFIG_PREEMPT=y
+CONFIG_USE_MFC_CMA=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_MALI_OSMEM_ONLY=y
+CONFIG_EXYNOS4_PM=y
+CONFIG_MMC_CLKGATE=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_HID_NTRIG=y
+CONFIG_S3C_LOWLEVEL_UART_PORT=2
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_S5P_GPIO_INT=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_CROSS_COMPILE="/usr/local/arm/arm-eabi-4.4.3/bin/arm-eabi-"
+CONFIG_S3C_DEV_I2C6=y
+CONFIG_USB_GADGET_SELECTED=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_NLS_UTF8=y
+CONFIG_NETFILTER_TPROXY=y
+CONFIG_UMP_OSMEM_ONLY=y
+CONFIG_LTO_MENU=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_NET_ACT_POLICE=y
+CONFIG_EXYNOS4_SETUP_FIMC0=y
+CONFIG_HID_SMARTJOYPLUS=y
+CONFIG_NEW_LEDS=y
+CONFIG_VIDEO_FIMC_RANGE_NARROW=y
+CONFIG_CRC_CCITT=y
+CONFIG_ANDROID_PMEM=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_CMDLINE_FROM_BOOTLOADER=y
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_USB_ARCH_HAS_XHCI=y
+CONFIG_CMA=y
+CONFIG_SAMSUNG_GPIOLIB_4BIT=y
+CONFIG_RCU_FANOUT=32
+CONFIG_BITREVERSE=y
+CONFIG_BLK_DEV_RAM_SIZE=8192
+CONFIG_USB_GADGET_S3C_OTGD=y
+CONFIG_VIDEO_V4L2_COMMON=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_USER_ALLOC_TVOUT=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_LCD_CLASS_DEVICE=y
+CONFIG_FILE_LOCKING=y
+CONFIG_S3C_DEV_WDT=y
+CONFIG_SND_SOC_I2C_AND_SPI=y
+CONFIG_S5P_SYSTEM_MMU=y
+CONFIG_NET_EMATCH=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_LEDS_CLASS=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+CONFIG_INITRAMFS_COMPRESSION_GZIP=y
+CONFIG_RTC_INTF_DEV=y
+CONFIG_SAMSUNG_IRQ_VIC_TIMER=y
+CONFIG_HID_SUPPORT=y
+CONFIG_NET_ACTIVITY_STATS=y
+CONFIG_CMA_ALIGNMENT=8
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NF_CT_PROTO_GRE=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_HAVE_S3C2410_I2C=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_NETFILTER_XT_MATCH_HL=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_EXYNOS4_SETUP_THERMAL=y
+CONFIG_INPUT=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_MMU=y
+CONFIG_HAVE_IRQ_WORK=y
+CONFIG_USER_WAKELOCK=y
+CONFIG_SEC_MODEM=y
+CONFIG_SND_SAMSUNG_ALP=y
+CONFIG_S3C_DEV_FIMC=y
+CONFIG_PLAT_S5P=y
+CONFIG_FB_S5P_VSYNC_THREAD=y
diff -urNp Kernel/include/config/auto.conf.cmd HelloWorld-Renew-v1.0-n7000-jb/include/config/auto.conf.cmd
--- Kernel/include/config/auto.conf.cmd	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/include/config/auto.conf.cmd	2013-05-01 12:14:22.489107096 +0200
@@ -0,0 +1,755 @@
+deps_config := \
+	lib/xz/Kconfig \
+	lib/Kconfig \
+	drivers/crypto/caam/Kconfig \
+	drivers/crypto/Kconfig \
+	crypto/async_tx/Kconfig \
+	crypto/Kconfig \
+	security/integrity/ima/Kconfig \
+	security/apparmor/Kconfig \
+	security/tomoyo/Kconfig \
+	security/smack/Kconfig \
+	security/selinux/Kconfig \
+	security/Kconfig \
+	lib/Kconfig.kmemcheck \
+	lib/Kconfig.kgdb \
+	samples/Kconfig \
+	kernel/trace/Kconfig \
+	mm/Kconfig.debug \
+	lib/Kconfig.debug \
+	arch/arm/Kconfig.debug \
+	fs/dlm/Kconfig \
+	fs/nls/Kconfig \
+	fs/partitions/Kconfig \
+	fs/9p/Kconfig \
+	fs/afs/Kconfig \
+	fs/coda/Kconfig \
+	fs/ncpfs/Kconfig \
+	fs/cifs/Kconfig \
+	fs/ceph/Kconfig \
+	net/sunrpc/Kconfig \
+	fs/nfsd/Kconfig \
+	fs/nfs/Kconfig \
+	fs/exofs/Kconfig \
+	fs/ufs/Kconfig \
+	fs/sysv/Kconfig \
+	fs/pstore/Kconfig \
+	fs/romfs/Kconfig \
+	fs/qnx4/Kconfig \
+	fs/hpfs/Kconfig \
+	fs/omfs/Kconfig \
+	fs/minix/Kconfig \
+	fs/freevxfs/Kconfig \
+	fs/squashfs/Kconfig \
+	fs/cramfs/Kconfig \
+	fs/logfs/Kconfig \
+	fs/ubifs/Kconfig \
+	fs/jffs2/Kconfig \
+	fs/yaffs2/Kconfig \
+	fs/efs/Kconfig \
+	fs/bfs/Kconfig \
+	fs/befs/Kconfig \
+	fs/hfsplus/Kconfig \
+	fs/hfs/Kconfig \
+	fs/ecryptfs/Kconfig \
+	fs/affs/Kconfig \
+	fs/adfs/Kconfig \
+	fs/configfs/Kconfig \
+	fs/sysfs/Kconfig \
+	fs/proc/Kconfig \
+	fs/ntfs/Kconfig \
+	fs/fat/Kconfig \
+	fs/udf/Kconfig \
+	fs/isofs/Kconfig \
+	fs/cachefiles/Kconfig \
+	fs/fscache/Kconfig \
+	fs/fuse/Kconfig \
+	fs/autofs4/Kconfig \
+	fs/quota/Kconfig \
+	fs/notify/fanotify/Kconfig \
+	fs/notify/inotify/Kconfig \
+	fs/notify/dnotify/Kconfig \
+	fs/notify/Kconfig \
+	fs/nilfs2/Kconfig \
+	fs/btrfs/Kconfig \
+	fs/ocfs2/Kconfig \
+	fs/gfs2/Kconfig \
+	fs/xfs/Kconfig \
+	fs/jfs/Kconfig \
+	fs/reiserfs/Kconfig \
+	fs/jbd2/Kconfig \
+	fs/jbd/Kconfig \
+	fs/ext4/Kconfig \
+	fs/ext3/Kconfig \
+	fs/ext2/Kconfig \
+	fs/Kconfig \
+	drivers/j4fs/Kconfig \
+	drivers/interceptor/Kconfig \
+	drivers/felica/Kconfig \
+	drivers/iommu/Kconfig \
+	drivers/gud/Kconfig \
+	drivers/barcode_emul/Kconfig \
+	drivers/extcon/Kconfig \
+	drivers/irda/Kconfig \
+	drivers/accessory/Kconfig \
+	drivers/svnet/Kconfig \
+	drivers/phone_svn/Kconfig \
+	drivers/devfreq/Kconfig \
+	drivers/sensorhub/Kconfig \
+	drivers/sensor/Kconfig \
+	drivers/samsung/Kconfig \
+	drivers/motor/Kconfig \
+	drivers/clocksource/Kconfig \
+	drivers/hwspinlock/Kconfig \
+	drivers/clk/Kconfig \
+	drivers/platform/x86/Kconfig \
+	drivers/platform/Kconfig \
+	drivers/staging/nvec/Kconfig \
+	drivers/staging/mei/Kconfig \
+	drivers/staging/altera-stapl/Kconfig \
+	drivers/staging/gma500/Kconfig \
+	drivers/staging/ste_rmi4/Kconfig \
+	drivers/staging/cptm1217/Kconfig \
+	drivers/staging/speakup/Kconfig \
+	drivers/staging/intel_sst/Kconfig \
+	drivers/staging/ft1000/Kconfig \
+	drivers/staging/bcm/Kconfig \
+	drivers/staging/keucr/Kconfig \
+	drivers/staging/ath6kl/Kconfig \
+	drivers/staging/sbe-2t3e3/Kconfig \
+	drivers/staging/westbridge/astoria/switch/Kconfig \
+	drivers/staging/westbridge/astoria/gadget/Kconfig \
+	drivers/staging/westbridge/astoria/block/Kconfig \
+	drivers/staging/westbridge/astoria/device/Kconfig \
+	drivers/staging/westbridge/astoria/Kconfig \
+	drivers/staging/westbridge/Kconfig \
+	drivers/staging/quickstart/Kconfig \
+	drivers/staging/tidspbridge/Kconfig \
+	drivers/staging/solo6x10/Kconfig \
+	drivers/staging/easycap/Kconfig \
+	drivers/staging/lirc/Kconfig \
+	drivers/staging/msm/Kconfig \
+	drivers/staging/xgifb/Kconfig \
+	drivers/staging/cxt1e1/Kconfig \
+	drivers/staging/crystalhd/Kconfig \
+	drivers/staging/dt3155v4l/Kconfig \
+	drivers/staging/sm7xx/Kconfig \
+	drivers/staging/wlags49_h25/Kconfig \
+	drivers/staging/wlags49_h2/Kconfig \
+	drivers/staging/zcache/Kconfig \
+	drivers/staging/zram/Kconfig \
+	drivers/staging/cs5535_gpio/Kconfig \
+	drivers/staging/iio/trigger/Kconfig \
+	drivers/staging/iio/resolver/Kconfig \
+	drivers/staging/iio/meter/Kconfig \
+	drivers/staging/iio/magnetometer/Kconfig \
+	drivers/staging/iio/light/Kconfig \
+	drivers/staging/iio/imu/Kconfig \
+	drivers/staging/iio/gyro/Kconfig \
+	drivers/staging/iio/dds/Kconfig \
+	drivers/staging/iio/dac/Kconfig \
+	drivers/staging/iio/addac/Kconfig \
+	drivers/staging/iio/adc/Kconfig \
+	drivers/staging/iio/accel/Kconfig \
+	drivers/staging/iio/Kconfig \
+	drivers/staging/sep/Kconfig \
+	drivers/staging/vme/boards/Kconfig \
+	drivers/staging/vme/devices/Kconfig \
+	drivers/staging/vme/bridges/Kconfig \
+	drivers/staging/vme/Kconfig \
+	drivers/staging/hv/Kconfig \
+	drivers/staging/vt6656/Kconfig \
+	drivers/staging/vt6655/Kconfig \
+	drivers/staging/quatech_usb2/Kconfig \
+	drivers/staging/spectra/Kconfig \
+	drivers/staging/serqt_usb2/Kconfig \
+	drivers/staging/octeon/Kconfig \
+	drivers/gpu/drm/nouveau/Kconfig \
+	drivers/staging/line6/Kconfig \
+	drivers/staging/phison/Kconfig \
+	drivers/staging/pohmelfs/Kconfig \
+	drivers/staging/android/Kconfig \
+	drivers/staging/frontier/Kconfig \
+	drivers/staging/rts_pstor/Kconfig \
+	drivers/staging/rtl8712/Kconfig \
+	drivers/staging/rtl8192e/Kconfig \
+	drivers/staging/rtl8192u/Kconfig \
+	drivers/staging/rtl8187se/Kconfig \
+	drivers/staging/panel/Kconfig \
+	drivers/staging/asus_oled/Kconfig \
+	drivers/staging/olpc_dcon/Kconfig \
+	drivers/staging/comedi/Kconfig \
+	drivers/staging/brcm80211/Kconfig \
+	drivers/staging/echo/Kconfig \
+	drivers/staging/wlan-ng/Kconfig \
+	drivers/staging/winbond/Kconfig \
+	drivers/staging/usbip/Kconfig \
+	drivers/staging/cxd2099/Kconfig \
+	drivers/staging/tm6000/Kconfig \
+	drivers/staging/cx25821/Kconfig \
+	drivers/staging/go7007/Kconfig \
+	drivers/staging/slicoss/Kconfig \
+	drivers/staging/et131x/Kconfig \
+	drivers/staging/generic_serial/Kconfig \
+	drivers/staging/tty/Kconfig \
+	drivers/staging/Kconfig \
+	drivers/xen/Kconfig \
+	drivers/vlynq/Kconfig \
+	drivers/uio/Kconfig \
+	drivers/auxdisplay/Kconfig \
+	drivers/dca/Kconfig \
+	drivers/dma/Kconfig \
+	drivers/rtc/Kconfig \
+	drivers/edac/Kconfig \
+	drivers/infiniband/ulp/iser/Kconfig \
+	drivers/infiniband/ulp/srp/Kconfig \
+	drivers/infiniband/ulp/ipoib/Kconfig \
+	drivers/infiniband/hw/nes/Kconfig \
+	drivers/infiniband/hw/mlx4/Kconfig \
+	drivers/infiniband/hw/cxgb4/Kconfig \
+	drivers/infiniband/hw/cxgb3/Kconfig \
+	drivers/infiniband/hw/amso1100/Kconfig \
+	drivers/infiniband/hw/ehca/Kconfig \
+	drivers/infiniband/hw/qib/Kconfig \
+	drivers/infiniband/hw/ipath/Kconfig \
+	drivers/infiniband/hw/mthca/Kconfig \
+	drivers/infiniband/Kconfig \
+	drivers/accessibility/Kconfig \
+	drivers/switch/Kconfig \
+	drivers/nfc/Kconfig \
+	drivers/leds/Kconfig \
+	drivers/memstick/host/Kconfig \
+	drivers/memstick/core/Kconfig \
+	drivers/memstick/Kconfig \
+	drivers/mmc/host/Kconfig \
+	drivers/mmc/card/Kconfig \
+	drivers/mmc/core/Kconfig \
+	drivers/mmc/Kconfig \
+	drivers/uwb/Kconfig \
+	drivers/usb/otg/Kconfig \
+	drivers/usb/gadget/Kconfig \
+	drivers/usb/atm/Kconfig \
+	drivers/usb/misc/sisusbvga/Kconfig \
+	drivers/usb/misc/Kconfig \
+	drivers/usb/serial/Kconfig \
+	drivers/usb/image/Kconfig \
+	drivers/usb/storage/Kconfig \
+	drivers/usb/class/Kconfig \
+	drivers/usb/renesas_usbhs/Kconfig \
+	drivers/usb/musb/Kconfig \
+	drivers/usb/host/Kconfig \
+	drivers/usb/wusbcore/Kconfig \
+	drivers/usb/mon/Kconfig \
+	drivers/usb/notify/Kconfig \
+	drivers/usb/core/Kconfig \
+	drivers/usb/Kconfig \
+	drivers/hid/usbhid/Kconfig \
+	drivers/hid/Kconfig \
+	sound/oss/Kconfig \
+	sound/soc/codecs/mc1n2/Kconfig \
+	sound/soc/codecs/Kconfig \
+	sound/soc/txx9/Kconfig \
+	sound/soc/tegra/Kconfig \
+	sound/soc/sh/Kconfig \
+	sound/soc/s6000/Kconfig \
+	sound/soc/samsung/srp_ulp/Kconfig \
+	sound/soc/samsung/srp_alp/Kconfig \
+	sound/soc/samsung/Kconfig \
+	sound/soc/pxa/Kconfig \
+	sound/soc/mid-x86/Kconfig \
+	sound/soc/kirkwood/Kconfig \
+	sound/soc/omap/Kconfig \
+	sound/soc/nuc900/Kconfig \
+	sound/soc/jz4740/Kconfig \
+	sound/soc/imx/Kconfig \
+	sound/soc/fsl/Kconfig \
+	sound/soc/ep93xx/Kconfig \
+	sound/soc/davinci/Kconfig \
+	sound/soc/blackfin/Kconfig \
+	sound/soc/au1x/Kconfig \
+	sound/soc/atmel/Kconfig \
+	sound/soc/Kconfig \
+	sound/parisc/Kconfig \
+	sound/sparc/Kconfig \
+	sound/pcmcia/Kconfig \
+	sound/firewire/Kconfig \
+	sound/usb/Kconfig \
+	sound/sh/Kconfig \
+	sound/mips/Kconfig \
+	sound/spi/Kconfig \
+	sound/atmel/Kconfig \
+	sound/arm/Kconfig \
+	sound/aoa/soundbus/Kconfig \
+	sound/aoa/codecs/Kconfig \
+	sound/aoa/fabrics/Kconfig \
+	sound/aoa/Kconfig \
+	sound/ppc/Kconfig \
+	sound/pci/hda/Kconfig \
+	sound/pci/Kconfig \
+	sound/isa/Kconfig \
+	sound/drivers/Kconfig \
+	sound/core/seq/Kconfig \
+	sound/core/Kconfig \
+	sound/oss/dmasound/Kconfig \
+	sound/Kconfig \
+	drivers/video/logo/Kconfig \
+	drivers/video/console/Kconfig \
+	drivers/video/display/Kconfig \
+	drivers/video/backlight/Kconfig \
+	drivers/video/omap2/displays/Kconfig \
+	drivers/video/omap2/omapfb/Kconfig \
+	drivers/video/omap2/dss/Kconfig \
+	drivers/video/omap2/Kconfig \
+	drivers/video/omap/Kconfig \
+	drivers/video/geode/Kconfig \
+	drivers/video/samsung_duallcd/Kconfig \
+	drivers/video/samsung_extdisp/Kconfig \
+	drivers/video/samsung/Kconfig \
+	drivers/gpu/ion/Kconfig \
+	drivers/gpu/stub/Kconfig \
+	drivers/gpu/drm/udl/Kconfig \
+	drivers/gpu/drm/gma500/Kconfig \
+	drivers/gpu/drm/vmwgfx/Kconfig \
+	drivers/gpu/drm/exynos/Kconfig \
+	drivers/gpu/drm/radeon/Kconfig \
+	drivers/gpu/drm/Kconfig \
+	drivers/gpu/vga/Kconfig \
+	drivers/char/agp/Kconfig \
+	drivers/video/Kconfig \
+	drivers/media/isdbt/Kconfig \
+	drivers/media/tdmb/Kconfig \
+	drivers/media/dvb/frontends/Kconfig \
+	drivers/media/dvb/ngene/Kconfig \
+	drivers/media/dvb/mantis/Kconfig \
+	drivers/media/dvb/pt1/Kconfig \
+	drivers/media/dvb/firewire/Kconfig \
+	drivers/media/dvb/dm1105/Kconfig \
+	drivers/media/dvb/pluto2/Kconfig \
+	drivers/media/dvb/bt8xx/Kconfig \
+	drivers/media/dvb/b2c2/Kconfig \
+	drivers/media/dvb/siano/Kconfig \
+	drivers/media/dvb/ttusb-dec/Kconfig \
+	drivers/media/dvb/ttusb-budget/Kconfig \
+	drivers/media/dvb/dvb-usb/Kconfig \
+	drivers/media/dvb/ttpci/Kconfig \
+	drivers/media/dvb/Kconfig \
+	drivers/media/radio/wl128x/Kconfig \
+	drivers/media/radio/si470x/Kconfig \
+	drivers/media/radio/Kconfig \
+	drivers/media/video/mhl/Kconfig \
+	drivers/media/video/exynos/fimc-is-mc/Kconfig \
+	drivers/media/video/exynos/gsc/Kconfig \
+	drivers/media/video/exynos/fimc-is/Kconfig \
+	drivers/media/video/exynos/rotator/Kconfig \
+	drivers/media/video/exynos/tv/Kconfig \
+	drivers/media/video/exynos/mipi-csis/Kconfig \
+	drivers/media/video/exynos/fimc-lite/Kconfig \
+	drivers/media/video/exynos/mdev/Kconfig \
+	drivers/media/video/exynos/Kconfig \
+	drivers/media/video/samsung/jpeg_v2x/Kconfig \
+	drivers/media/video/samsung/jpeg/Kconfig \
+	drivers/media/video/samsung/fimg2d4x-exynos4/Kconfig \
+	drivers/media/video/samsung/fimg2d3x-exynos4/Kconfig \
+	drivers/media/video/samsung/fimg2d4x/Kconfig \
+	drivers/media/video/samsung/fimg2d3x/Kconfig \
+	drivers/media/video/samsung/mfc5x/Kconfig \
+	drivers/media/video/samsung/tvout/Kconfig \
+	drivers/media/video/samsung/fimc/Kconfig \
+	drivers/media/video/samsung/Kconfig \
+	drivers/media/video/pwc/Kconfig \
+	drivers/media/video/sn9c102/Kconfig \
+	drivers/media/video/et61x251/Kconfig \
+	drivers/media/video/usbvision/Kconfig \
+	drivers/media/video/cx231xx/Kconfig \
+	drivers/media/video/tlg2300/Kconfig \
+	drivers/media/video/em28xx/Kconfig \
+	drivers/media/video/hdpvr/Kconfig \
+	drivers/media/video/pvrusb2/Kconfig \
+	drivers/media/video/gspca/gl860/Kconfig \
+	drivers/media/video/gspca/stv06xx/Kconfig \
+	drivers/media/video/gspca/m5602/Kconfig \
+	drivers/media/video/gspca/Kconfig \
+	drivers/media/video/uvc/Kconfig \
+	drivers/media/video/m5mols/Kconfig \
+	drivers/media/video/saa7164/Kconfig \
+	drivers/media/video/cx18/Kconfig \
+	drivers/media/video/ivtv/Kconfig \
+	drivers/media/video/au0828/Kconfig \
+	drivers/media/video/cx23885/Kconfig \
+	drivers/media/video/cx88/Kconfig \
+	drivers/media/video/saa7134/Kconfig \
+	drivers/media/video/zoran/Kconfig \
+	drivers/media/video/cpia2/Kconfig \
+	drivers/media/video/bt8xx/Kconfig \
+	drivers/media/video/omap/Kconfig \
+	drivers/media/video/davinci/Kconfig \
+	drivers/media/video/cx25840/Kconfig \
+	drivers/media/video/Kconfig \
+	drivers/media/common/tuners/Kconfig \
+	drivers/media/rc/keymaps/Kconfig \
+	drivers/media/rc/Kconfig \
+	drivers/media/common/Kconfig \
+	drivers/media/Kconfig \
+	drivers/regulator/Kconfig \
+	drivers/mfd/Kconfig \
+	drivers/bcma/Kconfig \
+	drivers/ssb/Kconfig \
+	drivers/watchdog/Kconfig \
+	drivers/thermal/Kconfig \
+	drivers/hwmon/Kconfig \
+	drivers/power/Kconfig \
+	drivers/battery/Kconfig \
+	drivers/w1/slaves/Kconfig \
+	drivers/w1/masters/Kconfig \
+	drivers/w1/Kconfig \
+	drivers/gpio/Kconfig \
+	drivers/ptp/Kconfig \
+	drivers/pps/generators/Kconfig \
+	drivers/pps/clients/Kconfig \
+	drivers/pps/Kconfig \
+	drivers/spi/Kconfig \
+	drivers/i2c/busses/Kconfig \
+	drivers/i2c/algos/Kconfig \
+	drivers/i2c/muxes/Kconfig \
+	drivers/i2c/Kconfig \
+	drivers/s390/char/Kconfig \
+	drivers/char/tpm/Kconfig \
+	drivers/char/pcmcia/Kconfig \
+	drivers/char/hw_random/Kconfig \
+	drivers/char/ipmi/Kconfig \
+	drivers/tty/hvc/Kconfig \
+	drivers/char/diag/Kconfig \
+	drivers/tty/serial/Kconfig \
+	drivers/tty/Kconfig \
+	drivers/char/Kconfig \
+	drivers/input/gameport/Kconfig \
+	drivers/input/serio/Kconfig \
+	drivers/input/misc/Kconfig \
+	drivers/input/touchscreen/wacom/Kconfig \
+	drivers/input/touchscreen/Kconfig \
+	drivers/input/tablet/Kconfig \
+	drivers/input/joystick/iforce/Kconfig \
+	drivers/input/joystick/Kconfig \
+	drivers/input/mouse/Kconfig \
+	drivers/input/keyboard/cypress/Kconfig \
+	drivers/input/keyboard/Kconfig \
+	drivers/input/Kconfig \
+	drivers/telephony/Kconfig \
+	drivers/isdn/hardware/mISDN/Kconfig \
+	drivers/isdn/mISDN/Kconfig \
+	drivers/isdn/hysdn/Kconfig \
+	drivers/isdn/gigaset/Kconfig \
+	drivers/isdn/hardware/eicon/Kconfig \
+	drivers/isdn/hardware/avm/Kconfig \
+	drivers/isdn/hardware/Kconfig \
+	drivers/isdn/capi/Kconfig \
+	drivers/isdn/act2000/Kconfig \
+	drivers/isdn/sc/Kconfig \
+	drivers/isdn/pcbit/Kconfig \
+	drivers/isdn/icn/Kconfig \
+	drivers/isdn/hisax/Kconfig \
+	drivers/isdn/i4l/Kconfig \
+	drivers/isdn/Kconfig \
+	drivers/net/caif/Kconfig \
+	drivers/s390/net/Kconfig \
+	drivers/ieee802154/Kconfig \
+	drivers/atm/Kconfig \
+	drivers/net/wan/Kconfig \
+	drivers/net/pcmcia/Kconfig \
+	drivers/net/usb/Kconfig \
+	drivers/net/wimax/i2400m/Kconfig \
+	drivers/net/wimax/Kconfig \
+	drivers/net/wimax_cmc/Kconfig \
+	drivers/net/wireless/mwlan_aarp/Kconfig \
+	drivers/net/wireless/mwifiex/Kconfig \
+	drivers/net/wireless/zd1211rw/Kconfig \
+	drivers/net/wireless/wl12xx/Kconfig \
+	drivers/net/wireless/wl1251/Kconfig \
+	drivers/net/wireless/rtlwifi/Kconfig \
+	drivers/net/wireless/rt2x00/Kconfig \
+	drivers/net/wireless/p54/Kconfig \
+	drivers/net/wireless/orinoco/Kconfig \
+	drivers/net/wireless/libertas/Kconfig \
+	drivers/net/wireless/iwmc3200wifi/Kconfig \
+	drivers/net/wireless/iwlegacy/Kconfig \
+	drivers/net/wireless/iwlwifi/Kconfig \
+	drivers/net/wireless/ipw2x00/Kconfig \
+	drivers/net/wireless/hostap/Kconfig \
+	drivers/net/wireless/bcmdhd/Kconfig \
+	drivers/net/wireless/b43legacy/Kconfig \
+	drivers/net/wireless/b43/Kconfig \
+	drivers/net/wireless/ath/ath6kl/Kconfig \
+	drivers/net/wireless/ath/Kconfig \
+	drivers/net/wireless/rtl818x/Kconfig \
+	drivers/net/wireless/Kconfig \
+	drivers/net/tokenring/Kconfig \
+	drivers/net/benet/Kconfig \
+	drivers/net/sfc/Kconfig \
+	drivers/net/stmmac/Kconfig \
+	drivers/net/ixp2000/Kconfig \
+	drivers/net/octeon/Kconfig \
+	drivers/net/fs_enet/Kconfig \
+	drivers/net/ibm_newemac/Kconfig \
+	drivers/net/tulip/Kconfig \
+	drivers/net/arm/Kconfig \
+	drivers/net/phy/Kconfig \
+	drivers/net/arcnet/Kconfig \
+	drivers/net/Kconfig \
+	drivers/macintosh/Kconfig \
+	drivers/message/i2o/Kconfig \
+	drivers/firewire/Kconfig \
+	drivers/message/fusion/Kconfig \
+	drivers/target/tcm_fc/Kconfig \
+	drivers/target/loopback/Kconfig \
+	drivers/target/Kconfig \
+	drivers/md/Kconfig \
+	drivers/ata/Kconfig \
+	drivers/scsi/osd/Kconfig \
+	drivers/scsi/device_handler/Kconfig \
+	drivers/scsi/pcmcia/Kconfig \
+	drivers/scsi/arm/Kconfig \
+	drivers/scsi/qla4xxx/Kconfig \
+	drivers/scsi/qla2xxx/Kconfig \
+	drivers/scsi/mpt2sas/Kconfig \
+	drivers/scsi/megaraid/Kconfig.megaraid \
+	drivers/scsi/mvsas/Kconfig \
+	drivers/scsi/aic94xx/Kconfig \
+	drivers/scsi/aic7xxx/Kconfig.aic79xx \
+	drivers/scsi/aic7xxx/Kconfig.aic7xxx \
+	drivers/scsi/be2iscsi/Kconfig \
+	drivers/scsi/bnx2fc/Kconfig \
+	drivers/scsi/bnx2i/Kconfig \
+	drivers/scsi/cxgbi/cxgb4i/Kconfig \
+	drivers/scsi/cxgbi/cxgb3i/Kconfig \
+	drivers/scsi/cxgbi/Kconfig \
+	drivers/scsi/libsas/Kconfig \
+	drivers/scsi/Kconfig \
+	drivers/ide/Kconfig \
+	drivers/misc/modem_if_na_spr/Kconfig \
+	drivers/misc/modem_if_na/Kconfig \
+	drivers/misc/modem_if/Kconfig \
+	drivers/misc/c2c/Kconfig \
+	drivers/misc/carma/Kconfig \
+	drivers/misc/lis3lv02d/Kconfig \
+	drivers/misc/ti-st/Kconfig \
+	drivers/misc/inv_mpu/Kconfig \
+	drivers/misc/mpu3050/Kconfig \
+	drivers/misc/iwmc3200top/Kconfig \
+	drivers/misc/cb710/Kconfig \
+	drivers/misc/eeprom/Kconfig \
+	drivers/misc/c2port/Kconfig \
+	drivers/misc/2mic/Kconfig \
+	drivers/misc/Kconfig \
+	drivers/s390/block/Kconfig \
+	drivers/block/drbd/Kconfig \
+	drivers/block/paride/Kconfig \
+	drivers/block/Kconfig \
+	drivers/pnp/pnpacpi/Kconfig \
+	drivers/pnp/pnpbios/Kconfig \
+	drivers/pnp/isapnp/Kconfig \
+	drivers/pnp/Kconfig \
+	drivers/parport/Kconfig \
+	drivers/of/Kconfig \
+	drivers/mtd/ubi/Kconfig \
+	drivers/mtd/lpddr/Kconfig \
+	drivers/mtd/onenand/Kconfig \
+	drivers/mtd/nand/Kconfig \
+	drivers/mtd/devices/Kconfig \
+	drivers/mtd/maps/Kconfig \
+	drivers/mtd/chips/Kconfig \
+	drivers/mtd/Kconfig \
+	drivers/connector/Kconfig \
+	drivers/base/Kconfig \
+	drivers/Kconfig \
+	net/ceph/Kconfig \
+	net/caif/Kconfig \
+	net/9p/Kconfig \
+	net/rfkill/Kconfig \
+	net/wimax/Kconfig \
+	net/mac80211/Kconfig \
+	net/wireless/Kconfig \
+	net/rxrpc/Kconfig \
+	drivers/bluetooth_tizen/Kconfig \
+	net/bluetooth_tizen/hidp/Kconfig \
+	net/bluetooth_tizen/cmtp/Kconfig \
+	net/bluetooth_tizen/bnep/Kconfig \
+	net/bluetooth_tizen/rfcomm/Kconfig \
+	net/bluetooth_tizen/Kconfig \
+	net/bluetooth_mgmt/hidp/Kconfig \
+	net/bluetooth_mgmt/cmtp/Kconfig \
+	net/bluetooth_mgmt/bnep/Kconfig \
+	net/bluetooth_mgmt/rfcomm/Kconfig \
+	net/bluetooth_mgmt/Kconfig \
+	drivers/bluetooth/Kconfig \
+	net/bluetooth/hidp/Kconfig \
+	net/bluetooth/cmtp/Kconfig \
+	net/bluetooth/bnep/Kconfig \
+	net/bluetooth/rfcomm/Kconfig \
+	net/bluetooth/Kconfig \
+	drivers/net/irda/Kconfig \
+	net/irda/ircomm/Kconfig \
+	net/irda/irnet/Kconfig \
+	net/irda/irlan/Kconfig \
+	net/irda/Kconfig \
+	drivers/net/can/softing/Kconfig \
+	drivers/net/can/usb/Kconfig \
+	drivers/net/can/c_can/Kconfig \
+	drivers/net/can/sja1000/Kconfig \
+	drivers/net/can/mscan/Kconfig \
+	drivers/net/can/Kconfig \
+	net/can/Kconfig \
+	drivers/net/hamradio/Kconfig \
+	net/ax25/Kconfig \
+	net/batman-adv/Kconfig \
+	net/dns_resolver/Kconfig \
+	net/dcb/Kconfig \
+	net/sched/Kconfig \
+	net/ieee802154/Kconfig \
+	net/phonet/Kconfig \
+	net/wanrouter/Kconfig \
+	net/econet/Kconfig \
+	net/lapb/Kconfig \
+	net/x25/Kconfig \
+	drivers/net/appletalk/Kconfig \
+	net/ipx/Kconfig \
+	net/llc/Kconfig \
+	net/decnet/Kconfig \
+	net/8021q/Kconfig \
+	net/dsa/Kconfig \
+	net/bridge/Kconfig \
+	net/802/Kconfig \
+	net/l2tp/Kconfig \
+	net/atm/Kconfig \
+	net/tipc/Kconfig \
+	net/rds/Kconfig \
+	net/sctp/Kconfig \
+	net/dccp/ccids/Kconfig \
+	net/dccp/Kconfig \
+	net/bridge/netfilter/Kconfig \
+	net/decnet/netfilter/Kconfig \
+	net/ipv6/netfilter/Kconfig \
+	net/ipv4/netfilter/Kconfig \
+	net/netfilter/ipvs/Kconfig \
+	net/netfilter/ipset/Kconfig \
+	net/netfilter/Kconfig \
+	net/netlabel/Kconfig \
+	net/ipv6/Kconfig \
+	net/ipv4/Kconfig \
+	net/iucv/Kconfig \
+	net/xfrm/Kconfig \
+	net/unix/Kconfig \
+	net/packet/Kconfig \
+	net/Kconfig \
+	kernel/power/Kconfig \
+	fs/Kconfig.binfmt \
+	drivers/cpuidle/Kconfig \
+	drivers/cpufreq/Kconfig.x86 \
+	drivers/cpufreq/Kconfig \
+	arch/arm/mvp/Kconfig \
+	mm/Kconfig \
+	kernel/Kconfig.preempt \
+	kernel/time/Kconfig \
+	drivers/pcmcia/Kconfig \
+	drivers/pci/Kconfig \
+	arch/arm/common/Kconfig \
+	arch/arm/Kconfig-nommu \
+	arch/arm/mm/Kconfig \
+	arch/arm/mach-w90x900/Kconfig \
+	arch/arm/mach-vt8500/Kconfig \
+	arch/arm/plat-versatile/Kconfig \
+	arch/arm/mach-vexpress/Kconfig \
+	arch/arm/mach-versatile/Kconfig \
+	arch/arm/mach-ux500/Kconfig \
+	arch/arm/mach-u300/Kconfig \
+	arch/arm/mach-tegra/Kconfig \
+	drivers/sh/intc/Kconfig \
+	drivers/sh/Kconfig \
+	arch/arm/mach-shmobile/Kconfig \
+	arch/arm/mach-exynos/Kconfig.local \
+	arch/arm/mach-exynos/Kconfig \
+	arch/arm/mach-s5pv210/Kconfig \
+	arch/arm/mach-s5pc100/Kconfig \
+	arch/arm/mach-s5p64x0/Kconfig \
+	arch/arm/mach-s3c64xx/Kconfig \
+	arch/arm/mach-s3c2443/Kconfig \
+	arch/arm/mach-s3c2440/Kconfig \
+	arch/arm/mach-s3c2416/Kconfig \
+	arch/arm/mach-s3c2412/Kconfig \
+	arch/arm/mach-s3c2410/Kconfig \
+	arch/arm/mach-s3c2400/Kconfig \
+	arch/arm/mach-tcc8k/Kconfig \
+	arch/arm/plat-tcc/Kconfig \
+	arch/arm/mach-spear6xx/Kconfig \
+	arch/arm/mach-spear3xx/Kconfig \
+	arch/arm/plat-spear/Kconfig \
+	arch/arm/plat-s5p/Kconfig \
+	arch/arm/plat-s3c24xx/Kconfig \
+	arch/arm/plat-samsung/Kconfig \
+	arch/arm/mach-sa1100/Kconfig \
+	arch/arm/mach-realview/Kconfig \
+	arch/arm/mach-mmp/Kconfig \
+	arch/arm/plat-pxa/Kconfig \
+	arch/arm/mach-pxa/Kconfig \
+	arch/arm/mach-orion5x/Kconfig \
+	arch/arm/mach-omap2/Kconfig \
+	arch/arm/mach-omap1/Kconfig \
+	arch/arm/plat-omap/Kconfig \
+	arch/arm/mach-nuc93x/Kconfig \
+	arch/arm/plat-nomadik/Kconfig \
+	arch/arm/mach-nomadik/Kconfig \
+	arch/arm/mach-netx/Kconfig \
+	arch/arm/mach-mxs/devices/Kconfig \
+	arch/arm/mach-mxs/Kconfig \
+	arch/arm/mach-mx5/Kconfig \
+	arch/arm/mach-imx/Kconfig \
+	arch/arm/plat-mxc/devices/Kconfig \
+	arch/arm/plat-mxc/Kconfig \
+	arch/arm/mach-mv78xx0/Kconfig \
+	arch/arm/mach-msm/Kconfig \
+	arch/arm/mach-lpc32xx/Kconfig \
+	arch/arm/mach-loki/Kconfig \
+	arch/arm/mach-ks8695/Kconfig \
+	arch/arm/mach-kirkwood/Kconfig \
+	arch/arm/mach-ixp23xx/Kconfig \
+	arch/arm/mach-ixp2000/Kconfig \
+	arch/arm/mach-ixp4xx/Kconfig \
+	arch/arm/mach-iop13xx/Kconfig \
+	arch/arm/mach-iop33x/Kconfig \
+	arch/arm/mach-iop32x/Kconfig \
+	arch/arm/mach-integrator/Kconfig \
+	arch/arm/mach-h720x/Kconfig \
+	arch/arm/mach-gemini/Kconfig \
+	arch/arm/mach-footbridge/Kconfig \
+	arch/arm/mach-ep93xx/Kconfig \
+	arch/arm/mach-dove/Kconfig \
+	arch/arm/mach-davinci/Kconfig \
+	arch/arm/mach-cns3xxx/Kconfig \
+	arch/arm/mach-clps711x/Kconfig \
+	arch/arm/mach-bcmring/Kconfig \
+	arch/arm/mach-at91/Kconfig \
+	kernel/Kconfig.freezer \
+	kernel/Kconfig.locks \
+	block/Kconfig.iosched \
+	block/Kconfig \
+	kernel/gcov/Kconfig \
+	arch/Kconfig \
+	usr/Kconfig \
+	kernel/irq/Kconfig \
+	init/Kconfig \
+	arch/arm/Kconfig \
+	Kconfig
+
+include/config/auto.conf: \
+	$(deps_config)
+
+ifneq "$(KERNELVERSION)" "3.0.31-1103517"
+include/config/auto.conf: FORCE
+endif
+ifneq "$(ARCH)" "arm"
+include/config/auto.conf: FORCE
+endif
+ifneq "$(SRCARCH)" "arm"
+include/config/auto.conf: FORCE
+endif
+
+$(deps_config): ;
diff -urNp Kernel/include/config/kernel.release HelloWorld-Renew-v1.0-n7000-jb/include/config/kernel.release
--- Kernel/include/config/kernel.release	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/include/config/kernel.release	2013-05-02 00:40:38.555412681 +0200
@@ -0,0 +1 @@
+3.0.31-1103517
diff -urNp Kernel/include/config/tristate.conf HelloWorld-Renew-v1.0-n7000-jb/include/config/tristate.conf
--- Kernel/include/config/tristate.conf	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/include/config/tristate.conf	2013-05-01 12:14:22.501107096 +0200
@@ -0,0 +1,364 @@
+#
+# Automatically generated - do not edit
+
+CONFIG_NF_CONNTRACK_H323=Y
+CONFIG_IP_NF_TARGET_REDIRECT=Y
+CONFIG_CRC32=Y
+CONFIG_NF_NAT_PROTO_SCTP=Y
+CONFIG_IR_JVC_DECODER=Y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=Y
+CONFIG_BLK_DEV_DM=Y
+CONFIG_BT_RFCOMM=Y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=Y
+CONFIG_CRYPTO_MD4=Y
+CONFIG_SERIAL_S5PV210=Y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=Y
+CONFIG_RC_CORE=Y
+CONFIG_BINFMT_MISC=Y
+CONFIG_NETFILTER_XT_MATCH_HELPER=Y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=Y
+CONFIG_CPU_FREQ_GOV_HYPER=Y
+CONFIG_LEDS_MAX8997=Y
+CONFIG_INET6_TUNNEL=Y
+CONFIG_FM_RADIO=Y
+CONFIG_IP6_NF_MANGLE=Y
+CONFIG_IPV6=Y
+CONFIG_CRYPTO_AEAD=Y
+CONFIG_NF_NAT_PROTO_GRE=Y
+CONFIG_CHARGER_MAX8997_U1=Y
+CONFIG_IP6_NF_TARGET_REJECT=Y
+CONFIG_IR_NEC_DECODER=Y
+CONFIG_SERIAL_SAMSUNG=Y
+CONFIG_XFRM_IPCOMP=Y
+CONFIG_CRYPTO_RNG2=Y
+CONFIG_NETFILTER_NETLINK_QUEUE=Y
+CONFIG_MSDOS_FS=Y
+CONFIG_TUN=Y
+CONFIG_CFG80211=Y
+CONFIG_DM_CRYPT=Y
+CONFIG_SERIAL_8250=Y
+CONFIG_HID_BELKIN=Y
+CONFIG_VIDEO_IR_I2C=Y
+CONFIG_USB=Y
+CONFIG_SWITCH_GPIO=Y
+CONFIG_CRYPTO_HMAC=Y
+CONFIG_CPU_FREQ_GOV_SMARTASS2=Y
+CONFIG_IP6_NF_TARGET_LOG=Y
+CONFIG_IP_NF_ARPTABLES=Y
+CONFIG_HID_CHERRY=Y
+CONFIG_HID_SUNPLUS=Y
+CONFIG_HID_PICOLCD=Y
+CONFIG_SND_SOC=Y
+CONFIG_HID_THRUSTMASTER=Y
+CONFIG_CRYPTO_AUTHENC=Y
+CONFIG_CRYPTO_DES=Y
+CONFIG_NLS_CODEPAGE_437=Y
+CONFIG_NET_CLS_U32=Y
+CONFIG_SERIO=Y
+CONFIG_NET_EMATCH_U32=Y
+CONFIG_EPEN_WACOM_G5SP=Y
+CONFIG_NF_CONNTRACK_SANE=Y
+CONFIG_NF_CT_PROTO_DCCP=Y
+CONFIG_ZLIB_INFLATE=Y
+CONFIG_CRYPTO_TWOFISH_COMMON=Y
+CONFIG_ANDROID_TIMED_GPIO=Y
+CONFIG_NETFILTER_XT_MATCH_STRING=Y
+CONFIG_IP_NF_TARGET_LOG=Y
+CONFIG_USB_STORAGE=Y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=Y
+CONFIG_IR_LIRC_CODEC=Y
+CONFIG_HID_APPLE=Y
+CONFIG_IP_NF_ARP_MANGLE=Y
+CONFIG_SND_SOC_MC1N2=Y
+CONFIG_BCM4330=Y
+CONFIG_NF_CONNTRACK_PPTP=Y
+CONFIG_NF_CONNTRACK_IRC=Y
+CONFIG_SWITCH=Y
+CONFIG_PPP_DEFLATE=Y
+CONFIG_TEXTSEARCH_KMP=Y
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=Y
+CONFIG_POWER_SUPPLY=Y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=Y
+CONFIG_NLS=Y
+CONFIG_HID_MAGICMOUSE=Y
+CONFIG_I2C_GPIO=Y
+CONFIG_USB_S3C_OTGD=Y
+CONFIG_INPUT_GPIO=Y
+CONFIG_SENSORS_GP2A_ANALOG=Y
+CONFIG_SPI_BITBANG=Y
+CONFIG_IP6_NF_IPTABLES=Y
+CONFIG_CPU_FREQ_GOV_LULZACTIVE=Y
+CONFIG_HID_CYPRESS=Y
+CONFIG_NLS_ISO8859_1=Y
+CONFIG_CRYPTO_WORKQUEUE=Y
+CONFIG_HID_KENSINGTON=Y
+CONFIG_USB_EHCI_HCD=Y
+CONFIG_CPU_FREQ_TABLE=Y
+CONFIG_TEXTSEARCH_BM=Y
+CONFIG_HID_ZYDACRON=Y
+CONFIG_PPP_MPPE=Y
+CONFIG_RFKILL=Y
+CONFIG_NET_KEY=Y
+CONFIG_IOSCHED_DEADLINE=Y
+CONFIG_IPV6_SIT=Y
+CONFIG_SND_SOC_SAMSUNG=Y
+CONFIG_IP_NF_TARGET_MASQUERADE=Y
+CONFIG_NF_CONNTRACK_BROADCAST=Y
+CONFIG_ECRYPT_FS=Y
+CONFIG_IR_RC5_SZ_DECODER=Y
+CONFIG_NF_NAT_PROTO_DCCP=Y
+CONFIG_BATTERY_SEC_U1=Y
+CONFIG_PHONET=Y
+CONFIG_SCSI_WAIT_SCAN=M
+CONFIG_FM_SI4709=M
+CONFIG_BACKLIGHT_CLASS_DEVICE=Y
+CONFIG_NF_DEFRAG_IPV4=Y
+CONFIG_CRYPTO_DEFLATE=Y
+CONFIG_VIDEO_M5MO=Y
+CONFIG_NETFILTER_NETLINK_LOG=Y
+CONFIG_NETFILTER_XT_MATCH_MARK=Y
+CONFIG_IP_NF_MANGLE=Y
+CONFIG_INET6_XFRM_MODE_TUNNEL=Y
+CONFIG_MEDIA_SUPPORT=Y
+CONFIG_IP_NF_FILTER=Y
+CONFIG_HID_ZEROPLUS=Y
+CONFIG_J4FS=M
+CONFIG_NETFILTER_XT_MATCH_LENGTH=Y
+CONFIG_FAT_FS=Y
+CONFIG_TEXTSEARCH_FSM=Y
+CONFIG_IP6_NF_RAW=Y
+CONFIG_INET_TUNNEL=Y
+CONFIG_IOSCHED_CFQ=Y
+CONFIG_MFD_CORE=Y
+CONFIG_RTC_DRV_S3C=Y
+CONFIG_NLS_ASCII=Y
+CONFIG_SENSORS_K3G=Y
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=Y
+CONFIG_VIDEOBUF2_MEMOPS=Y
+CONFIG_HID_ROCCAT=Y
+CONFIG_INET_XFRM_MODE_TRANSPORT=Y
+CONFIG_CRYPTO_MD5=Y
+CONFIG_INET6_AH=Y
+CONFIG_REGULATOR_FIXED_VOLTAGE=Y
+CONFIG_NETFILTER_XT_MARK=Y
+CONFIG_NETFILTER_XTABLES=Y
+CONFIG_HID_GREENASIA=Y
+CONFIG_HID_ROCCAT_COMMON=Y
+CONFIG_INPUT_WACOM=Y
+CONFIG_NET_ACT_GACT=Y
+CONFIG_HID_GYRATION=Y
+CONFIG_MUIC_MAX8997=Y
+CONFIG_NETFILTER_XT_TARGET_TPROXY=Y
+CONFIG_CRC16=Y
+CONFIG_SENSORS_BMP180=Y
+CONFIG_USB_HID=Y
+CONFIG_IOSCHED_SIO=Y
+CONFIG_NET_SCH_INGRESS=Y
+CONFIG_IOSCHED_ROW=Y
+CONFIG_CRYPTO_PCOMP2=Y
+CONFIG_KEYBOARD_GPIO=Y
+CONFIG_NF_CONNTRACK_FTP=Y
+CONFIG_IP_NF_MATCH_ECN=Y
+CONFIG_USB_GADGET=Y
+CONFIG_SOUND=Y
+CONFIG_SENSORS_K3DH=Y
+CONFIG_UNIX=Y
+CONFIG_CRYPTO_HASH2=Y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=Y
+CONFIG_INET_ESP=Y
+CONFIG_HID_QUANTA=Y
+CONFIG_NF_CONNTRACK_IPV6=Y
+CONFIG_CRYPTO_ALGAPI=Y
+CONFIG_MEDIA_TUNER=Y
+CONFIG_INPUT_UINPUT=Y
+CONFIG_KEYBOARD_ATKBD=Y
+CONFIG_NF_NAT=Y
+CONFIG_CRYPTO_HASH=Y
+CONFIG_CPU_FREQ_GOV_INTERACTIVE=Y
+CONFIG_VFAT_FS=Y
+CONFIG_SND_HWDEP=Y
+CONFIG_BLK_DEV_LOOP=Y
+CONFIG_NF_NAT_IRC=Y
+CONFIG_CRYPTO_CBC=Y
+CONFIG_NF_NAT_TFTP=Y
+CONFIG_CRYPTO_MANAGER2=Y
+CONFIG_I2C=Y
+CONFIG_BT_HIDP=Y
+CONFIG_CRYPTO_ECB=Y
+CONFIG_NF_CONNTRACK_AMANDA=Y
+CONFIG_FB_CFB_IMAGEBLIT=Y
+CONFIG_ZLIB_DEFLATE=Y
+CONFIG_FW_LOADER=Y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=Y
+CONFIG_REGULATOR_MAX8997=Y
+CONFIG_EXT4_FS=Y
+CONFIG_CRYPTO_SHA1=Y
+CONFIG_PPPOPNS=Y
+CONFIG_IP_NF_MATCH_TTL=Y
+CONFIG_NETFILTER_XT_TARGET_TRACE=Y
+CONFIG_SND_PCM=Y
+CONFIG_IR_SONY_DECODER=Y
+CONFIG_NETFILTER_XT_MATCH_COMMENT=Y
+CONFIG_INPUT_EVDEV=Y
+CONFIG_MOTOR_DRV_MAX8997=Y
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=Y
+CONFIG_EXT2_FS=Y
+CONFIG_HID_DRAGONRISE=Y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=Y
+CONFIG_PACKET=Y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=Y
+CONFIG_NF_CONNTRACK_TFTP=Y
+CONFIG_CRYPTO_TWOFISH=Y
+CONFIG_BT=Y
+CONFIG_HID_WACOM=Y
+CONFIG_NETFILTER_XT_MATCH_POLICY=Y
+CONFIG_CRYPTO_AES=Y
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=Y
+CONFIG_SERIO_SERPORT=Y
+CONFIG_LIRC=Y
+CONFIG_BT_BNEP=Y
+CONFIG_BATTERY_MAX17042_FUELGAUGE_U1=Y
+CONFIG_CPU_FREQ_STAT=Y
+CONFIG_INET6_ESP=Y
+CONFIG_I2C_S3C2410=Y
+CONFIG_IP6_NF_FILTER=Y
+CONFIG_SERIO_LIBPS2=Y
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=Y
+CONFIG_USB_PRINTER=Y
+CONFIG_FB_S5P=Y
+CONFIG_TOUCHSCREEN_ATMEL_MXT540E=Y
+CONFIG_MMC_MSHCI=Y
+CONFIG_NETFILTER_XT_MATCH_TIME=Y
+CONFIG_NETFILTER_XT_MATCH_MAC=Y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=Y
+CONFIG_LIBCRC32C=Y
+CONFIG_IOSCHED_VR=Y
+CONFIG_CRYPTO_SHA256=Y
+CONFIG_SND_SAMSUNG_I2S=Y
+CONFIG_INET_TCP_DIAG=Y
+CONFIG_HID_SONY=Y
+CONFIG_HID_MONTEREY=Y
+CONFIG_HID_EZKEY=Y
+CONFIG_CRYPTO=Y
+CONFIG_IP_NF_IPTABLES=Y
+CONFIG_SPI_GPIO=Y
+CONFIG_HID_SAMSUNG=Y
+CONFIG_SCSI_MOD=Y
+CONFIG_CPU_FREQ_GOV_LAGFREE=Y
+CONFIG_CRYPTO_CRC32C=Y
+CONFIG_SERIAL_CORE=Y
+CONFIG_FUSE_FS=Y
+CONFIG_HID_MICROSOFT=Y
+CONFIG_SMB328_CHARGER=Y
+CONFIG_NF_DEFRAG_IPV6=Y
+CONFIG_VIDEO_DEV=Y
+CONFIG_NF_CT_PROTO_SCTP=Y
+CONFIG_SCSI=Y
+CONFIG_FB_CFB_FILLRECT=Y
+CONFIG_NF_NAT_PPTP=Y
+CONFIG_HID_CHICONY=Y
+CONFIG_HID=Y
+CONFIG_SENSORS_AK8975C=Y
+CONFIG_USB_S3C_OTG_HOST=Y
+CONFIG_JBD2=Y
+CONFIG_INET6_IPCOMP=Y
+CONFIG_IPV6_TUNNEL=Y
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=Y
+CONFIG_IP_NF_RAW=Y
+CONFIG_IP_NF_ARPFILTER=Y
+CONFIG_NETFILTER_XT_MATCH_SOCKET=Y
+CONFIG_HID_TOPSEED=Y
+CONFIG_NF_NAT_H323=Y
+CONFIG_HID_A4TECH=Y
+CONFIG_IP_NF_TARGET_NETMAP=Y
+CONFIG_CHR_DEV_SG=Y
+CONFIG_CPU_FREQ_GOV_SMARTASS=Y
+CONFIG_VIDEO_S5K5BAFX=Y
+CONFIG_VIBETONZ=Y
+CONFIG_NF_NAT_AMANDA=Y
+CONFIG_INET6_XFRM_MODE_TRANSPORT=Y
+CONFIG_CRYPTO_ARC4=Y
+CONFIG_SLHC=Y
+CONFIG_CRYPTO_MANAGER=Y
+CONFIG_NET_SCH_HTB=Y
+CONFIG_PPP_BSDCOMP=Y
+CONFIG_HID_ORTEK=Y
+CONFIG_NETFILTER_XT_TARGET_MARK=Y
+CONFIG_I2C_ALGOBIT=Y
+CONFIG_MMC_BLOCK=Y
+CONFIG_SMB136_CHARGER_Q1=Y
+CONFIG_MMC=Y
+CONFIG_HID_LOGITECH=Y
+CONFIG_PPPOLAC=Y
+CONFIG_NETFILTER_XT_MATCH_U32=Y
+CONFIG_RTC_DRV_MAX8997=Y
+CONFIG_IPV6_MIP6=Y
+CONFIG_TCP_CONG_CUBIC=Y
+CONFIG_MMC_SDHCI=Y
+CONFIG_NETFILTER_XT_CONNMARK=Y
+CONFIG_HID_KYE=Y
+CONFIG_IP_NF_MATCH_AH=Y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=Y
+CONFIG_FB=Y
+CONFIG_BT_HCIUART=Y
+CONFIG_HID_PETALYNX=Y
+CONFIG_NET_ACT_MIRRED=Y
+CONFIG_NF_CONNTRACK_IPV4=Y
+CONFIG_INET6_XFRM_TUNNEL=Y
+CONFIG_MMC_SDHCI_S3C=Y
+CONFIG_VIDEO_MEDIA=Y
+CONFIG_INPUT_KEYCHORD=Y
+CONFIG_NF_NAT_PROTO_UDPLITE=Y
+CONFIG_ANDROID_LOGGER=M
+CONFIG_HW_RANDOM=Y
+CONFIG_SND_SOC_U1_MC1N2=Y
+CONFIG_VIDEOBUF2_CORE=Y
+CONFIG_NTFS_FS=Y
+CONFIG_CRYPTO_BLKCIPHER2=Y
+CONFIG_RC_MAP=Y
+CONFIG_HID_PANTHERLORD=Y
+CONFIG_SND=Y
+CONFIG_IR_RC6_DECODER=Y
+CONFIG_CIFS=Y
+CONFIG_PPP_ASYNC=Y
+CONFIG_NETFILTER_XT_MATCH_QUOTA2=Y
+CONFIG_HID_ELECOM=Y
+CONFIG_SND_TIMER=Y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=Y
+CONFIG_PPP=Y
+CONFIG_NETFILTER_XT_MATCH_QUOTA=Y
+CONFIG_INET_DIAG=Y
+CONFIG_NF_NAT_FTP=Y
+CONFIG_HID_ROCCAT_KONE=Y
+CONFIG_NF_CT_PROTO_UDPLITE=Y
+CONFIG_CPU_FREQ_GOV_PEGASUSQ=Y
+CONFIG_BLK_DEV_RAM=Y
+CONFIG_NETFILTER_XT_MATCH_STATE=Y
+CONFIG_IR_RC5_DECODER=Y
+CONFIG_INET6_XFRM_MODE_BEET=Y
+CONFIG_KEYBOARD_CYPRESS_TOUCH=Y
+CONFIG_FB_CFB_COPYAREA=Y
+CONFIG_VIDEO_V4L2=Y
+CONFIG_HID_NTRIG=Y
+CONFIG_DECOMPRESS_GZIP=Y
+CONFIG_I2C_CHARDEV=Y
+CONFIG_NLS_UTF8=Y
+CONFIG_NETFILTER_TPROXY=Y
+CONFIG_NET_ACT_POLICE=Y
+CONFIG_HID_SMARTJOYPLUS=Y
+CONFIG_CRC_CCITT=Y
+CONFIG_BLK_DEV_SD=Y
+CONFIG_NETFILTER_NETLINK=Y
+CONFIG_BITREVERSE=Y
+CONFIG_VIDEO_V4L2_COMMON=Y
+CONFIG_CRYPTO_BLKCIPHER=Y
+CONFIG_NF_CONNTRACK=Y
+CONFIG_LCD_CLASS_DEVICE=Y
+CONFIG_SND_SOC_I2C_AND_SPI=Y
+CONFIG_IP_NF_TARGET_REJECT=Y
+CONFIG_NF_CT_PROTO_GRE=Y
+CONFIG_NF_CT_NETLINK=Y
+CONFIG_CRYPTO_AEAD2=Y
+CONFIG_NETFILTER_XT_MATCH_HL=Y
+CONFIG_CRYPTO_ALGAPI2=Y
+CONFIG_INPUT=Y
diff -urNp Kernel/include/generated/asm-offsets.h HelloWorld-Renew-v1.0-n7000-jb/include/generated/asm-offsets.h
--- Kernel/include/generated/asm-offsets.h	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/include/generated/asm-offsets.h	2013-05-02 00:10:52.143407645 +0200
@@ -0,0 +1,71 @@
+#ifndef __ASM_OFFSETS_H__
+#define __ASM_OFFSETS_H__
+/*
+ * DO NOT MODIFY.
+ *
+ * This file was generated by Kbuild
+ *
+ */
+
+#define TSK_ACTIVE_MM 244 /* offsetof(struct task_struct, active_mm)	@ */
+
+#define TI_FLAGS 0 /* offsetof(struct thread_info, flags)	@ */
+#define TI_PREEMPT 4 /* offsetof(struct thread_info, preempt_count)	@ */
+#define TI_ADDR_LIMIT 8 /* offsetof(struct thread_info, addr_limit)	@ */
+#define TI_TASK 12 /* offsetof(struct thread_info, task)	@ */
+#define TI_EXEC_DOMAIN 16 /* offsetof(struct thread_info, exec_domain)	@ */
+#define TI_CPU 20 /* offsetof(struct thread_info, cpu)	@ */
+#define TI_CPU_DOMAIN 24 /* offsetof(struct thread_info, cpu_domain)	@ */
+#define TI_CPU_SAVE 28 /* offsetof(struct thread_info, cpu_context)	@ */
+#define TI_USED_CP 80 /* offsetof(struct thread_info, used_cp)	@ */
+#define TI_TP_VALUE 96 /* offsetof(struct thread_info, tp_value)	@ */
+#define TI_FPSTATE 288 /* offsetof(struct thread_info, fpstate)	@ */
+#define TI_VFPSTATE 432 /* offsetof(struct thread_info, vfpstate)	@ */
+
+#define S_R0 0 /* offsetof(struct pt_regs, ARM_r0)	@ */
+#define S_R1 4 /* offsetof(struct pt_regs, ARM_r1)	@ */
+#define S_R2 8 /* offsetof(struct pt_regs, ARM_r2)	@ */
+#define S_R3 12 /* offsetof(struct pt_regs, ARM_r3)	@ */
+#define S_R4 16 /* offsetof(struct pt_regs, ARM_r4)	@ */
+#define S_R5 20 /* offsetof(struct pt_regs, ARM_r5)	@ */
+#define S_R6 24 /* offsetof(struct pt_regs, ARM_r6)	@ */
+#define S_R7 28 /* offsetof(struct pt_regs, ARM_r7)	@ */
+#define S_R8 32 /* offsetof(struct pt_regs, ARM_r8)	@ */
+#define S_R9 36 /* offsetof(struct pt_regs, ARM_r9)	@ */
+#define S_R10 40 /* offsetof(struct pt_regs, ARM_r10)	@ */
+#define S_FP 44 /* offsetof(struct pt_regs, ARM_fp)	@ */
+#define S_IP 48 /* offsetof(struct pt_regs, ARM_ip)	@ */
+#define S_SP 52 /* offsetof(struct pt_regs, ARM_sp)	@ */
+#define S_LR 56 /* offsetof(struct pt_regs, ARM_lr)	@ */
+#define S_PC 60 /* offsetof(struct pt_regs, ARM_pc)	@ */
+#define S_PSR 64 /* offsetof(struct pt_regs, ARM_cpsr)	@ */
+#define S_OLD_R0 68 /* offsetof(struct pt_regs, ARM_ORIG_r0)	@ */
+#define S_FRAME_SIZE 72 /* sizeof(struct pt_regs)	@ */
+
+#define MM_CONTEXT_ID 352 /* offsetof(struct mm_struct, context.id)	@ */
+
+#define VMA_VM_MM 0 /* offsetof(struct vm_area_struct, vm_mm)	@ */
+#define VMA_VM_FLAGS 24 /* offsetof(struct vm_area_struct, vm_flags)	@ */
+
+#define VM_EXEC 4 /* VM_EXEC	@ */
+
+#define PAGE_SZ 4096 /* PAGE_SIZE	@ */
+
+#define SYS_ERROR0 10420224 /* 0x9f0000	@ */
+
+#define SIZEOF_MACHINE_DESC 60 /* sizeof(struct machine_desc)	@ */
+#define MACHINFO_TYPE 0 /* offsetof(struct machine_desc, nr)	@ */
+#define MACHINFO_NAME 4 /* offsetof(struct machine_desc, name)	@ */
+
+#define PROC_INFO_SZ 52 /* sizeof(struct proc_info_list)	@ */
+#define PROCINFO_INITFUNC 16 /* offsetof(struct proc_info_list, __cpu_flush)	@ */
+#define PROCINFO_MM_MMUFLAGS 8 /* offsetof(struct proc_info_list, __cpu_mm_mmu_flags)	@ */
+#define PROCINFO_IO_MMUFLAGS 12 /* offsetof(struct proc_info_list, __cpu_io_mmu_flags)	@ */
+
+#define CACHE_FLUSH_KERN_ALL 4 /* offsetof(struct cpu_cache_fns, flush_kern_all)	@ */
+
+#define DMA_BIDIRECTIONAL 0 /* DMA_BIDIRECTIONAL	@ */
+#define DMA_TO_DEVICE 1 /* DMA_TO_DEVICE	@ */
+#define DMA_FROM_DEVICE 2 /* DMA_FROM_DEVICE	@ */
+
+#endif
diff -urNp Kernel/include/generated/autoconf.h HelloWorld-Renew-v1.0-n7000-jb/include/generated/autoconf.h
--- Kernel/include/generated/autoconf.h	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/include/generated/autoconf.h	2013-05-01 12:14:22.501107096 +0200
@@ -0,0 +1,984 @@
+/*
+ * Automatically generated C config: don't edit
+ * Linux/arm 3.0.31-1103517 Kernel Configuration
+ */
+#define CONFIG_NF_CONNTRACK_H323 1
+#define CONFIG_EXYNOS4_SETUP_I2C5 1
+#define CONFIG_SCSI_DMA 1
+#define CONFIG_KERNEL_GZIP 1
+#define CONFIG_BROADCOM_WIFI_RESERVED_MEM 1
+#define CONFIG_INPUT_KEYBOARD 1
+#define CONFIG_RFS_ACCEL 1
+#define CONFIG_IP_NF_TARGET_REDIRECT 1
+#define CONFIG_VIDEO_SAMSUNG_MEMSIZE_TVOUT 16384
+#define CONFIG_CRC32 1
+#define CONFIG_I2C_BOARDINFO 1
+#define CONFIG_NF_NAT_PROTO_SCTP 1
+#define CONFIG_HAVE_AOUT 1
+#define CONFIG_VFP 1
+#define CONFIG_IR_JVC_DECODER 1
+#define CONFIG_AEABI 1
+#define CONFIG_CPU_FREQ_GOV_CONSERVATIVE 1
+#define CONFIG_HIGH_RES_TIMERS 1
+#define CONFIG_BLK_DEV_DM 1
+#define CONFIG_IP_MULTIPLE_TABLES 1
+#define CONFIG_FLATMEM_MANUAL 1
+#define CONFIG_FB_S5P_S6E8AA0 1
+#define CONFIG_SAMSUNG_MFC_DRIVERS 1
+#define CONFIG_BT_RFCOMM 1
+#define CONFIG_USB_S5P_HSIC1 1
+#define CONFIG_CPU_FREQ_DEFAULT_GOV_PEGASUSQ 1
+#define CONFIG_INOTIFY_USER 1
+#define CONFIG_EXYNOS4_SETUP_FIMD0 1
+#define CONFIG_NF_CONNTRACK_NETBIOS_NS 1
+#define CONFIG_NETWORK_FILESYSTEMS 1
+#define CONFIG_MODULE_FORCE_UNLOAD 1
+#define CONFIG_CRYPTO_MD4 1
+#define CONFIG_SERIAL_S5PV210 1
+#define CONFIG_CPU_FREQ_GOV_ONDEMAND 1
+#define CONFIG_EXYNOS4_SETUP_CSIS 1
+#define CONFIG_EXPERIMENTAL 1
+#define CONFIG_ANDROID_PMEM_MEMSIZE_PMEM 4096
+#define CONFIG_ARCH_SUSPEND_POSSIBLE 1
+#define CONFIG_RC_CORE 1
+#define CONFIG_PM_WATCHDOG_TIMEOUT 1
+#define CONFIG_BINFMT_MISC 1
+#define CONFIG_SEC_THERMISTOR 1
+#define CONFIG_NETFILTER_XT_MATCH_HELPER 1
+#define CONFIG_SSB_POSSIBLE 1
+#define CONFIG_S3C_ADC 1
+#define CONFIG_NETFILTER_XT_MATCH_STATISTIC 1
+#define CONFIG_CPU_FREQ_GOV_HYPER 1
+#define CONFIG_NET_SCH_FIFO 1
+#define CONFIG_FSNOTIFY 1
+#define CONFIG_LEDS_MAX8997 1
+#define CONFIG_INET6_TUNNEL 1
+#define CONFIG_FM_RADIO 1
+#define CONFIG_EXYNOS4_SETUP_FIMC3 1
+#define CONFIG_USB_SUSPEND 1
+#define CONFIG_BT_MGMT 1
+#define CONFIG_HAVE_KERNEL_LZMA 1
+#define CONFIG_DEFAULT_SECURITY_DAC 1
+#define CONFIG_FIB_RULES 1
+#define CONFIG_RT_GROUP_SCHED 1
+#define CONFIG_KTIME_SCALAR 1
+#define CONFIG_IP6_NF_MANGLE 1
+#define CONFIG_SENSORS_CORE 1
+#define CONFIG_IPV6 1
+#define CONFIG_CRYPTO_AEAD 1
+#define CONFIG_DEFAULT_TCP_CONG "cubic"
+#define CONFIG_UEVENT_HELPER_PATH "/sbin/hotplug"
+#define CONFIG_USB_DEVICEFS 1
+#define CONFIG_FB_BGRA_ORDER 1
+#define CONFIG_NF_NAT_PROTO_GRE 1
+#define CONFIG_ANDROID_BINDER_IPC 1
+#define CONFIG_CHARGER_MAX8997_U1 1
+#define CONFIG_IP6_NF_TARGET_REJECT 1
+#define CONFIG_S3C_GPIO_CFG_S3C24XX 1
+#define CONFIG_IR_NEC_DECODER 1
+#define CONFIG_HOTPLUG_CPU 1
+#define CONFIG_WLAN 1
+#define CONFIG_SAMSUNG_MHL 1
+#define CONFIG_DEFAULT_MESSAGE_LOGLEVEL 4
+#define CONFIG_EXYNOS4_LOWPWR_IDLE 1
+#define CONFIG_ARM_PLD_SIZE 32
+#define CONFIG_S3C_DEV_RTC 1
+#define CONFIG_VIDEO_MFC5X 1
+#define CONFIG_HAVE_ARM_SCU 1
+#define CONFIG_NETFILTER_XT_MATCH_QUOTA2_LOG 1
+#define CONFIG_SERIAL_SAMSUNG 1
+#define CONFIG_J4FS_PAGE_SHIFT 11
+#define CONFIG_XFRM_IPCOMP 1
+#define CONFIG_CRYPTO_RNG2 1
+#define CONFIG_NETFILTER_NETLINK_QUEUE 1
+#define CONFIG_MSDOS_FS 1
+#define CONFIG_TUN 1
+#define CONFIG_CFG80211 1
+#define CONFIG_TREE_PREEMPT_RCU 1
+#define CONFIG_BT_BCM4330 1
+#define CONFIG_DM_CRYPT 1
+#define CONFIG_SERIAL_8250 1
+#define CONFIG_HAVE_PROC_CPU 1
+#define CONFIG_IOMMU_SUPPORT 1
+#define CONFIG_HID_BELKIN 1
+#define CONFIG_VIDEO_IR_I2C 1
+#define CONFIG_EXYNOS4_SETUP_I2C6 1
+#define CONFIG_WIRELESS_EXT_SYSFS 1
+#define CONFIG_USB 1
+#define CONFIG_SWITCH_GPIO 1
+#define CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMD 32000
+#define CONFIG_CRYPTO_HMAC 1
+#define CONFIG_USB_DUN_SUPPORT 1
+#define CONFIG_CPU_FREQ_GOV_SMARTASS2 1
+#define CONFIG_VIDEO_FIMC_MIPI 1
+#define CONFIG_HDMI_HPD 1
+#define CONFIG_BRANCH_PROFILE_NONE 1
+#define CONFIG_HAVE_DMA_CONTIGUOUS 1
+#define CONFIG_IP6_NF_TARGET_LOG 1
+#define CONFIG_IP_NF_ARPTABLES 1
+#define CONFIG_ARM_ERRATA_751472 1
+#define CONFIG_HID_CHERRY 1
+#define CONFIG_S3C_ADDR_BASE 0xFB000000
+#define CONFIG_EXYNOS4_MSHC_8BIT 1
+#define CONFIG_HID_SUNPLUS 1
+#define CONFIG_HID_PICOLCD 1
+#define CONFIG_BCMA_POSSIBLE 1
+#define CONFIG_FORCE_MAX_ZONEORDER 11
+#define CONFIG_S3C_DEV_I2C8_EMUL 1
+#define CONFIG_SND_SOC 1
+#define CONFIG_SYNC 1
+#define CONFIG_MALI_UMP_R2P4_LSI 1
+#define CONFIG_EXYNOS4_MSHC_DDR 1
+#define CONFIG_NF_CONNTRACK_PROC_COMPAT 1
+#define CONFIG_WIFI_CONTROL_FUNC 1
+#define CONFIG_TIMERFD 1
+#define CONFIG_HID_THRUSTMASTER 1
+#define CONFIG_CRYPTO_AUTHENC 1
+#define CONFIG_NET_EMATCH_STACK 32
+#define CONFIG_BOUNCE 1
+#define CONFIG_SHMEM 1
+#define CONFIG_MIGRATION 1
+#define CONFIG_MMC_BLOCK_MINORS 8
+#define CONFIG_EXYNOS4_SETUP_SDHCI 1
+#define CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE 1
+#define CONFIG_CRYPTO_DES 1
+#define CONFIG_ENABLE_MUST_CHECK 1
+#define CONFIG_S5P_DEV_TVOUT 1
+#define CONFIG_NLS_CODEPAGE_437 1
+#define CONFIG_NET_CLS_U32 1
+#define CONFIG_SEC_DEV_JACK 1
+#define CONFIG_ARM_GIC 1
+#define CONFIG_SERIO 1
+#define CONFIG_RTC_INTF_SYSFS 1
+#define CONFIG_NET_EMATCH_U32 1
+#define CONFIG_BLK_DEV_INITRD 1
+#define CONFIG_EPEN_WACOM_G5SP 1
+#define CONFIG_NF_CONNTRACK_SANE 1
+#define CONFIG_ANDROID_PMEM_MEMSIZE_PMEM_CAM 0
+#define CONFIG_NF_CT_PROTO_DCCP 1
+#define CONFIG_ZLIB_INFLATE 1
+#define CONFIG_USB_G_ANDROID 1
+#define CONFIG_ARM_ERRATA_764369 1
+#define CONFIG_CRYPTO_TWOFISH_COMMON 1
+#define CONFIG_RTC_INTF_PROC 1
+#define CONFIG_EXYNOS_DEV_PD 1
+#define CONFIG_CMA_SIZE_SEL_MBYTES 1
+#define CONFIG_S3C_DEV_HSMMC2 1
+#define CONFIG_CPU_IDLE_GOV_MENU 1
+#define CONFIG_STACKTRACE_SUPPORT 1
+#define CONFIG_USB_DEVICE_CLASS 1
+#define CONFIG_ANDROID_TIMED_GPIO 1
+#define CONFIG_ARM 1
+#define CONFIG_ARM_L1_CACHE_SHIFT 5
+#define CONFIG_BT_RFCOMM_TTY 1
+#define CONFIG_S5P_MEM_CMA 1
+#define CONFIG_CRYPTO_MANAGER_TESTS 1
+#define CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMC3 7168
+#define CONFIG_NETFILTER_XT_MATCH_STRING 1
+#define CONFIG_ARM_CPU_TOPOLOGY 1
+#define CONFIG_IP_NF_TARGET_LOG 1
+#define CONFIG_LTO 1
+#define CONFIG_HAS_WAKELOCK 1
+#define CONFIG_HDMI_SWITCH_HPD 1
+#define CONFIG_S3C_PL330_DMA 1
+#define CONFIG_USB_STORAGE 1
+#define CONFIG_EXYNOS4_SETUP_I2C3 1
+#define CONFIG_STANDALONE 1
+#define CONFIG_SCHED_MC 1
+#define CONFIG_CPU_FREQ_GOV_PERFORMANCE 1
+#define CONFIG_IR_LIRC_CODEC 1
+#define CONFIG_MMC_EMBEDDED_SDIO 1
+#define CONFIG_ARCH_HAS_CPUFREQ 1
+#define CONFIG_ASHMEM 1
+#define CONFIG_BLOCK 1
+#define CONFIG_HAVE_IDE 1
+#define CONFIG_HID_APPLE 1
+#define CONFIG_INIT_ENV_ARG_LIMIT 32
+#define CONFIG_IP_NF_ARP_MANGLE 1
+#define CONFIG_SND_SOC_MC1N2 1
+#define CONFIG_GENERIC_GPIO 1
+#define CONFIG_BCM4330 1
+#define CONFIG_NF_CONNTRACK_PPTP 1
+#define CONFIG_TMPFS_POSIX_ACL 1
+#define CONFIG_BUG 1
+#define CONFIG_PM 1
+#define CONFIG_SPI 1
+#define CONFIG_NF_CONNTRACK_IRC 1
+#define CONFIG_SWITCH 1
+#define CONFIG_SAMSUNG_PRODUCT_SHIP 1
+#define CONFIG_DEVKMEM 1
+#define CONFIG_PPP_DEFLATE 1
+#define CONFIG_NTFS_RW 1
+#define CONFIG_TEXTSEARCH_KMP 1
+#define CONFIG_VT 1
+#define CONFIG_USE_LEGACY_MFC 1
+#define CONFIG_NETFILTER_XT_TARGET_CLASSIFY 1
+#define CONFIG_SPLIT_PTLOCK_CPUS 4
+#define CONFIG_EXYNOS_MEM 1
+#define CONFIG_BT_SCO 1
+#define CONFIG_POWER_SUPPLY 1
+#define CONFIG_CPU_CACHE_VIPT 1
+#define CONFIG_NETFILTER_XT_TARGET_NFQUEUE 1
+#define CONFIG_V4L_USB_DRIVERS 1
+#define CONFIG_WEXT_CORE 1
+#define CONFIG_GENERIC_IRQ_CHIP 1
+#define CONFIG_NLS 1
+#define CONFIG_S3C_MEM 1
+#define CONFIG_HID_MAGICMOUSE 1
+#define CONFIG_S3C_DEV_I2C14_EMUL 1
+#define CONFIG_I2C_GPIO 1
+#define CONFIG_MFD_SUPPORT 1
+#define CONFIG_USB_S3C_OTGD 1
+#define CONFIG_VIDEO_FIMG2D 1
+#define CONFIG_IP_ADVANCED_ROUTER 1
+#define CONFIG_ENABLE_WARN_DEPRECATED 1
+#define CONFIG_INPUT_GPIO 1
+#define CONFIG_SENSORS_GP2A_ANALOG 1
+#define CONFIG_SPI_BITBANG 1
+#define CONFIG_USE_TVOUT_CMA 1
+#define CONFIG_IP6_NF_IPTABLES 1
+#define CONFIG_CPU_FREQ_GOV_LULZACTIVE 1
+#define CONFIG_ARCH_SKIP_SECONDARY_CALIBRATE 1
+#define CONFIG_HID_CYPRESS 1
+#define CONFIG_ACCESSORY 1
+#define CONFIG_NLS_ISO8859_1 1
+#define CONFIG_CRYPTO_WORKQUEUE 1
+#define CONFIG_HID_KENSINGTON 1
+#define CONFIG_USB_EHCI_HCD 1
+#define CONFIG_CPU_FREQ_TABLE 1
+#define CONFIG_BCMDHD_FW_PATH "/system/etc/firmware/fw_bcmdhd.bin"
+#define CONFIG_TEXTSEARCH_BM 1
+#define CONFIG_HID_ZYDACRON 1
+#define CONFIG_PPP_MPPE 1
+#define CONFIG_S5P_DEV_MFC 1
+#define CONFIG_RFKILL 1
+#define CONFIG_NETDEVICES 1
+#define CONFIG_NET_KEY 1
+#define CONFIG_IOSCHED_DEADLINE 1
+#define CONFIG_S3C_DEV_I2C5 1
+#define CONFIG_INITRAMFS_ROOT_GID 0
+#define CONFIG_CGROUP_FREEZER 1
+#define CONFIG_CPU_TLB_V7 1
+#define CONFIG_EVENTFD 1
+#define CONFIG_SAMSUNG_DEV_ADC 1
+#define CONFIG_FS_POSIX_ACL 1
+#define CONFIG_IPV6_SIT 1
+#define CONFIG_SND_SOC_SAMSUNG 1
+#define CONFIG_XFRM 1
+#define CONFIG_DEFCONFIG_LIST "/lib/modules/$UNAME_RELEASE/.config"
+#define CONFIG_HAVE_S3C_RTC 1
+#define CONFIG_J4FS_USE_MOVI 1
+#define CONFIG_IPV6_MULTIPLE_TABLES 1
+#define CONFIG_USB_ANNOUNCE_NEW_DEVICES 1
+#define CONFIG_IP_NF_TARGET_MASQUERADE 1
+#define CONFIG_NF_CONNTRACK_BROADCAST 1
+#define CONFIG_ECRYPT_FS 1
+#define CONFIG_IR_RC5_SZ_DECODER 1
+#define CONFIG_PROC_PAGE_MONITOR 1
+#define CONFIG_EXYNOS4_SETUP_MSHCI 1
+#define CONFIG_SND_SOC_SAMSUNG_I2S_SEC 1
+#define CONFIG_NF_NAT_PROTO_DCCP 1
+#define CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV 1
+#define CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMC0 12288
+#define CONFIG_IOMMU_EXYNOS4_API 1
+#define CONFIG_ANDROID_LOW_MEMORY_KILLER 1
+#define CONFIG_VIDEOBUF2_CMA_PHYS 1
+#define CONFIG_ARCH_HAS_CPU_IDLE_WAIT 1
+#define CONFIG_BATTERY_SEC_U1 1
+#define CONFIG_PHONET 1
+#define CONFIG_SCSI_WAIT_SCAN_MODULE 1
+#define CONFIG_FM_SI4709_MODULE 1
+#define CONFIG_BACKLIGHT_CLASS_DEVICE 1
+#define CONFIG_NF_DEFRAG_IPV4 1
+#define CONFIG_SELECT_MEMORY_MODEL 1
+#define CONFIG_EXYNOS4_SETUP_MIPI_DSI 1
+#define CONFIG_MMC_UNSAFE_RESUME 1
+#define CONFIG_HAVE_ARCH_PFN_VALID 1
+#define CONFIG_CPU_COPY_V6 1
+#define CONFIG_NETFILTER_ADVANCED 1
+#define CONFIG_CRYPTO_DEFLATE 1
+#define CONFIG_IPV6_ROUTER_PREF 1
+#define CONFIG_VIDEO_FIMC 1
+#define CONFIG_VIDEO_M5MO 1
+#define CONFIG_NETFILTER_NETLINK_LOG 1
+#define CONFIG_HAVE_DYNAMIC_FTRACE 1
+#define CONFIG_MAGIC_SYSRQ 1
+#define CONFIG_NETFILTER_XT_MATCH_MARK 1
+#define CONFIG_IP_NF_MANGLE 1
+#define CONFIG_EXYNOS4_SETUP_FB_S5P 1
+#define CONFIG_INET6_XFRM_MODE_TUNNEL 1
+#define CONFIG_MEDIA_SUPPORT 1
+#define CONFIG_DEBUG_BUGVERBOSE 1
+#define CONFIG_IP_NF_FILTER 1
+#define CONFIG_HID_ZEROPLUS 1
+#define CONFIG_J4FS_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_LENGTH 1
+#define CONFIG_FAT_FS 1
+#define CONFIG_TEXTSEARCH_FSM 1
+#define CONFIG_TARGET_LOCALE_EUR 1
+#define CONFIG_HIGHMEM 1
+#define CONFIG_IP6_NF_RAW 1
+#define CONFIG_EXYNOS4_SETUP_TVOUT 1
+#define CONFIG_INET_TUNNEL 1
+#define CONFIG_FB_S5P_NR_BUFFERS 2
+#define CONFIG_MMC_BLOCK_BOUNCE 1
+#define CONFIG_GENERIC_CLOCKEVENTS 1
+#define CONFIG_IOSCHED_CFQ 1
+#define CONFIG_MFD_CORE 1
+#define CONFIG_RTC_DRV_S3C 1
+#define CONFIG_CPU_CP15_MMU 1
+#define CONFIG_CONSOLE_TRANSLATIONS 1
+#define CONFIG_STOP_MACHINE 1
+#define CONFIG_CPU_FREQ 1
+#define CONFIG_BUSFREQ_QOS_1280X800 1
+#define CONFIG_DUMMY_CONSOLE 1
+#define CONFIG_LINK_DEVICE_HSIC 1
+#define CONFIG_MODULE_FORCE_LOAD 1
+#define CONFIG_NLS_ASCII 1
+#define CONFIG_TRACE_IRQFLAGS_SUPPORT 1
+#define CONFIG_SENSORS_K3G 1
+#define CONFIG_NETFILTER_XT_MATCH_CONNMARK 1
+#define CONFIG_SND_USB 1
+#define CONFIG_VIDEOBUF2_MEMOPS 1
+#define CONFIG_RD_GZIP 1
+#define CONFIG_HAVE_REGS_AND_STACK_ACCESS_API 1
+#define CONFIG_EXYNOS4210_1400MHZ_SUPPORT 1
+#define CONFIG_LBDAF 1
+#define CONFIG_HID_ROCCAT 1
+#define CONFIG_INET_XFRM_MODE_TRANSPORT 1
+#define CONFIG_CRYPTO_MD5 1
+#define CONFIG_DEBUG_USER 1
+#define CONFIG_HAVE_GENERIC_HARDIRQS 1
+#define CONFIG_BINFMT_ELF 1
+#define CONFIG_SCSI_PROC_FS 1
+#define CONFIG_HOTPLUG 1
+#define CONFIG_INET6_AH 1
+#define CONFIG_CPU_CP15 1
+#define CONFIG_S3C24XX_PWM 1
+#define CONFIG_REGULATOR_FIXED_VOLTAGE 1
+#define CONFIG_KEYS 1
+#define CONFIG_NETFILTER_XT_MARK 1
+#define CONFIG_NETFILTER_XTABLES 1
+#define CONFIG_RESOURCE_COUNTERS 1
+#define CONFIG_KEYS_DEBUG_PROC_KEYS 1
+#define CONFIG_EXYNOS4_SETUP_FIMC2 1
+#define CONFIG_J4FS_DEVNAME "/dev/block/mmcblk0p4"
+#define CONFIG_EXYNOS4_SETUP_MFC 1
+#define CONFIG_PM_SLEEP_SMP 1
+#define CONFIG_CRYPTO_HW 1
+#define CONFIG_VIDEO_SAMSUNG_MEMSIZE_JPEG 20480
+#define CONFIG_HID_GREENASIA 1
+#define CONFIG_S3C_DEV_I2C9_EMUL 1
+#define CONFIG_HARDIRQS_SW_RESEND 1
+#define CONFIG_SPI_MASTER 1
+#define CONFIG_HID_ROCCAT_COMMON 1
+#define CONFIG_INPUT_WACOM 1
+#define CONFIG_NET_ACT_GACT 1
+#define CONFIG_HID_GYRATION 1
+#define CONFIG_MUIC_MAX8997 1
+#define CONFIG_NETFILTER_XT_TARGET_TPROXY 1
+#define CONFIG_EARLYSUSPEND 1
+#define CONFIG_USB_HOST_NOTIFY 1
+#define CONFIG_CRC16 1
+#define CONFIG_GENERIC_CALIBRATE_DELAY 1
+#define CONFIG_NET_CLS 1
+#define CONFIG_CPU_HAS_PMU 1
+#define CONFIG_ARCH_REQUIRE_GPIOLIB 1
+#define CONFIG_TMPFS 1
+#define CONFIG_ANON_INODES 1
+#define CONFIG_FUTEX 1
+#define CONFIG_SENSORS_BMP180 1
+#define CONFIG_VIDEO_IMPROVE_STREAMOFF 1
+#define CONFIG_VMSPLIT_3G 1
+#define CONFIG_RTC_HCTOSYS 1
+#define CONFIG_SERIAL_CORE_CONSOLE 1
+#define CONFIG_USB_HID 1
+#define CONFIG_IOSCHED_SIO 1
+#define CONFIG_ANDROID 1
+#define CONFIG_NET_SCH_INGRESS 1
+#define CONFIG_NF_CONNTRACK_EVENTS 1
+#define CONFIG_IPV6_NDISC_NODETYPE 1
+#define CONFIG_IOSCHED_ROW 1
+#define CONFIG_CGROUP_SCHED 1
+#define CONFIG_SYSVIPC 1
+#define CONFIG_CRYPTO_PCOMP2 1
+#define CONFIG_KEYBOARD_GPIO 1
+#define CONFIG_NF_CONNTRACK_FTP 1
+#define CONFIG_EXYNOS4_SETUP_I2C7 1
+#define CONFIG_MODULES 1
+#define CONFIG_IP_NF_MATCH_ECN 1
+#define CONFIG_CPU_HAS_ASID 1
+#define CONFIG_USB_GADGET 1
+#define CONFIG_SOUND 1
+#define CONFIG_SENSORS_K3DH 1
+#define CONFIG_S3C_BOOT_UART_FORCE_FIFO 1
+#define CONFIG_ARCH_HIBERNATION_POSSIBLE 1
+#define CONFIG_UNIX 1
+#define CONFIG_HAVE_CLK 1
+#define CONFIG_CRYPTO_HASH2 1
+#define CONFIG_DEFAULT_HOSTNAME "(none)"
+#define CONFIG_CPU_FREQ_GOV_POWERSAVE 1
+#define CONFIG_ARM_ERRATA_743622 1
+#define CONFIG_ARCH_EXYNOS4 1
+#define CONFIG_XPS 1
+#define CONFIG_S6E8AA0_AMS529HA01 1
+#define CONFIG_INET_ESP 1
+#define CONFIG_HID_QUANTA 1
+#define CONFIG_NF_CONNTRACK_IPV6 1
+#define CONFIG_MD 1
+#define CONFIG_CRYPTO_ALGAPI 1
+#define CONFIG_GPIO_PLAT_SAMSUNG 1
+#define CONFIG_EXYNOS4_CPUFREQ 1
+#define CONFIG_VIDEO_SAMSUNG_MEMSIZE_MFC1 28672
+#define CONFIG_MEDIA_TUNER 1
+#define CONFIG_MISC_DEVICES 1
+#define CONFIG_SAMSUNG_DEV_TS1 1
+#define CONFIG_INPUT_UINPUT 1
+#define CONFIG_PM_OPP 1
+#define CONFIG_KEYBOARD_ATKBD 1
+#define CONFIG_NF_NAT 1
+#define CONFIG_CPU_IDLE 1
+#define CONFIG_S3C_DEV_I2C16_EMUL 1
+#define CONFIG_REGULATOR 1
+#define CONFIG_FAIR_GROUP_SCHED 1
+#define CONFIG_CRYPTO_HASH 1
+#define CONFIG_EFI_PARTITION 1
+#define CONFIG_S3C_DEV_ADC 1
+#define CONFIG_CSI_C 1
+#define CONFIG_S5P_DEV_FIMD0 1
+#define CONFIG_LOG_BUF_SHIFT 18
+#define CONFIG_PANEL_U1 1
+#define CONFIG_EXTRA_FIRMWARE ""
+#define CONFIG_CACHE_L2X0 1
+#define CONFIG_CPU_FREQ_GOV_INTERACTIVE 1
+#define CONFIG_VIRT_TO_BUS 1
+#define CONFIG_VFAT_FS 1
+#define CONFIG_S3C_GPIO_CFG_S3C64XX 1
+#define CONFIG_S5P_DEV_USB_EHCI 1
+#define CONFIG_CPU_RMAP 1
+#define CONFIG_SND_HWDEP 1
+#define CONFIG_BLK_DEV_LOOP 1
+#define CONFIG_WAKELOCK 1
+#define CONFIG_NF_NAT_IRC 1
+#define CONFIG_MEDIA_TUNER_CUSTOMISE 1
+#define CONFIG_USB_EHCI_S5P 1
+#define CONFIG_PLAT_SAMSUNG 1
+#define CONFIG_INPUT_MISC 1
+#define CONFIG_CPU_PABRT_V7 1
+#define CONFIG_SUSPEND 1
+#define CONFIG_CRYPTO_CBC 1
+#define CONFIG_SERIAL_8250_RUNTIME_UARTS 4
+#define CONFIG_BUSFREQ_L2_160M 1
+#define CONFIG_EXYNOS4_SETUP_MSHCI_GPIO 1
+#define CONFIG_RTC_CLASS 1
+#define CONFIG_HAVE_LATENCYTOP_SUPPORT 1
+#define CONFIG_TMPFS_XATTR 1
+#define CONFIG_S3C_DEV_I2C11_EMUL 1
+#define CONFIG_BCMDHD_NVRAM_PATH "/system/etc/wifi/bcmdhd.cal"
+#define CONFIG_INITRAMFS_ROOT_UID 0
+#define CONFIG_UMP_MEM_SIZE 1024
+#define CONFIG_HAVE_FUNCTION_TRACER 1
+#define CONFIG_NF_NAT_TFTP 1
+#define CONFIG_OUTER_CACHE 1
+#define CONFIG_SERIAL_SAMSUNG_UARTS_4 1
+#define CONFIG_NO_IOPORT 1
+#define CONFIG_CPU_CACHE_V7 1
+#define CONFIG_CRYPTO_MANAGER2 1
+#define CONFIG_USB_GADGET_VBUS_DRAW 2
+#define CONFIG_SLUB 1
+#define CONFIG_S3C_DEV_I2C1 1
+#define CONFIG_PM_SLEEP 1
+#define CONFIG_I2C 1
+#define CONFIG_FRAME_POINTER 1
+#define CONFIG_BT_HIDP 1
+#define CONFIG_CPU_ABRT_EV7 1
+#define CONFIG_VM_EVENT_COUNTERS 1
+#define CONFIG_CRYPTO_ECB 1
+#define CONFIG_VIDEO_FIMC_DMA_AUTO 1
+#define CONFIG_NF_CONNTRACK_AMANDA 1
+#define CONFIG_DEBUG_FS 1
+#define CONFIG_BASE_FULL 1
+#define CONFIG_FB_CFB_IMAGEBLIT 1
+#define CONFIG_MACH_Q1_BD 1
+#define CONFIG_ZLIB_DEFLATE 1
+#define CONFIG_VIDEO_TVOUT 1
+#define CONFIG_VIDEO_SAMSUNG 1
+#define CONFIG_GPIO_SYSFS 1
+#define CONFIG_FW_LOADER 1
+#define CONFIG_KALLSYMS 1
+#define CONFIG_SW_SYNC_USER 1
+#define CONFIG_RTC_HCTOSYS_DEVICE "rtc0"
+#define CONFIG_NETFILTER_XT_MATCH_PKTTYPE 1
+#define CONFIG_SIGNALFD 1
+#define CONFIG_REGULATOR_MAX8997 1
+#define CONFIG_IP_NF_TARGET_REJECT_SKERR 1
+#define CONFIG_EXT4_FS 1
+#define CONFIG_TV_FB 1
+#define CONFIG_CRYPTO_SHA1 1
+#define CONFIG_ARM_DMA_MEM_BUFFERABLE 1
+#define CONFIG_IPV6_PRIVACY 1
+#define CONFIG_USB_GADGET_DUALSPEED 1
+#define CONFIG_HAS_IOMEM 1
+#define CONFIG_PPPOPNS 1
+#define CONFIG_GENERIC_IRQ_PROBE 1
+#define CONFIG_IP_NF_MATCH_TTL 1
+#define CONFIG_NETFILTER_XT_TARGET_TRACE 1
+#define CONFIG_CMA_BEST_FIT 1
+#define CONFIG_HAVE_PWM 1
+#define CONFIG_EPOLL 1
+#define CONFIG_SND_PCM 1
+#define CONFIG_PM_RUNTIME 1
+#define CONFIG_PARTITION_ADVANCED 1
+#define CONFIG_S3C_GPIO_TRACK 1
+#define CONFIG_IR_SONY_DECODER 1
+#define CONFIG_NETFILTER_XT_MATCH_COMMENT 1
+#define CONFIG_HDMI_EARJACK_MUTE 1
+#define CONFIG_NET 1
+#define CONFIG_INPUT_EVDEV 1
+#define CONFIG_MOTOR_DRV_MAX8997 1
+#define CONFIG_SND_JACK 1
+#define CONFIG_NETFILTER_XT_TARGET_TCPMSS 1
+#define CONFIG_S5P_GPIO_DRVSTR 1
+#define CONFIG_HAVE_SPARSE_IRQ 1
+#define CONFIG_EXT2_FS 1
+#define CONFIG_HID_DRAGONRISE 1
+#define CONFIG_NETFILTER_XT_MATCH_CONNTRACK 1
+#define CONFIG_EXYNOS4_SETUP_SDHCI_GPIO 1
+#define CONFIG_VFPv3 1
+#define CONFIG_CPU_EXYNOS4210 1
+#define CONFIG_PACKET 1
+#define CONFIG_ARM_ERRATA_753970 1
+#define CONFIG_NETFILTER_XT_MATCH_IPRANGE 1
+#define CONFIG_NF_CONNTRACK_TFTP 1
+#define CONFIG_MFD_MAX8997 1
+#define CONFIG_BACKLIGHT_LCD_SUPPORT 1
+#define CONFIG_INET 1
+#define CONFIG_PREVENT_FIRMWARE_BUILD 1
+#define CONFIG_CRYPTO_TWOFISH 1
+#define CONFIG_FREEZER 1
+#define CONFIG_BT 1
+#define CONFIG_RFKILL_PM 1
+#define CONFIG_NET_CLS_ACT 1
+#define CONFIG_EXYNOS_PM_HOTPLUG 1
+#define CONFIG_HID_WACOM 1
+#define CONFIG_RTC_LIB 1
+#define CONFIG_NETFILTER_XT_MATCH_POLICY 1
+#define CONFIG_HAVE_KPROBES 1
+#define CONFIG_CRYPTO_AES 1
+#define CONFIG_GPIOLIB 1
+#define CONFIG_VIDEO_MFC_MAX_INSTANCE 4
+#define CONFIG_S5PV310_HI_ARMCLK_THAN_1_2GHZ 1
+#define CONFIG_VIDEO_JPEG 1
+#define CONFIG_EXT4_USE_FOR_EXT23 1
+#define CONFIG_BT_HCIUART_H4 1
+#define CONFIG_SWP_EMULATE 1
+#define CONFIG_IP6_NF_TARGET_REJECT_SKERR 1
+#define CONFIG_NF_CONNTRACK_MARK 1
+#define CONFIG_NETFILTER 1
+#define CONFIG_NETFILTER_XT_MATCH_HASHLIMIT 1
+#define CONFIG_USE_GENERIC_SMP_HELPERS 1
+#define CONFIG_SERIO_SERPORT 1
+#define CONFIG_LIRC 1
+#define CONFIG_BT_BNEP 1
+#define CONFIG_BLK_DEV_RAM_COUNT 16
+#define CONFIG_PN544 1
+#define CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMC1 32768
+#define CONFIG_PREEMPT_RCU 1
+#define CONFIG_NF_NAT_NEEDED 1
+#define CONFIG_S5P_DEV_MIPI_DSI 1
+#define CONFIG_LOCKDEP_SUPPORT 1
+#define CONFIG_ANDROID_PMEM_MEMSIZE_PMEM_GPU1 4
+#define CONFIG_SERIAL_SAMSUNG_UARTS 4
+#define CONFIG_NO_HZ 1
+#define CONFIG_RTC_INTF_ALARM 1
+#define CONFIG_USB_ARCH_HAS_EHCI 1
+#define CONFIG_BATTERY_MAX17042_FUELGAUGE_U1 1
+#define CONFIG_CPU_FREQ_STAT 1
+#define CONFIG_VIDEO_CAPTURE_DRIVERS 1
+#define CONFIG_EXYNOS4_SETUP_USB_PHY 1
+#define CONFIG_INET6_ESP 1
+#define CONFIG_SYSCTL_SYSCALL 1
+#define CONFIG_I2C_S3C2410 1
+#define CONFIG_IP6_NF_FILTER 1
+#define CONFIG_NEED_DMA_MAP_STATE 1
+#define CONFIG_SERIO_LIBPS2 1
+#define CONFIG_NETFILTER_XT_MATCH_CONNBYTES 1
+#define CONFIG_ANDROID_PARANOID_NETWORK 1
+#define CONFIG_PAGE_OFFSET 0xC0000000
+#define CONFIG_USB_PRINTER 1
+#define CONFIG_CPU_V7 1
+#define CONFIG_FB_S5P 1
+#define CONFIG_TOUCHSCREEN_ATMEL_MXT540E 1
+#define CONFIG_PANIC_TIMEOUT 1
+#define CONFIG_ZBOOT_ROM_BSS 0x0
+#define CONFIG_MMC_MSHCI 1
+#define CONFIG_EXYNOS4_DEV_MSHC 1
+#define CONFIG_CFG80211_DEFAULT_PS 1
+#define CONFIG_SMP 1
+#define CONFIG_NETFILTER_XT_MATCH_TIME 1
+#define CONFIG_HAVE_KERNEL_GZIP 1
+#define CONFIG_NETFILTER_XT_MATCH_MAC 1
+#define CONFIG_NETFILTER_XT_TARGET_NFLOG 1
+#define CONFIG_GENERIC_ALLOCATOR 1
+#define CONFIG_KALLSYMS_ALL 1
+#define CONFIG_ANDROID_TIMED_OUTPUT 1
+#define CONFIG_LIBCRC32C 1
+#define CONFIG_IOSCHED_VR 1
+#define CONFIG_CRYPTO_SHA256 1
+#define CONFIG_HAVE_FTRACE_MCOUNT_RECORD 1
+#define CONFIG_SND_SAMSUNG_I2S 1
+#define CONFIG_INET_TCP_DIAG 1
+#define CONFIG_HID_SONY 1
+#define CONFIG_HW_CONSOLE 1
+#define CONFIG_DEVMEM 1
+#define CONFIG_HID_MONTEREY 1
+#define CONFIG_HID_EZKEY 1
+#define CONFIG_IOSCHED_NOOP 1
+#define CONFIG_SAMSUNG_CLKSRC 1
+#define CONFIG_NEON 1
+#define CONFIG_GENERIC_ACL 1
+#define CONFIG_COMPAT_BRK 1
+#define CONFIG_LOCALVERSION ""
+#define CONFIG_MACH_NO_WESTBRIDGE 1
+#define CONFIG_CRYPTO 1
+#define CONFIG_WITH_DVFS_POLICY 1
+#define CONFIG_SCHED_DEBUG 1
+#define CONFIG_DEFAULT_MMAP_MIN_ADDR 4096
+#define CONFIG_S3C_DEV_I2C7 1
+#define CONFIG_IP_NF_IPTABLES 1
+#define CONFIG_CMDLINE "console=ttySAC2,115200 consoleblank=0"
+#define CONFIG_SPI_GPIO 1
+#define CONFIG_HAVE_DMA_API_DEBUG 1
+#define CONFIG_HID_SAMSUNG 1
+#define CONFIG_FB_S5P_DEFAULT_WINDOW 2
+#define CONFIG_USB_ARCH_HAS_HCD 1
+#define CONFIG_VIDEO_SAMSUNG_V4L2 1
+#define CONFIG_GENERIC_IRQ_SHOW 1
+#define CONFIG_IPV6_OPTIMISTIC_DAD 1
+#define CONFIG_ALIGNMENT_TRAP 1
+#define CONFIG_FSYNC_CONTROL 1
+#define CONFIG_SCSI_MOD 1
+#define CONFIG_EXYNOS4_SETUP_FIMC1 1
+#define CONFIG_CPU_FREQ_GOV_LAGFREE 1
+#define CONFIG_SERIAL_SAMSUNG_CONSOLE 1
+#define CONFIG_CRYPTO_CRC32C 1
+#define CONFIG_ARCH_HAS_OPP 1
+#define CONFIG_SERIAL_CORE 1
+#define CONFIG_FUSE_FS 1
+#define CONFIG_VIDEO_TVOUT_2CH_AUDIO 1
+#define CONFIG_UID16 1
+#define CONFIG_EMBEDDED 1
+#define CONFIG_HID_MICROSOFT 1
+#define CONFIG_SMB328_CHARGER 1
+#define CONFIG_HAVE_KRETPROBES 1
+#define CONFIG_SAMSUNG_IRQ_UART 1
+#define CONFIG_NF_DEFRAG_IPV6 1
+#define CONFIG_VIDEO_DEV 1
+#define CONFIG_EXYNOS_MCT 1
+#define CONFIG_HAS_DMA 1
+#define CONFIG_NF_CT_PROTO_SCTP 1
+#define CONFIG_BT_L2CAP 1
+#define CONFIG_VIDEO_MALI400MP_UMP 1
+#define CONFIG_VIDEO_MALI400MP_DVFS 1
+#define CONFIG_SCSI 1
+#define CONFIG_GPIO_EXYNOS4 1
+#define CONFIG_FB_CFB_FILLRECT 1
+#define CONFIG_NF_NAT_PPTP 1
+#define CONFIG_SAMSUNG_GPIO_EXTRA 0
+#define CONFIG_HID_CHICONY 1
+#define CONFIG_HID 1
+#define CONFIG_SENSORS_AK8975C 1
+#define CONFIG_USB_S3C_OTG_HOST 1
+#define CONFIG_CLKDEV_LOOKUP 1
+#define CONFIG_JBD2 1
+#define CONFIG_INET6_IPCOMP 1
+#define CONFIG_IPV6_TUNNEL 1
+#define CONFIG_S5P_DEV_JPEG 1
+#define CONFIG_LOCALVERSION_AUTO 1
+#define CONFIG_EHCI_IRQ_DISTRIBUTION 1
+#define CONFIG_MISC_FILESYSTEMS 1
+#define CONFIG_USB_CDFS_SUPPORT 1
+#define CONFIG_FTRACE 1
+#define CONFIG_NETFILTER_XT_MATCH_CONNLIMIT 1
+#define CONFIG_IP_NF_RAW 1
+#define CONFIG_IP_NF_ARPFILTER 1
+#define CONFIG_NETFILTER_XT_MATCH_SOCKET 1
+#define CONFIG_HID_TOPSEED 1
+#define CONFIG_NF_NAT_H323 1
+#define CONFIG_AUDIO_SAMSUNG_MEMSIZE_SRP 1024
+#define CONFIG_HID_A4TECH 1
+#define CONFIG_IP_NF_TARGET_NETMAP 1
+#define CONFIG_RCU_CPU_STALL_TIMEOUT 60
+#define CONFIG_CHR_DEV_SG 1
+#define CONFIG_CPU_FREQ_GOV_SMARTASS 1
+#define CONFIG_SAMSUNG_DEV_TS 1
+#define CONFIG_VIDEO_S5K5BAFX 1
+#define CONFIG_VIBETONZ 1
+#define CONFIG_NF_NAT_AMANDA 1
+#define CONFIG_CACHE_PL310 1
+#define CONFIG_USB_S5P_HSIC0 1
+#define CONFIG_INET6_XFRM_MODE_TRANSPORT 1
+#define CONFIG_CRYPTO_ARC4 1
+#define CONFIG_S5P_DEV_FIMG2D 1
+#define CONFIG_VIDEO_SAMSUNG_MEMSIZE_MFC0 18432
+#define CONFIG_SLHC 1
+#define CONFIG_CRYPTO_MANAGER 1
+#define CONFIG_NET_SCH_HTB 1
+#define CONFIG_PPP_BSDCOMP 1
+#define CONFIG_S5P_DEV_CSIS 1
+#define CONFIG_EXYNOS4_MSHC_MPLL_40MHZ 1
+#define CONFIG_RT_MUTEXES 1
+#define CONFIG_VECTORS_BASE 0xffff0000
+#define CONFIG_HID_ORTEK 1
+#define CONFIG_NETFILTER_XT_TARGET_MARK 1
+#define CONFIG_I2C_ALGOBIT 1
+#define CONFIG_MMC_BLOCK 1
+#define CONFIG_EXPERT 1
+#define CONFIG_EXYNOS4_CPUIDLE 1
+#define CONFIG_WIRELESS 1
+#define CONFIG_WEXT_PROC 1
+#define CONFIG_SMB136_CHARGER_Q1 1
+#define CONFIG_PERF_USE_VMALLOC 1
+#define CONFIG_UMTS_MODEM_XMM6260 1
+#define CONFIG_FAT_DEFAULT_IOCHARSET "iso8859-1"
+#define CONFIG_FRAME_WARN 1024
+#define CONFIG_RCU_CPU_STALL_VERBOSE 1
+#define CONFIG_GENERIC_HWEIGHT 1
+#define CONFIG_INITRAMFS_SOURCE "/home/ali/android/kernel/Ramdisks/initramfs"
+#define CONFIG_CGROUPS 1
+#define CONFIG_MMC 1
+#define CONFIG_VIDEO_MFC_MEM_PORT_COUNT 2
+#define CONFIG_S5P_DEV_USBGADGET 1
+#define CONFIG_FB_S5P_MIPI_DSIM 1
+#define CONFIG_HID_LOGITECH 1
+#define CONFIG_PPPOLAC 1
+#define CONFIG_WTL_ENCRYPTION_FILTER 1
+#define CONFIG_FB_S5P_MDNIE 1
+#define CONFIG_CGROUP_CPUACCT 1
+#define CONFIG_FB_EARLYSUSPEND 1
+#define CONFIG_HZ 200
+#define CONFIG_I2C_HELPER_AUTO 1
+#define CONFIG_NETFILTER_XT_MATCH_U32 1
+#define CONFIG_SERIAL_8250_NR_UARTS 4
+#define CONFIG_RTC_DRV_MAX8997 1
+#define CONFIG_GENERIC_LOCKBREAK 1
+#define CONFIG_ARM_PATCH_PHYS_VIRT 1
+#define CONFIG_DEFAULT_IOSCHED "noop"
+#define CONFIG_IPV6_MIP6 1
+#define CONFIG_NLATTR 1
+#define CONFIG_TCP_CONG_CUBIC 1
+#define CONFIG_MACH_U1 1
+#define CONFIG_PM_RUNTIME_CLK 1
+#define CONFIG_NR_CPUS 2
+#define CONFIG_SUSPEND_FREEZER 1
+#define CONFIG_MMC_SDHCI 1
+#define CONFIG_NETFILTER_XT_CONNMARK 1
+#define CONFIG_HID_KYE 1
+#define CONFIG_FIRMWARE_IN_KERNEL 1
+#define CONFIG_SYSFS 1
+#define CONFIG_BUSFREQ 1
+#define CONFIG_INPUT_TOUCHSCREEN 1
+#define CONFIG_OUTER_CACHE_SYNC 1
+#define CONFIG_ARM_THUMB 1
+#define CONFIG_IP_NF_MATCH_AH 1
+#define CONFIG_MMC_SDHCI_S3C_DMA 1
+#define CONFIG_NETFILTER_XT_MATCH_LIMIT 1
+#define CONFIG_ARM_ERRATA_754322 1
+#define CONFIG_FB 1
+#define CONFIG_I2C_COMPAT 1
+#define CONFIG_CPU_32v7 1
+#define CONFIG_EXYNOS4_SETUP_I2C1 1
+#define CONFIG_MSDOS_PARTITION 1
+#define CONFIG_BT_HCIUART 1
+#define CONFIG_HAVE_OPROFILE 1
+#define CONFIG_HAVE_GENERIC_DMA_COHERENT 1
+#define CONFIG_CPU_IDLE_GOV_LADDER 1
+#define CONFIG_HID_PETALYNX 1
+#define CONFIG_CMA_SIZE_MBYTES 16
+#define CONFIG_NET_ACT_MIRRED 1
+#define CONFIG_HAVE_ARCH_KGDB 1
+#define CONFIG_USB_ARCH_HAS_OHCI 1
+#define CONFIG_NF_CONNTRACK_IPV4 1
+#define CONFIG_SMP_ON_UP 1
+#define CONFIG_ZONE_DMA_FLAG 0
+#define CONFIG_RPS 1
+#define CONFIG_INET6_XFRM_TUNNEL 1
+#define CONFIG_MMC_SDHCI_S3C 1
+#define CONFIG_VIDEO_MEDIA 1
+#define CONFIG_IP_MULTICAST 1
+#define CONFIG_WAKELOCK_STAT 1
+#define CONFIG_INPUT_KEYCHORD 1
+#define CONFIG_HAS_EARLYSUSPEND 1
+#define CONFIG_CPU_32v6K 1
+#define CONFIG_DEFAULT_SECURITY ""
+#define CONFIG_BUSFREQ_QOS 1
+#define CONFIG_USB_ANDROID_SAMSUNG_MTP 1
+#define CONFIG_TICK_ONESHOT 1
+#define CONFIG_NF_NAT_PROTO_UDPLITE 1
+#define CONFIG_CGROUP_DEBUG 1
+#define CONFIG_SW_SYNC 1
+#define CONFIG_VIDEO_FIXED_MINOR_RANGES 1
+#define CONFIG_ANDROID_LOGGER_MODULE 1
+#define CONFIG_HW_RANDOM 1
+#define CONFIG_MUTEX_SPIN_ON_OWNER 1
+#define CONFIG_CRYPTO_FIPS_INTEG_OFFSET 0x20000000
+#define CONFIG_RWSEM_GENERIC_SPINLOCK 1
+#define CONFIG_DEFAULT_NOOP 1
+#define CONFIG_DEBUG_S3C_UART 1
+#define CONFIG_HAVE_FUNCTION_GRAPH_TRACER 1
+#define CONFIG_SND_SOC_U1_MC1N2 1
+#define CONFIG_VIDEOBUF2_CORE 1
+#define CONFIG_NTFS_FS 1
+#define CONFIG_ARCH_EXYNOS 1
+#define CONFIG_VIDEO_FIMG2D3X 1
+#define CONFIG_BASE_SMALL 0
+#define CONFIG_CRYPTO_BLKCIPHER2 1
+#define CONFIG_COMPACTION 1
+#define CONFIG_S5P_DEV_FIMD_S5P 1
+#define CONFIG_SND_SOC_USE_EXTERNAL_MIC_BIAS 1
+#define CONFIG_PROC_FS 1
+#define CONFIG_RC_MAP 1
+#define CONFIG_SCSI_LOWLEVEL 1
+#define CONFIG_J4FS_BLOCK_COUNT 20
+#define CONFIG_HID_PANTHERLORD 1
+#define CONFIG_SND 1
+#define CONFIG_FLATMEM 1
+#define CONFIG_IR_RC6_DECODER 1
+#define CONFIG_S3C_DEV_HSMMC3 1
+#define CONFIG_FB_S5P_SPLASH_SCREEN 1
+#define CONFIG_IOVMM 1
+#define CONFIG_SEC_MODEM_U1 1
+#define CONFIG_S3C_GPIO_PULL_UPDOWN 1
+#define CONFIG_S3C_DEV_I2C3 1
+#define CONFIG_PAGEFLAGS_EXTENDED 1
+#define CONFIG_SYSCTL 1
+#define CONFIG_LOCAL_TIMERS 1
+#define CONFIG_HAVE_C_RECORDMCOUNT 1
+#define CONFIG_PL310_ERRATA_727915 1
+#define CONFIG_CIFS 1
+#define CONFIG_VIDEO_SAMSUNG_MEMSIZE_FIMC2 25600
+#define CONFIG_HAVE_PERF_EVENTS 1
+#define CONFIG_PPP_ASYNC 1
+#define CONFIG_UID_STAT 1
+#define CONFIG_SYS_SUPPORTS_APM_EMULATION 1
+#define CONFIG_RTC_INTF_ALARM_DEV 1
+#define CONFIG_CMA_AREAS 7
+#define CONFIG_SAMSUNG_PD 1
+#define CONFIG_S3C_GPIO_SPACE 0
+#define CONFIG_NETFILTER_XT_MATCH_QUOTA2 1
+#define CONFIG_HID_ELECOM 1
+#define CONFIG_SND_TIMER 1
+#define CONFIG_USB_EHCI_TT_NEWSCHED 1
+#define CONFIG_FAT_DEFAULT_CODEPAGE 437
+#define CONFIG_BLK_DEV 1
+#define CONFIG_SAMSUNG_ANALOG_UART_SWITCH 1
+#define CONFIG_TRACING_SUPPORT 1
+#define CONFIG_UNIX98_PTYS 1
+#define CONFIG_NETFILTER_XT_TARGET_CONNMARK 1
+#define CONFIG_JACK_RESELECTOR_SUPPORT 1
+#define CONFIG_NET_SCHED 1
+#define CONFIG_SAMSUNG_WORKAROUND_HPD_GLANCE 1
+#define CONFIG_PPP 1
+#define CONFIG_NETFILTER_XT_MATCH_QUOTA 1
+#define CONFIG_HAVE_KERNEL_LZO 1
+#define CONFIG_INET_DIAG 1
+#define CONFIG_NF_NAT_FTP 1
+#define CONFIG_HID_ROCCAT_KONE 1
+#define CONFIG_NF_CT_PROTO_UDPLITE 1
+#define CONFIG_ELF_CORE 1
+#define CONFIG_TEXTSEARCH 1
+#define CONFIG_WLAN_REGION_CODE 100
+#define CONFIG_USB_SUPPORT 1
+#define CONFIG_NETFILTER_XT_MATCH_QTAGUID 1
+#define CONFIG_PL330 1
+#define CONFIG_STAGING 1
+#define CONFIG_DMA_CMA 1
+#define CONFIG_FLAT_NODE_MEM_MAP 1
+#define CONFIG_CPU_FREQ_GOV_PEGASUSQ 1
+#define CONFIG_CFG80211_WEXT 1
+#define CONFIG_BLK_DEV_RAM 1
+#define CONFIG_NETFILTER_XT_MATCH_STATE 1
+#define CONFIG_IR_RC5_DECODER 1
+#define CONFIG_INET6_XFRM_MODE_BEET 1
+#define CONFIG_KEYBOARD_CYPRESS_TOUCH 1
+#define CONFIG_PREEMPT 1
+#define CONFIG_USE_MFC_CMA 1
+#define CONFIG_FB_CFB_COPYAREA 1
+#define CONFIG_MALI_OSMEM_ONLY 1
+#define CONFIG_EXYNOS4_PM 1
+#define CONFIG_MMC_CLKGATE 1
+#define CONFIG_GENERIC_CLOCKEVENTS_BUILD 1
+#define CONFIG_VIDEO_V4L2 1
+#define CONFIG_SYSVIPC_SYSCTL 1
+#define CONFIG_HID_NTRIG 1
+#define CONFIG_S3C_LOWLEVEL_UART_PORT 2
+#define CONFIG_DECOMPRESS_GZIP 1
+#define CONFIG_S5P_GPIO_INT 1
+#define CONFIG_I2C_CHARDEV 1
+#define CONFIG_CROSS_COMPILE "/usr/local/arm/arm-eabi-4.4.3/bin/arm-eabi-"
+#define CONFIG_S3C_DEV_I2C6 1
+#define CONFIG_USB_GADGET_SELECTED 1
+#define CONFIG_GENERIC_CLOCKEVENTS_BROADCAST 1
+#define CONFIG_NLS_UTF8 1
+#define CONFIG_NETFILTER_TPROXY 1
+#define CONFIG_UMP_OSMEM_ONLY 1
+#define CONFIG_LTO_MENU 1
+#define CONFIG_SCSI_MULTI_LUN 1
+#define CONFIG_NET_ACT_POLICE 1
+#define CONFIG_EXYNOS4_SETUP_FIMC0 1
+#define CONFIG_HID_SMARTJOYPLUS 1
+#define CONFIG_NEW_LEDS 1
+#define CONFIG_VIDEO_FIMC_RANGE_NARROW 1
+#define CONFIG_CRC_CCITT 1
+#define CONFIG_ANDROID_PMEM 1
+#define CONFIG_BLK_DEV_SD 1
+#define CONFIG_CMDLINE_FROM_BOOTLOADER 1
+#define CONFIG_NETFILTER_NETLINK 1
+#define CONFIG_MODULE_UNLOAD 1
+#define CONFIG_USB_ARCH_HAS_XHCI 1
+#define CONFIG_CMA 1
+#define CONFIG_SAMSUNG_GPIOLIB_4BIT 1
+#define CONFIG_RCU_FANOUT 32
+#define CONFIG_BITREVERSE 1
+#define CONFIG_BLK_DEV_RAM_SIZE 8192
+#define CONFIG_USB_GADGET_S3C_OTGD 1
+#define CONFIG_VIDEO_V4L2_COMMON 1
+#define CONFIG_CRYPTO_BLKCIPHER 1
+#define CONFIG_USER_ALLOC_TVOUT 1
+#define CONFIG_NF_CONNTRACK 1
+#define CONFIG_LCD_CLASS_DEVICE 1
+#define CONFIG_FILE_LOCKING 1
+#define CONFIG_S3C_DEV_WDT 1
+#define CONFIG_SND_SOC_I2C_AND_SPI 1
+#define CONFIG_S5P_SYSTEM_MMU 1
+#define CONFIG_NET_EMATCH 1
+#define CONFIG_IP_NF_TARGET_REJECT 1
+#define CONFIG_LEDS_CLASS 1
+#define CONFIG_GENERIC_HARDIRQS 1
+#define CONFIG_SYSCTL_SYSCALL_CHECK 1
+#define CONFIG_INITRAMFS_COMPRESSION_GZIP 1
+#define CONFIG_RTC_INTF_DEV 1
+#define CONFIG_SAMSUNG_IRQ_VIC_TIMER 1
+#define CONFIG_HID_SUPPORT 1
+#define CONFIG_NET_ACTIVITY_STATS 1
+#define CONFIG_CMA_ALIGNMENT 8
+#define CONFIG_NLS_DEFAULT "iso8859-1"
+#define CONFIG_NF_CT_PROTO_GRE 1
+#define CONFIG_NF_CT_NETLINK 1
+#define CONFIG_HAVE_S3C2410_I2C 1
+#define CONFIG_CRYPTO_AEAD2 1
+#define CONFIG_NETFILTER_XT_MATCH_HL 1
+#define CONFIG_CRYPTO_ALGAPI2 1
+#define CONFIG_ZBOOT_ROM_TEXT 0x0
+#define CONFIG_HAVE_MEMBLOCK 1
+#define CONFIG_EXYNOS4_SETUP_THERMAL 1
+#define CONFIG_INPUT 1
+#define CONFIG_PROC_SYSCTL 1
+#define CONFIG_MMU 1
+#define CONFIG_HAVE_IRQ_WORK 1
+#define CONFIG_USER_WAKELOCK 1
+#define CONFIG_SEC_MODEM 1
+#define CONFIG_SND_SAMSUNG_ALP 1
+#define CONFIG_S3C_DEV_FIMC 1
+#define CONFIG_PLAT_S5P 1
+#define CONFIG_FB_S5P_VSYNC_THREAD 1
diff -urNp Kernel/include/generated/bounds.h HelloWorld-Renew-v1.0-n7000-jb/include/generated/bounds.h
--- Kernel/include/generated/bounds.h	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/include/generated/bounds.h	2013-05-02 00:10:51.983407644 +0200
@@ -0,0 +1,14 @@
+#ifndef __LINUX_BOUNDS_H__
+#define __LINUX_BOUNDS_H__
+/*
+ * DO NOT MODIFY.
+ *
+ * This file was generated by Kbuild
+ *
+ */
+
+#define NR_PAGEFLAGS 22 /* __NR_PAGEFLAGS	@ */
+#define MAX_NR_ZONES 3 /* __MAX_NR_ZONES	@ */
+#define NR_PCG_FLAGS 7 /* __NR_PCG_FLAGS	@ */
+
+#endif
diff -urNp Kernel/include/generated/compile.h HelloWorld-Renew-v1.0-n7000-jb/include/generated/compile.h
--- Kernel/include/generated/compile.h	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/include/generated/compile.h	2013-05-02 00:40:41.159412689 +0200
@@ -0,0 +1,7 @@
+/* This file is auto generated, version 42 */
+/* SMP PREEMPT */
+#define UTS_MACHINE "arm"
+#define UTS_VERSION "#42 SMP PREEMPT Thu May 2 00:40:41 CEST 2013"
+#define LINUX_COMPILE_BY "c.o.h."
+#define LINUX_COMPILE_HOST "HelloWorld-N7000-JB"
+#define LINUX_COMPILER "gcc version 4.6 20120106 (prerelease) (GCC) "
diff -urNp Kernel/include/generated/mach-types.h HelloWorld-Renew-v1.0-n7000-jb/include/generated/mach-types.h
--- Kernel/include/generated/mach-types.h	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/include/generated/mach-types.h	2013-04-29 16:58:29.594590321 +0200
@@ -0,0 +1,14350 @@
+/*
+ * This was automagically generated from arch/arm/tools/mach-types!
+ * Do NOT edit
+ */
+
+#ifndef __ASM_ARM_MACH_TYPE_H
+#define __ASM_ARM_MACH_TYPE_H
+
+#ifndef __ASSEMBLY__
+/* The type of machine we're running on */
+extern unsigned int __machine_arch_type;
+#endif
+
+/* see arch/arm/kernel/arch.c for a description of these */
+#define MACH_TYPE_EBSA110              0
+#define MACH_TYPE_RISCPC               1
+#define MACH_TYPE_EBSA285              4
+#define MACH_TYPE_NETWINDER            5
+#define MACH_TYPE_CATS                 6
+#define MACH_TYPE_SHARK                15
+#define MACH_TYPE_BRUTUS               16
+#define MACH_TYPE_PERSONAL_SERVER      17
+#define MACH_TYPE_L7200                19
+#define MACH_TYPE_PLEB                 20
+#define MACH_TYPE_INTEGRATOR           21
+#define MACH_TYPE_H3600                22
+#define MACH_TYPE_P720T                24
+#define MACH_TYPE_ASSABET              25
+#define MACH_TYPE_LART                 27
+#define MACH_TYPE_GRAPHICSCLIENT       29
+#define MACH_TYPE_XP860                30
+#define MACH_TYPE_CERF                 31
+#define MACH_TYPE_NANOENGINE           32
+#define MACH_TYPE_JORNADA720           48
+#define MACH_TYPE_EDB7211              50
+#define MACH_TYPE_PFS168               52
+#define MACH_TYPE_FLEXANET             54
+#define MACH_TYPE_SIMPAD               87
+#define MACH_TYPE_LUBBOCK              89
+#define MACH_TYPE_CLEP7212             91
+#define MACH_TYPE_SHANNON              97
+#define MACH_TYPE_CONSUS               105
+#define MACH_TYPE_AAED2000             106
+#define MACH_TYPE_CDB89712             107
+#define MACH_TYPE_GRAPHICSMASTER       108
+#define MACH_TYPE_ADSBITSY             109
+#define MACH_TYPE_PXA_IDP              110
+#define MACH_TYPE_PT_SYSTEM3           112
+#define MACH_TYPE_AUTCPU12             118
+#define MACH_TYPE_H3100                136
+#define MACH_TYPE_COLLIE               146
+#define MACH_TYPE_BADGE4               148
+#define MACH_TYPE_FORTUNET             152
+#define MACH_TYPE_MX1ADS               160
+#define MACH_TYPE_H7201                161
+#define MACH_TYPE_H7202                162
+#define MACH_TYPE_IQ80321              169
+#define MACH_TYPE_KS8695               180
+#define MACH_TYPE_SMDK2410             193
+#define MACH_TYPE_CEIVA                200
+#define MACH_TYPE_VOICEBLUE            218
+#define MACH_TYPE_H5400                220
+#define MACH_TYPE_OMAP_INNOVATOR       234
+#define MACH_TYPE_IXDP2400             242
+#define MACH_TYPE_IXDP2800             243
+#define MACH_TYPE_IXDP425              245
+#define MACH_TYPE_HACKKIT              254
+#define MACH_TYPE_IXCDP1100            260
+#define MACH_TYPE_AT91RM9200DK         262
+#define MACH_TYPE_CINTEGRATOR          275
+#define MACH_TYPE_VIPER                283
+#define MACH_TYPE_ADI_COYOTE           290
+#define MACH_TYPE_IXDP2401             299
+#define MACH_TYPE_IXDP2801             300
+#define MACH_TYPE_IQ31244              327
+#define MACH_TYPE_BAST                 331
+#define MACH_TYPE_H1940                347
+#define MACH_TYPE_ENP2611              356
+#define MACH_TYPE_S3C2440              362
+#define MACH_TYPE_GUMSTIX              373
+#define MACH_TYPE_OMAP_H2              382
+#define MACH_TYPE_E740                 384
+#define MACH_TYPE_IQ80331              385
+#define MACH_TYPE_VERSATILE_PB         387
+#define MACH_TYPE_KEV7A400             388
+#define MACH_TYPE_LPD7A400             389
+#define MACH_TYPE_LPD7A404             390
+#define MACH_TYPE_CSB337               399
+#define MACH_TYPE_MAINSTONE            406
+#define MACH_TYPE_XCEP                 413
+#define MACH_TYPE_ARCOM_VULCAN         414
+#define MACH_TYPE_NOMADIK              420
+#define MACH_TYPE_CORGI                423
+#define MACH_TYPE_POODLE               424
+#define MACH_TYPE_ARMCORE              438
+#define MACH_TYPE_MX31ADS              447
+#define MACH_TYPE_HIMALAYA             448
+#define MACH_TYPE_EDB9312              451
+#define MACH_TYPE_OMAP_GENERIC         452
+#define MACH_TYPE_EDB9301              462
+#define MACH_TYPE_EDB9315              463
+#define MACH_TYPE_VR1000               475
+#define MACH_TYPE_OMAP_PERSEUS2        491
+#define MACH_TYPE_E800                 496
+#define MACH_TYPE_E750                 497
+#define MACH_TYPE_SCB9328              508
+#define MACH_TYPE_OMAP_H3              509
+#define MACH_TYPE_OMAP_H4              510
+#define MACH_TYPE_OMAP_OSK             515
+#define MACH_TYPE_TOSA                 520
+#define MACH_TYPE_AVILA                526
+#define MACH_TYPE_EDB9302              538
+#define MACH_TYPE_HUSKY                543
+#define MACH_TYPE_SHEPHERD             545
+#define MACH_TYPE_H4700                562
+#define MACH_TYPE_RX3715               592
+#define MACH_TYPE_NSLU2                597
+#define MACH_TYPE_E400                 598
+#define MACH_TYPE_IXDPG425             604
+#define MACH_TYPE_VERSATILE_AB         606
+#define MACH_TYPE_EDB9307              607
+#define MACH_TYPE_KB9200               612
+#define MACH_TYPE_SX1                  613
+#define MACH_TYPE_IXDP465              618
+#define MACH_TYPE_IXDP2351             619
+#define MACH_TYPE_IQ80332              629
+#define MACH_TYPE_GTWX5715             641
+#define MACH_TYPE_CSB637               648
+#define MACH_TYPE_N30                  656
+#define MACH_TYPE_NEC_MP900            659
+#define MACH_TYPE_KAFA                 662
+#define MACH_TYPE_TS72XX               673
+#define MACH_TYPE_OTOM                 680
+#define MACH_TYPE_NEXCODER_2440        681
+#define MACH_TYPE_ECO920               702
+#define MACH_TYPE_ROADRUNNER           704
+#define MACH_TYPE_AT91RM9200EK         705
+#define MACH_TYPE_SPITZ                713
+#define MACH_TYPE_ADSSPHERE            723
+#define MACH_TYPE_COLIBRI              729
+#define MACH_TYPE_GATEWAY7001          731
+#define MACH_TYPE_PCM027               732
+#define MACH_TYPE_ANUBIS               734
+#define MACH_TYPE_AKITA                744
+#define MACH_TYPE_E330                 753
+#define MACH_TYPE_NOKIA770             755
+#define MACH_TYPE_CARMEVA              769
+#define MACH_TYPE_EDB9315A             772
+#define MACH_TYPE_STARGATE2            774
+#define MACH_TYPE_INTELMOTE2           775
+#define MACH_TYPE_TRIZEPS4             776
+#define MACH_TYPE_PNX4008              782
+#define MACH_TYPE_CPUAT91              787
+#define MACH_TYPE_IQ81340SC            799
+#define MACH_TYPE_IQ81340MC            801
+#define MACH_TYPE_MICRO9               811
+#define MACH_TYPE_MICRO9L              812
+#define MACH_TYPE_OMAP_PALMTE          817
+#define MACH_TYPE_REALVIEW_EB          827
+#define MACH_TYPE_BORZOI               831
+#define MACH_TYPE_PALMLD               835
+#define MACH_TYPE_IXDP28X5             838
+#define MACH_TYPE_OMAP_PALMTT          839
+#define MACH_TYPE_ARCOM_ZEUS           841
+#define MACH_TYPE_OSIRIS               842
+#define MACH_TYPE_PALMTE2              844
+#define MACH_TYPE_MX27ADS              846
+#define MACH_TYPE_AT91SAM9261EK        848
+#define MACH_TYPE_LOFT                 849
+#define MACH_TYPE_MX21ADS              851
+#define MACH_TYPE_AMS_DELTA            862
+#define MACH_TYPE_NAS100D              865
+#define MACH_TYPE_MAGICIAN             875
+#define MACH_TYPE_NXDKN                880
+#define MACH_TYPE_PALMTX               885
+#define MACH_TYPE_S3C2413              887
+#define MACH_TYPE_WG302V2              890
+#define MACH_TYPE_OMAP_2430SDP         900
+#define MACH_TYPE_DAVINCI_EVM          901
+#define MACH_TYPE_PALMZ72              904
+#define MACH_TYPE_NXDB500              905
+#define MACH_TYPE_PALMT5               917
+#define MACH_TYPE_PALMTC               918
+#define MACH_TYPE_OMAP_APOLLON         919
+#define MACH_TYPE_ATEB9200             923
+#define MACH_TYPE_N35                  927
+#define MACH_TYPE_LOGICPD_PXA270       930
+#define MACH_TYPE_NXEB500HMI           941
+#define MACH_TYPE_ESPRESSO             949
+#define MACH_TYPE_RX1950               952
+#define MACH_TYPE_GESBC9312            958
+#define MACH_TYPE_PICOTUX2XX           963
+#define MACH_TYPE_DSMG600              964
+#define MACH_TYPE_OMAP_FSAMPLE         970
+#define MACH_TYPE_SNAPPER_CL15         986
+#define MACH_TYPE_OMAP_PALMZ71         993
+#define MACH_TYPE_SMDK2412             1009
+#define MACH_TYPE_SMDK2413             1022
+#define MACH_TYPE_AML_M5900            1024
+#define MACH_TYPE_BALLOON3             1029
+#define MACH_TYPE_ECBAT91              1072
+#define MACH_TYPE_ONEARM               1075
+#define MACH_TYPE_SMDK2443             1084
+#define MACH_TYPE_FSG                  1091
+#define MACH_TYPE_AT91SAM9260EK        1099
+#define MACH_TYPE_GLANTANK             1100
+#define MACH_TYPE_N2100                1101
+#define MACH_TYPE_QT2410               1108
+#define MACH_TYPE_KIXRP435             1109
+#define MACH_TYPE_CC9P9360DEV          1114
+#define MACH_TYPE_EDB9302A             1127
+#define MACH_TYPE_EDB9307A             1128
+#define MACH_TYPE_OMAP_3430SDP         1138
+#define MACH_TYPE_VSTMS                1140
+#define MACH_TYPE_MICRO9M              1169
+#define MACH_TYPE_BUG                  1179
+#define MACH_TYPE_AT91SAM9263EK        1202
+#define MACH_TYPE_EM7210               1212
+#define MACH_TYPE_VPAC270              1227
+#define MACH_TYPE_TREO680              1230
+#define MACH_TYPE_ZYLONITE             1233
+#define MACH_TYPE_MX31LITE             1236
+#define MACH_TYPE_MIOA701              1257
+#define MACH_TYPE_ARMADILLO5X0         1260
+#define MACH_TYPE_CC9P9360JS           1264
+#define MACH_TYPE_SMDK6400             1270
+#define MACH_TYPE_NOKIA_N800           1271
+#define MACH_TYPE_EP80219              1281
+#define MACH_TYPE_GORAMO_MLR           1292
+#define MACH_TYPE_EM_X270              1297
+#define MACH_TYPE_NEO1973_GTA02        1304
+#define MACH_TYPE_AT91SAM9RLEK         1326
+#define MACH_TYPE_COLIBRI320           1340
+#define MACH_TYPE_CAM60                1351
+#define MACH_TYPE_AT91EB01             1354
+#define MACH_TYPE_DB88F5281            1358
+#define MACH_TYPE_CSB726               1359
+#define MACH_TYPE_DAVINCI_DM6467_EVM   1380
+#define MACH_TYPE_DAVINCI_DM355_EVM    1381
+#define MACH_TYPE_LITTLETON            1388
+#define MACH_TYPE_REALVIEW_PB11MP      1407
+#define MACH_TYPE_MX27_3DS             1430
+#define MACH_TYPE_HALIBUT              1439
+#define MACH_TYPE_TROUT                1440
+#define MACH_TYPE_TCT_HAMMER           1460
+#define MACH_TYPE_HERALD               1461
+#define MACH_TYPE_SIM_ONE              1476
+#define MACH_TYPE_JIVE                 1490
+#define MACH_TYPE_SAM9_L9260           1501
+#define MACH_TYPE_REALVIEW_PB1176      1504
+#define MACH_TYPE_YL9200               1507
+#define MACH_TYPE_RD88F5182            1508
+#define MACH_TYPE_KUROBOX_PRO          1509
+#define MACH_TYPE_MX31_3DS             1511
+#define MACH_TYPE_QONG                 1524
+#define MACH_TYPE_OMAP2EVM             1534
+#define MACH_TYPE_OMAP3EVM             1535
+#define MACH_TYPE_DNS323               1542
+#define MACH_TYPE_OMAP3_BEAGLE         1546
+#define MACH_TYPE_NOKIA_N810           1548
+#define MACH_TYPE_PCM038               1551
+#define MACH_TYPE_TS209                1565
+#define MACH_TYPE_AT91CAP9ADK          1566
+#define MACH_TYPE_MX31MOBOARD          1574
+#define MACH_TYPE_TERASTATION_PRO2     1584
+#define MACH_TYPE_LINKSTATION_PRO      1585
+#define MACH_TYPE_E350                 1596
+#define MACH_TYPE_TS409                1601
+#define MACH_TYPE_CM_X300              1616
+#define MACH_TYPE_AT91SAM9G20EK        1624
+#define MACH_TYPE_SMDK6410             1626
+#define MACH_TYPE_U300                 1627
+#define MACH_TYPE_WRT350N_V2           1633
+#define MACH_TYPE_OMAP_LDP             1639
+#define MACH_TYPE_MX35_3DS             1645
+#define MACH_TYPE_NEUROS_OSD2          1647
+#define MACH_TYPE_TRIZEPS4WL           1649
+#define MACH_TYPE_TS78XX               1652
+#define MACH_TYPE_SFFSDR               1657
+#define MACH_TYPE_PCM037               1673
+#define MACH_TYPE_DB88F6281_BP         1680
+#define MACH_TYPE_RD88F6192_NAS        1681
+#define MACH_TYPE_RD88F6281            1682
+#define MACH_TYPE_DB78X00_BP           1683
+#define MACH_TYPE_SMDK2416             1685
+#define MACH_TYPE_WBD111               1690
+#define MACH_TYPE_MV2120               1693
+#define MACH_TYPE_MX51_3DS             1696
+#define MACH_TYPE_IMX27LITE            1701
+#define MACH_TYPE_USB_A9260            1709
+#define MACH_TYPE_USB_A9263            1710
+#define MACH_TYPE_QIL_A9260            1711
+#define MACH_TYPE_KZM_ARM11_01         1722
+#define MACH_TYPE_NOKIA_N810_WIMAX     1727
+#define MACH_TYPE_SAPPHIRE             1729
+#define MACH_TYPE_STMP37XX             1732
+#define MACH_TYPE_STMP378X             1733
+#define MACH_TYPE_EZX_A780             1740
+#define MACH_TYPE_EZX_E680             1741
+#define MACH_TYPE_EZX_A1200            1742
+#define MACH_TYPE_EZX_E6               1743
+#define MACH_TYPE_EZX_E2               1744
+#define MACH_TYPE_EZX_A910             1745
+#define MACH_TYPE_EDMINI_V2            1756
+#define MACH_TYPE_ZIPIT2               1757
+#define MACH_TYPE_OMAP3_PANDORA        1761
+#define MACH_TYPE_MSS2                 1766
+#define MACH_TYPE_LB88RC8480           1769
+#define MACH_TYPE_MX25_3DS             1771
+#define MACH_TYPE_OMAP3530_LV_SOM      1773
+#define MACH_TYPE_DAVINCI_DA830_EVM    1781
+#define MACH_TYPE_AT572D940HFEB        1783
+#define MACH_TYPE_DOVE_DB              1788
+#define MACH_TYPE_OVERO                1798
+#define MACH_TYPE_AT2440EVB            1799
+#define MACH_TYPE_NEOCORE926           1800
+#define MACH_TYPE_WNR854T              1801
+#define MACH_TYPE_RD88F5181L_GE        1812
+#define MACH_TYPE_RD88F5181L_FXO       1818
+#define MACH_TYPE_STAMP9G20            1824
+#define MACH_TYPE_SMDKC100             1826
+#define MACH_TYPE_TAVOREVB             1827
+#define MACH_TYPE_SAAR                 1828
+#define MACH_TYPE_AT91SAM9M10G45EK     1830
+#define MACH_TYPE_MXLADS               1851
+#define MACH_TYPE_LINKSTATION_MINI     1858
+#define MACH_TYPE_AFEB9260             1859
+#define MACH_TYPE_IMX27IPCAM           1871
+#define MACH_TYPE_RD88F6183AP_GE       1894
+#define MACH_TYPE_REALVIEW_PBA8        1897
+#define MACH_TYPE_REALVIEW_PBX         1901
+#define MACH_TYPE_MICRO9S              1902
+#define MACH_TYPE_RUT100               1908
+#define MACH_TYPE_G3EVM                1919
+#define MACH_TYPE_W90P910EVB           1921
+#define MACH_TYPE_W90P950EVB           1923
+#define MACH_TYPE_W90N960EVB           1924
+#define MACH_TYPE_MV88F6281GTW_GE      1932
+#define MACH_TYPE_NCP                  1933
+#define MACH_TYPE_DAVINCI_DM365_EVM    1939
+#define MACH_TYPE_CENTRO               1944
+#define MACH_TYPE_NOKIA_RX51           1955
+#define MACH_TYPE_OMAP_ZOOM2           1967
+#define MACH_TYPE_CPUAT9260            1973
+#define MACH_TYPE_CPUIMX27             1975
+#define MACH_TYPE_ACS5K                1982
+#define MACH_TYPE_SNAPPER_9260         1987
+#define MACH_TYPE_DSM320               1988
+#define MACH_TYPE_EXEDA                1994
+#define MACH_TYPE_MINI2440             1999
+#define MACH_TYPE_COLIBRI300           2000
+#define MACH_TYPE_LINKSTATION_LS_HGL   2005
+#define MACH_TYPE_CPUAT9G20            2031
+#define MACH_TYPE_SMDK6440             2032
+#define MACH_TYPE_NAS4220B             2038
+#define MACH_TYPE_ZYLONITE2            2042
+#define MACH_TYPE_ASPENITE             2043
+#define MACH_TYPE_TTC_DKB              2045
+#define MACH_TYPE_PCM043               2072
+#define MACH_TYPE_SHEEVAPLUG           2097
+#define MACH_TYPE_AVENGERS_LITE        2104
+#define MACH_TYPE_MX51_BABBAGE         2125
+#define MACH_TYPE_RD78X00_MASA         2135
+#define MACH_TYPE_DM355_LEOPARD        2138
+#define MACH_TYPE_TS219                2139
+#define MACH_TYPE_PCA100               2149
+#define MACH_TYPE_DAVINCI_DA850_EVM    2157
+#define MACH_TYPE_AT91SAM9G10EK        2159
+#define MACH_TYPE_OMAP_4430SDP         2160
+#define MACH_TYPE_MAGX_ZN5             2162
+#define MACH_TYPE_BTMAVB101            2172
+#define MACH_TYPE_BTMAWB101            2173
+#define MACH_TYPE_OMAP3_TORPEDO        2178
+#define MACH_TYPE_ANW6410              2183
+#define MACH_TYPE_IMX27_VISSTRIM_M10   2187
+#define MACH_TYPE_PORTUXG20            2191
+#define MACH_TYPE_SMDKC110             2193
+#define MACH_TYPE_OMAP3517EVM          2200
+#define MACH_TYPE_NETSPACE_V2          2201
+#define MACH_TYPE_NETSPACE_MAX_V2      2202
+#define MACH_TYPE_D2NET_V2             2203
+#define MACH_TYPE_NET2BIG_V2           2204
+#define MACH_TYPE_NET5BIG_V2           2206
+#define MACH_TYPE_INETSPACE_V2         2208
+#define MACH_TYPE_AT91SAM9G45EKES      2212
+#define MACH_TYPE_PC7302               2220
+#define MACH_TYPE_SPEAR600             2236
+#define MACH_TYPE_SPEAR300             2237
+#define MACH_TYPE_LILLY1131            2239
+#define MACH_TYPE_HMT                  2254
+#define MACH_TYPE_VEXPRESS             2272
+#define MACH_TYPE_D2NET                2282
+#define MACH_TYPE_BIGDISK              2283
+#define MACH_TYPE_AT91SAM9G20EK_2MMC   2288
+#define MACH_TYPE_BCMRING              2289
+#define MACH_TYPE_DP6XX                2302
+#define MACH_TYPE_MAHIMAHI             2304
+#define MACH_TYPE_SMDK6442             2324
+#define MACH_TYPE_OPENRD_BASE          2325
+#define MACH_TYPE_DEVKIT8000           2330
+#define MACH_TYPE_MX51_EFIKAMX         2336
+#define MACH_TYPE_CM_T35               2341
+#define MACH_TYPE_NET2BIG              2342
+#define MACH_TYPE_IGEP0020             2344
+#define MACH_TYPE_NUC932EVB            2356
+#define MACH_TYPE_OPENRD_CLIENT        2361
+#define MACH_TYPE_U8500                2368
+#define MACH_TYPE_MX51_EFIKASB         2370
+#define MACH_TYPE_MARVELL_JASPER       2382
+#define MACH_TYPE_FLINT                2383
+#define MACH_TYPE_TAVOREVB3            2384
+#define MACH_TYPE_TOUCHBOOK            2393
+#define MACH_TYPE_RAUMFELD_RC          2413
+#define MACH_TYPE_RAUMFELD_CONNECTOR   2414
+#define MACH_TYPE_RAUMFELD_SPEAKER     2415
+#define MACH_TYPE_TNETV107X            2418
+#define MACH_TYPE_SMDKV210             2456
+#define MACH_TYPE_OMAP_ZOOM3           2464
+#define MACH_TYPE_OMAP_3630SDP         2465
+#define MACH_TYPE_SMARTQ7              2479
+#define MACH_TYPE_WATSON_EFM_PLUGIN    2491
+#define MACH_TYPE_G4EVM                2493
+#define MACH_TYPE_OMAPL138_HAWKBOARD   2495
+#define MACH_TYPE_TS41X                2502
+#define MACH_TYPE_PHY3250              2511
+#define MACH_TYPE_MINI6410             2520
+#define MACH_TYPE_MX28EVK              2531
+#define MACH_TYPE_SMARTQ5              2534
+#define MACH_TYPE_DAVINCI_DM6467TEVM   2548
+#define MACH_TYPE_MXT_TD60             2550
+#define MACH_TYPE_RIOT_BEI2            2576
+#define MACH_TYPE_RIOT_X37             2578
+#define MACH_TYPE_CAPC7117             2612
+#define MACH_TYPE_ICONTROL             2624
+#define MACH_TYPE_QSD8X50A_ST1_5       2627
+#define MACH_TYPE_MX23EVK              2629
+#define MACH_TYPE_AP4EVB               2630
+#define MACH_TYPE_MITYOMAPL138         2650
+#define MACH_TYPE_GURUPLUG             2659
+#define MACH_TYPE_SPEAR310             2660
+#define MACH_TYPE_SPEAR320             2661
+#define MACH_TYPE_AQUILA               2676
+#define MACH_TYPE_ESATA_SHEEVAPLUG     2678
+#define MACH_TYPE_MSM7X30_SURF         2679
+#define MACH_TYPE_EA2478DEVKIT         2683
+#define MACH_TYPE_TERASTATION_WXL      2697
+#define MACH_TYPE_MSM7X25_SURF         2703
+#define MACH_TYPE_MSM7X25_FFA          2704
+#define MACH_TYPE_MSM7X27_SURF         2705
+#define MACH_TYPE_MSM7X27_FFA          2706
+#define MACH_TYPE_MSM7X30_FFA          2707
+#define MACH_TYPE_QSD8X50_SURF         2708
+#define MACH_TYPE_MX53_EVK             2716
+#define MACH_TYPE_IGEP0030             2717
+#define MACH_TYPE_SBC3530              2722
+#define MACH_TYPE_SAARB                2727
+#define MACH_TYPE_HARMONY              2731
+#define MACH_TYPE_MSM7X30_FLUID        2741
+#define MACH_TYPE_CM_T3517             2750
+#define MACH_TYPE_WBD222               2753
+#define MACH_TYPE_MSM8X60_SURF         2755
+#define MACH_TYPE_MSM8X60_SIM          2756
+#define MACH_TYPE_TCC8000_SDK          2758
+#define MACH_TYPE_NANOS                2759
+#define MACH_TYPE_STAMP9G45            2761
+#define MACH_TYPE_CNS3420VB            2776
+#define MACH_TYPE_OMAP4_PANDA          2791
+#define MACH_TYPE_TI8168EVM            2800
+#define MACH_TYPE_TETON_BGA            2816
+#define MACH_TYPE_EUKREA_CPUIMX25      2820
+#define MACH_TYPE_EUKREA_CPUIMX35      2821
+#define MACH_TYPE_EUKREA_CPUIMX51SD    2822
+#define MACH_TYPE_EUKREA_CPUIMX51      2823
+#define MACH_TYPE_SMDKC210             2838
+#define MACH_TYPE_OMAP3_BRAILLO        2839
+#define MACH_TYPE_SPYPLUG              2840
+#define MACH_TYPE_GINGER               2841
+#define MACH_TYPE_TNY_T3530            2842
+#define MACH_TYPE_PCA102               2843
+#define MACH_TYPE_SPADE                2844
+#define MACH_TYPE_MXC25_TOPAZ          2845
+#define MACH_TYPE_T5325                2846
+#define MACH_TYPE_GW2361               2847
+#define MACH_TYPE_ELOG                 2848
+#define MACH_TYPE_INCOME               2849
+#define MACH_TYPE_BCM589X              2850
+#define MACH_TYPE_ETNA                 2851
+#define MACH_TYPE_HAWKS                2852
+#define MACH_TYPE_MESON                2853
+#define MACH_TYPE_XSBASE255            2854
+#define MACH_TYPE_PVM2030              2855
+#define MACH_TYPE_MIOA502              2856
+#define MACH_TYPE_VVBOX_SDORIG2        2857
+#define MACH_TYPE_VVBOX_SDLITE2        2858
+#define MACH_TYPE_VVBOX_SDPRO4         2859
+#define MACH_TYPE_HTC_SPV_M700         2860
+#define MACH_TYPE_MX257SX              2861
+#define MACH_TYPE_GONI                 2862
+#define MACH_TYPE_MSM8X55_SVLTE_FFA    2863
+#define MACH_TYPE_MSM8X55_SVLTE_SURF   2864
+#define MACH_TYPE_QUICKSTEP            2865
+#define MACH_TYPE_DMW96                2866
+#define MACH_TYPE_HAMMERHEAD           2867
+#define MACH_TYPE_TRIDENT              2868
+#define MACH_TYPE_LIGHTNING            2869
+#define MACH_TYPE_ICONNECT             2870
+#define MACH_TYPE_AUTOBOT              2871
+#define MACH_TYPE_COCONUT              2872
+#define MACH_TYPE_DURIAN               2873
+#define MACH_TYPE_CAYENNE              2874
+#define MACH_TYPE_FUJI                 2875
+#define MACH_TYPE_SYNOLOGY_6282        2876
+#define MACH_TYPE_EM1SY                2877
+#define MACH_TYPE_M502                 2878
+#define MACH_TYPE_MATRIX518            2879
+#define MACH_TYPE_TINY_GURNARD         2880
+#define MACH_TYPE_SPEAR1310            2881
+#define MACH_TYPE_BV07                 2882
+#define MACH_TYPE_MXT_TD61             2883
+#define MACH_TYPE_OPENRD_ULTIMATE      2884
+#define MACH_TYPE_DEVIXP               2885
+#define MACH_TYPE_MICCPT               2886
+#define MACH_TYPE_MIC256               2887
+#define MACH_TYPE_AS1167               2888
+#define MACH_TYPE_OMAP3_IBIZA          2889
+#define MACH_TYPE_U5500                2890
+#define MACH_TYPE_DAVINCI_PICTO        2891
+#define MACH_TYPE_MECHA                2892
+#define MACH_TYPE_BUBBA3               2893
+#define MACH_TYPE_PUPITRE              2894
+#define MACH_TYPE_TEGRA_VOGUE          2896
+#define MACH_TYPE_TEGRA_E1165          2897
+#define MACH_TYPE_SIMPLENET            2898
+#define MACH_TYPE_EC4350TBM            2899
+#define MACH_TYPE_PEC_TC               2900
+#define MACH_TYPE_PEC_HC2              2901
+#define MACH_TYPE_ESL_MOBILIS_A        2902
+#define MACH_TYPE_ESL_MOBILIS_B        2903
+#define MACH_TYPE_ESL_WAVE_A           2904
+#define MACH_TYPE_ESL_WAVE_B           2905
+#define MACH_TYPE_UNISENSE_MMM         2906
+#define MACH_TYPE_BLUESHARK            2907
+#define MACH_TYPE_E10                  2908
+#define MACH_TYPE_APP3K_ROBIN          2909
+#define MACH_TYPE_POV15HD              2910
+#define MACH_TYPE_STELLA               2911
+#define MACH_TYPE_LINKSTATION_LSCHL    2913
+#define MACH_TYPE_NETWALKER            2914
+#define MACH_TYPE_ACSX106              2915
+#define MACH_TYPE_ATLAS5_C1            2916
+#define MACH_TYPE_NSB3AST              2917
+#define MACH_TYPE_GNET_SLC             2918
+#define MACH_TYPE_AF4000               2919
+#define MACH_TYPE_ARK9431              2920
+#define MACH_TYPE_FS_S5PC100           2921
+#define MACH_TYPE_OMAP3505NOVA8        2922
+#define MACH_TYPE_OMAP3621_EDP1        2923
+#define MACH_TYPE_ORATISAES            2924
+#define MACH_TYPE_SMDKV310             2925
+#define MACH_TYPE_SIEMENS_L0           2926
+#define MACH_TYPE_VENTANA              2927
+#define MACH_TYPE_WM8505_7IN_NETBOOK   2928
+#define MACH_TYPE_EC4350SDB            2929
+#define MACH_TYPE_MIMAS                2930
+#define MACH_TYPE_TITAN                2931
+#define MACH_TYPE_CRANEBOARD           2932
+#define MACH_TYPE_ES2440               2933
+#define MACH_TYPE_NAJAY_A9263          2934
+#define MACH_TYPE_HTCTORNADO           2935
+#define MACH_TYPE_DIMM_MX257           2936
+#define MACH_TYPE_JIGEN                2937
+#define MACH_TYPE_SMDK6450             2938
+#define MACH_TYPE_MENO_QNG             2939
+#define MACH_TYPE_NS2416               2940
+#define MACH_TYPE_RPC353               2941
+#define MACH_TYPE_TQ6410               2942
+#define MACH_TYPE_SKY6410              2943
+#define MACH_TYPE_DYNASTY              2944
+#define MACH_TYPE_VIVO                 2945
+#define MACH_TYPE_BURY_BL7582          2946
+#define MACH_TYPE_BURY_BPS5270         2947
+#define MACH_TYPE_BASI                 2948
+#define MACH_TYPE_TN200                2949
+#define MACH_TYPE_C2MMI                2950
+#define MACH_TYPE_MESON_6236M          2951
+#define MACH_TYPE_MESON_8626M          2952
+#define MACH_TYPE_TUBE                 2953
+#define MACH_TYPE_MESSINA              2954
+#define MACH_TYPE_MX50_ARM2            2955
+#define MACH_TYPE_CETUS9263            2956
+#define MACH_TYPE_BROWNSTONE           2957
+#define MACH_TYPE_VMX25                2958
+#define MACH_TYPE_VMX51                2959
+#define MACH_TYPE_ABACUS               2960
+#define MACH_TYPE_CM4745               2961
+#define MACH_TYPE_ORATISLINK           2962
+#define MACH_TYPE_DAVINCI_DM365_DVR    2963
+#define MACH_TYPE_NETVIZ               2964
+#define MACH_TYPE_FLEXIBITY            2965
+#define MACH_TYPE_WLAN_COMPUTER        2966
+#define MACH_TYPE_LPC24XX              2967
+#define MACH_TYPE_SPICA                2968
+#define MACH_TYPE_GPSDISPLAY           2969
+#define MACH_TYPE_BIPNET               2970
+#define MACH_TYPE_OVERO_CTU_INERTIAL   2971
+#define MACH_TYPE_DAVINCI_DM355_MMM    2972
+#define MACH_TYPE_PC9260_V2            2973
+#define MACH_TYPE_PTX7545              2974
+#define MACH_TYPE_TM_EFDC              2975
+#define MACH_TYPE_OMAP3_WALDO1         2977
+#define MACH_TYPE_FLYER                2978
+#define MACH_TYPE_TORNADO3240          2979
+#define MACH_TYPE_SOLI_01              2980
+#define MACH_TYPE_OMAPL138_EUROPALC    2981
+#define MACH_TYPE_HELIOS_V1            2982
+#define MACH_TYPE_NETSPACE_LITE_V2     2983
+#define MACH_TYPE_SSC                  2984
+#define MACH_TYPE_PREMIERWAVE_EN       2985
+#define MACH_TYPE_WASABI               2986
+#define MACH_TYPE_MX50_RDP             2988
+#define MACH_TYPE_UNIVERSAL_C210       2989
+#define MACH_TYPE_REAL6410             2990
+#define MACH_TYPE_SPX_SAKURA           2991
+#define MACH_TYPE_IJ3K_2440            2992
+#define MACH_TYPE_OMAP3_BC10           2993
+#define MACH_TYPE_THEBE                2994
+#define MACH_TYPE_RV082                2995
+#define MACH_TYPE_ARMLGUEST            2996
+#define MACH_TYPE_TJINC1000            2997
+#define MACH_TYPE_DOCKSTAR             2998
+#define MACH_TYPE_AX8008               2999
+#define MACH_TYPE_GNET_SGCE            3000
+#define MACH_TYPE_PXWNAS_500_1000      3001
+#define MACH_TYPE_EA20                 3002
+#define MACH_TYPE_AWM2                 3003
+#define MACH_TYPE_TI8148EVM            3004
+#define MACH_TYPE_SEABOARD             3005
+#define MACH_TYPE_LINKSTATION_CHLV2    3006
+#define MACH_TYPE_TERA_PRO2_RACK       3007
+#define MACH_TYPE_RUBYS                3008
+#define MACH_TYPE_AQUARIUS             3009
+#define MACH_TYPE_MX53_ARD             3010
+#define MACH_TYPE_MX53_SMD             3011
+#define MACH_TYPE_LSWXL                3012
+#define MACH_TYPE_DOVE_AVNG_V3         3013
+#define MACH_TYPE_SDI_ESS_9263         3014
+#define MACH_TYPE_JOCPU550             3015
+#define MACH_TYPE_MSM8X60_RUMI3        3016
+#define MACH_TYPE_MSM8X60_FFA          3017
+#define MACH_TYPE_YANOMAMI             3018
+#define MACH_TYPE_GTA04                3019
+#define MACH_TYPE_CM_A510              3020
+#define MACH_TYPE_OMAP3_RFS200         3021
+#define MACH_TYPE_KX33XX               3022
+#define MACH_TYPE_PTX7510              3023
+#define MACH_TYPE_TOP9000              3024
+#define MACH_TYPE_TEENOTE              3025
+#define MACH_TYPE_TS3                  3026
+#define MACH_TYPE_A0                   3027
+#define MACH_TYPE_FSM9XXX_SURF         3028
+#define MACH_TYPE_FSM9XXX_FFA          3029
+#define MACH_TYPE_FRRHWCDMA60W         3030
+#define MACH_TYPE_REMUS                3031
+#define MACH_TYPE_AT91CAP7XDK          3032
+#define MACH_TYPE_AT91CAP7STK          3033
+#define MACH_TYPE_KT_SBC_SAM9_1        3034
+#define MACH_TYPE_ARMADA_XP_DB         3036
+#define MACH_TYPE_SPDM                 3037
+#define MACH_TYPE_GTIB                 3038
+#define MACH_TYPE_DGM3240              3039
+#define MACH_TYPE_HTCMEGA              3041
+#define MACH_TYPE_TRICORDER            3042
+#define MACH_TYPE_TX28                 3043
+#define MACH_TYPE_BSTBRD               3044
+#define MACH_TYPE_PWB3090              3045
+#define MACH_TYPE_IDEA6410             3046
+#define MACH_TYPE_QBC9263              3047
+#define MACH_TYPE_BORABORA             3048
+#define MACH_TYPE_VALDEZ               3049
+#define MACH_TYPE_LS9G20               3050
+#define MACH_TYPE_MIOS_V1              3051
+#define MACH_TYPE_S5PC110_CRESPO       3052
+#define MACH_TYPE_CONTROLTEK9G20       3053
+#define MACH_TYPE_TIN307               3054
+#define MACH_TYPE_TIN510               3055
+#define MACH_TYPE_BLUECHEESE           3057
+#define MACH_TYPE_TEM3X30              3058
+#define MACH_TYPE_HARVEST_DESOTO       3059
+#define MACH_TYPE_MSM8X60_QRDC         3060
+#define MACH_TYPE_SPEAR900             3061
+#define MACH_TYPE_PCONTROL_G20         3062
+#define MACH_TYPE_RDSTOR               3063
+#define MACH_TYPE_USDLOADER            3064
+#define MACH_TYPE_TSOPLOADER           3065
+#define MACH_TYPE_KRONOS               3066
+#define MACH_TYPE_FFCORE               3067
+#define MACH_TYPE_MONE                 3068
+#define MACH_TYPE_UNIT2S               3069
+#define MACH_TYPE_ACER_A5              3070
+#define MACH_TYPE_ETHERPRO_ISP         3071
+#define MACH_TYPE_STRETCHS7000         3072
+#define MACH_TYPE_P87_SMARTSIM         3073
+#define MACH_TYPE_TULIP                3074
+#define MACH_TYPE_SUNFLOWER            3075
+#define MACH_TYPE_RIB                  3076
+#define MACH_TYPE_CLOD                 3077
+#define MACH_TYPE_RUMP                 3078
+#define MACH_TYPE_TENDERLOIN           3079
+#define MACH_TYPE_SHORTLOIN            3080
+#define MACH_TYPE_ANTARES              3082
+#define MACH_TYPE_WB40N                3083
+#define MACH_TYPE_HERRING              3084
+#define MACH_TYPE_NAXY400              3085
+#define MACH_TYPE_NAXY1200             3086
+#define MACH_TYPE_VPR200               3087
+#define MACH_TYPE_BUG20                3088
+#define MACH_TYPE_GOFLEXNET            3089
+#define MACH_TYPE_TORBRECK             3090
+#define MACH_TYPE_SAARB_MG1            3091
+#define MACH_TYPE_CALLISTO             3092
+#define MACH_TYPE_MULTHSU              3093
+#define MACH_TYPE_SALUDA               3094
+#define MACH_TYPE_PEMP_OMAP3_APOLLO    3095
+#define MACH_TYPE_VC0718               3096
+#define MACH_TYPE_MVBLX                3097
+#define MACH_TYPE_INHAND_APEIRON       3098
+#define MACH_TYPE_INHAND_FURY          3099
+#define MACH_TYPE_INHAND_SIREN         3100
+#define MACH_TYPE_HDNVP                3101
+#define MACH_TYPE_SOFTWINNER           3102
+#define MACH_TYPE_PRIMA2_EVB           3103
+#define MACH_TYPE_NAS6210              3104
+#define MACH_TYPE_UNISDEV              3105
+#define MACH_TYPE_SBCA11               3106
+#define MACH_TYPE_SAGA                 3107
+#define MACH_TYPE_NS_K330              3108
+#define MACH_TYPE_TANNA                3109
+#define MACH_TYPE_IMATE8502            3110
+#define MACH_TYPE_ASPEN                3111
+#define MACH_TYPE_DAINTREE_CWAC        3112
+#define MACH_TYPE_ZMX25                3113
+#define MACH_TYPE_MAPLE1               3114
+#define MACH_TYPE_QSD8X72_SURF         3115
+#define MACH_TYPE_QSD8X72_FFA          3116
+#define MACH_TYPE_ABILENE              3117
+#define MACH_TYPE_EIGEN_TTR            3118
+#define MACH_TYPE_IOMEGA_IX2_200       3119
+#define MACH_TYPE_CORETEC_VCX7400      3120
+#define MACH_TYPE_SANTIAGO             3121
+#define MACH_TYPE_MX257SOL             3122
+#define MACH_TYPE_STRASBOURG           3123
+#define MACH_TYPE_MSM8X60_FLUID        3124
+#define MACH_TYPE_SMARTQV5             3125
+#define MACH_TYPE_SMARTQV3             3126
+#define MACH_TYPE_SMARTQV7             3127
+#define MACH_TYPE_PAZ00                3128
+#define MACH_TYPE_ACMENETUSFOXG20      3129
+#define MACH_TYPE_FWBD_0404            3131
+#define MACH_TYPE_HDGU                 3132
+#define MACH_TYPE_PYRAMID              3133
+#define MACH_TYPE_EPIPHAN              3134
+#define MACH_TYPE_OMAP_BENDER          3135
+#define MACH_TYPE_GURNARD              3136
+#define MACH_TYPE_GTL_IT5100           3137
+#define MACH_TYPE_BCM2708              3138
+#define MACH_TYPE_MX51_GGC             3139
+#define MACH_TYPE_SHARESPACE           3140
+#define MACH_TYPE_HABA_KNX_EXPLORER    3141
+#define MACH_TYPE_SIMTEC_KIRKMOD       3142
+#define MACH_TYPE_CRUX                 3143
+#define MACH_TYPE_MX51_BRAVO           3144
+#define MACH_TYPE_CHARON               3145
+#define MACH_TYPE_PICOCOM3             3146
+#define MACH_TYPE_PICOCOM4             3147
+#define MACH_TYPE_SERRANO              3148
+#define MACH_TYPE_DOUBLESHOT           3149
+#define MACH_TYPE_EVSY                 3150
+#define MACH_TYPE_HUASHAN              3151
+#define MACH_TYPE_LAUSANNE             3152
+#define MACH_TYPE_EMERALD              3153
+#define MACH_TYPE_TQMA35               3154
+#define MACH_TYPE_MARVEL               3155
+#define MACH_TYPE_MANUAE               3156
+#define MACH_TYPE_CHACHA               3157
+#define MACH_TYPE_LEMON                3158
+#define MACH_TYPE_CSC                  3159
+#define MACH_TYPE_GIRA_KNXIP_ROUTER    3160
+#define MACH_TYPE_T20                  3161
+#define MACH_TYPE_HDMINI               3162
+#define MACH_TYPE_SCIPHONE_G2          3163
+#define MACH_TYPE_EXPRESS              3164
+#define MACH_TYPE_EXPRESS_KT           3165
+#define MACH_TYPE_MAXIMASP             3166
+#define MACH_TYPE_NITROGEN_IMX51       3167
+#define MACH_TYPE_NITROGEN_IMX53       3168
+#define MACH_TYPE_SUNFIRE              3169
+#define MACH_TYPE_AROWANA              3170
+#define MACH_TYPE_TEGRA_DAYTONA        3171
+#define MACH_TYPE_TEGRA_SWORDFISH      3172
+#define MACH_TYPE_EDISON               3173
+#define MACH_TYPE_SVP8500V1            3174
+#define MACH_TYPE_SVP8500V2            3175
+#define MACH_TYPE_SVP5500              3176
+#define MACH_TYPE_B5500                3177
+#define MACH_TYPE_S5500                3178
+#define MACH_TYPE_ICON                 3179
+#define MACH_TYPE_ELEPHANT             3180
+#define MACH_TYPE_SHOOTER              3182
+#define MACH_TYPE_SPADE_LTE            3183
+#define MACH_TYPE_PHILHWANI            3184
+#define MACH_TYPE_GSNCOMM              3185
+#define MACH_TYPE_STRASBOURG_A2        3186
+#define MACH_TYPE_MMM                  3187
+#define MACH_TYPE_DAVINCI_DM365_BV     3188
+#define MACH_TYPE_AG5EVM               3189
+#define MACH_TYPE_SC575PLC             3190
+#define MACH_TYPE_SC575IPC             3191
+#define MACH_TYPE_OMAP3_TDM3730        3192
+#define MACH_TYPE_TOP9000_EVAL         3194
+#define MACH_TYPE_TOP9000_SU           3195
+#define MACH_TYPE_UTM300               3196
+#define MACH_TYPE_TSUNAGI              3197
+#define MACH_TYPE_TS75XX               3198
+#define MACH_TYPE_TS47XX               3200
+#define MACH_TYPE_DA850_K5             3201
+#define MACH_TYPE_AX502                3202
+#define MACH_TYPE_IGEP0032             3203
+#define MACH_TYPE_ANTERO               3204
+#define MACH_TYPE_SYNERGY              3205
+#define MACH_TYPE_ICS_IF_VOIP          3206
+#define MACH_TYPE_WLF_CRAGG_6410       3207
+#define MACH_TYPE_PUNICA               3208
+#define MACH_TYPE_TRIMSLICE            3209
+#define MACH_TYPE_MX27_WMULTRA         3210
+#define MACH_TYPE_MACKEREL             3211
+#define MACH_TYPE_FA9X27               3213
+#define MACH_TYPE_NS2816TB             3214
+#define MACH_TYPE_NS2816_NTPAD         3215
+#define MACH_TYPE_NS2816_NTNB          3216
+#define MACH_TYPE_KAEN                 3217
+#define MACH_TYPE_NV1000               3218
+#define MACH_TYPE_NUC950TS             3219
+#define MACH_TYPE_NOKIA_RM680          3220
+#define MACH_TYPE_AST2200              3221
+#define MACH_TYPE_LEAD                 3222
+#define MACH_TYPE_UNINO1               3223
+#define MACH_TYPE_GREECO               3224
+#define MACH_TYPE_VERDI                3225
+#define MACH_TYPE_DM6446_ADBOX         3226
+#define MACH_TYPE_QUAD_SALSA           3227
+#define MACH_TYPE_ABB_GMA_1_1          3228
+#define MACH_TYPE_SVCID                3229
+#define MACH_TYPE_MSM8960_SIM          3230
+#define MACH_TYPE_MSM8960_RUMI3        3231
+#define MACH_TYPE_ICON_G               3232
+#define MACH_TYPE_MB3                  3233
+#define MACH_TYPE_GSIA18S              3234
+#define MACH_TYPE_PIVICC               3235
+#define MACH_TYPE_PCM048               3236
+#define MACH_TYPE_DDS                  3237
+#define MACH_TYPE_CHALTEN_XA1          3238
+#define MACH_TYPE_TS48XX               3239
+#define MACH_TYPE_TONGA2_TFTTIMER      3240
+#define MACH_TYPE_WHISTLER             3241
+#define MACH_TYPE_ASL_PHOENIX          3242
+#define MACH_TYPE_AT91SAM9263OTLITE    3243
+#define MACH_TYPE_DDPLUG               3244
+#define MACH_TYPE_D2PLUG               3245
+#define MACH_TYPE_KZM9D                3246
+#define MACH_TYPE_VERDI_LTE            3247
+#define MACH_TYPE_NANOZOOM             3248
+#define MACH_TYPE_DM3730_SOM_LV        3249
+#define MACH_TYPE_DM3730_TORPEDO       3250
+#define MACH_TYPE_ANCHOVY              3251
+#define MACH_TYPE_RE2REV20             3253
+#define MACH_TYPE_RE2REV21             3254
+#define MACH_TYPE_CNS21XX              3255
+#define MACH_TYPE_RIDER                3257
+#define MACH_TYPE_NSK330               3258
+#define MACH_TYPE_CNS2133EVB           3259
+#define MACH_TYPE_Z3_816X_MOD          3260
+#define MACH_TYPE_Z3_814X_MOD          3261
+#define MACH_TYPE_BEECT                3262
+#define MACH_TYPE_DMA_THUNDERBUG       3263
+#define MACH_TYPE_OMN_AT91SAM9G20      3264
+#define MACH_TYPE_MX25_E2S_UC          3265
+#define MACH_TYPE_MIONE                3266
+#define MACH_TYPE_TOP9000_TCU          3267
+#define MACH_TYPE_TOP9000_BSL          3268
+#define MACH_TYPE_KINGDOM              3269
+#define MACH_TYPE_ARMADILLO460         3270
+#define MACH_TYPE_LQ2                  3271
+#define MACH_TYPE_SWEDA_TMS2           3272
+#define MACH_TYPE_MX53_LOCO            3273
+#define MACH_TYPE_ACER_A8              3275
+#define MACH_TYPE_ACER_GAUGUIN         3276
+#define MACH_TYPE_GUPPY                3277
+#define MACH_TYPE_MX61_ARD             3278
+#define MACH_TYPE_TX53                 3279
+#define MACH_TYPE_OMAPL138_CASE_A3     3280
+#define MACH_TYPE_UEMD                 3281
+#define MACH_TYPE_CCWMX51MUT           3282
+#define MACH_TYPE_ROCKHOPPER           3283
+#define MACH_TYPE_NOOKCOLOR            3284
+#define MACH_TYPE_HKDKC100             3285
+#define MACH_TYPE_TS42XX               3286
+#define MACH_TYPE_AEBL                 3287
+#define MACH_TYPE_WARIO                3288
+#define MACH_TYPE_GFS_SPM              3289
+#define MACH_TYPE_CM_T3730             3290
+#define MACH_TYPE_ISC3                 3291
+#define MACH_TYPE_RASCAL               3292
+#define MACH_TYPE_HREFV60              3293
+#define MACH_TYPE_TPT_2_0              3294
+#define MACH_TYPE_SPLENDOR             3296
+#define MACH_TYPE_MSM8X60_QT           3298
+#define MACH_TYPE_HTC_HD_MINI          3299
+#define MACH_TYPE_ATHENE               3300
+#define MACH_TYPE_DEEP_R_EK_1          3301
+#define MACH_TYPE_VIVOW_CT             3302
+#define MACH_TYPE_NERY_1000            3303
+#define MACH_TYPE_RFL109145_SSRV       3304
+#define MACH_TYPE_NMH                  3305
+#define MACH_TYPE_WN802T               3306
+#define MACH_TYPE_DRAGONET             3307
+#define MACH_TYPE_AT91SAM9263DESK16L   3309
+#define MACH_TYPE_BCMHANA_SV           3310
+#define MACH_TYPE_BCMHANA_TABLET       3311
+#define MACH_TYPE_KOI                  3312
+#define MACH_TYPE_TS4800               3313
+#define MACH_TYPE_TQMA9263             3314
+#define MACH_TYPE_HOLIDAY              3315
+#define MACH_TYPE_DMA6410              3316
+#define MACH_TYPE_PCATS_OVERLAY        3317
+#define MACH_TYPE_HWGW6410             3318
+#define MACH_TYPE_SHENZHOU             3319
+#define MACH_TYPE_CWME9210             3320
+#define MACH_TYPE_CWME9210JS           3321
+#define MACH_TYPE_PGS_SITARA           3322
+#define MACH_TYPE_COLIBRI_TEGRA2       3323
+#define MACH_TYPE_W21                  3324
+#define MACH_TYPE_POLYSAT1             3325
+#define MACH_TYPE_DATAWAY              3326
+#define MACH_TYPE_COBRAL138            3327
+#define MACH_TYPE_ROVERPCS8            3328
+#define MACH_TYPE_MARVELC              3329
+#define MACH_TYPE_NAVEFIHID            3330
+#define MACH_TYPE_DM365_CV100          3331
+#define MACH_TYPE_ABLE                 3332
+#define MACH_TYPE_LEGACY               3333
+#define MACH_TYPE_ICONG                3334
+#define MACH_TYPE_ROVER_G8             3335
+#define MACH_TYPE_T5388P               3336
+#define MACH_TYPE_DINGO                3337
+#define MACH_TYPE_GOFLEXHOME           3338
+#define MACH_TYPE_LANREADYFN511        3340
+#define MACH_TYPE_OMAP3_BAIA           3341
+#define MACH_TYPE_OMAP3SMARTDISPLAY    3342
+#define MACH_TYPE_XILINX               3343
+#define MACH_TYPE_A2F                  3344
+#define MACH_TYPE_SKY25                3345
+#define MACH_TYPE_CCMX53               3346
+#define MACH_TYPE_CCMX53JS             3347
+#define MACH_TYPE_CCWMX53              3348
+#define MACH_TYPE_CCWMX53JS            3349
+#define MACH_TYPE_FRISMS               3350
+#define MACH_TYPE_MSM7X27A_FFA         3351
+#define MACH_TYPE_MSM7X27A_SURF        3352
+#define MACH_TYPE_MSM7X27A_RUMI3       3353
+#define MACH_TYPE_DIMMSAM9G20          3354
+#define MACH_TYPE_DIMM_IMX28           3355
+#define MACH_TYPE_AMK_A4               3356
+#define MACH_TYPE_GNET_SGME            3357
+#define MACH_TYPE_SHOOTER_U            3358
+#define MACH_TYPE_VMX53                3359
+#define MACH_TYPE_RHINO                3360
+#define MACH_TYPE_ARMLEX4210           3361
+#define MACH_TYPE_SWARCOEXTMODEM       3362
+#define MACH_TYPE_SNOWBALL             3363
+#define MACH_TYPE_PCM049               3364
+#define MACH_TYPE_VIGOR                3365
+#define MACH_TYPE_OSLO_AMUNDSEN        3366
+#define MACH_TYPE_GSL_DIAMOND          3367
+#define MACH_TYPE_CV2201               3368
+#define MACH_TYPE_CV2202               3369
+#define MACH_TYPE_CV2203               3370
+#define MACH_TYPE_VIT_IBOX             3371
+#define MACH_TYPE_DM6441_ESP           3372
+#define MACH_TYPE_AT91SAM9X5EK         3373
+#define MACH_TYPE_LIBRA                3374
+#define MACH_TYPE_EASYCRRH             3375
+#define MACH_TYPE_TRIPEL               3376
+#define MACH_TYPE_ENDIAN_MINI          3377
+#define MACH_TYPE_XILINX_EP107         3378
+#define MACH_TYPE_NURI                 3379
+#define MACH_TYPE_JANUS                3380
+#define MACH_TYPE_DDNAS                3381
+#define MACH_TYPE_U1HD                 3381
+#define MACH_TYPE_TAG                  3382
+#define MACH_TYPE_TAGW                 3383
+#define MACH_TYPE_NITROGEN_VM_IMX51    3384
+#define MACH_TYPE_VIPRINET             3385
+#define MACH_TYPE_BOCKW                3386
+#define MACH_TYPE_EVA2000              3387
+#define MACH_TYPE_STEELYARD            3388
+#define MACH_TYPE_MACH_SDH001          3390
+#define MACH_TYPE_NSSLSBOARD           3392
+#define MACH_TYPE_GENEVA_B5            3393
+#define MACH_TYPE_SPEAR1340            3394
+#define MACH_TYPE_REXMAS               3395
+#define MACH_TYPE_MSM8960_CDP          3396
+#define MACH_TYPE_MSM8960_MDP          3397
+#define MACH_TYPE_MSM8960_FLUID        3398
+#define MACH_TYPE_MSM8960_APQ          3399
+#define MACH_TYPE_HELIOS_V2            3400
+#define MACH_TYPE_MIF10P               3401
+#define MACH_TYPE_IAM28                3402
+#define MACH_TYPE_PICASSO              3403
+#define MACH_TYPE_MR301A               3404
+#define MACH_TYPE_NOTLE                3405
+#define MACH_TYPE_EELX2                3406
+#define MACH_TYPE_MOON                 3407
+#define MACH_TYPE_RUBY                 3408
+#define MACH_TYPE_GOLDENGATE           3409
+#define MACH_TYPE_CTBU_GEN2            3410
+#define MACH_TYPE_KMP_AM17_01          3411
+#define MACH_TYPE_WTPLUG               3412
+#define MACH_TYPE_MX27SU2              3413
+#define MACH_TYPE_NB31                 3414
+#define MACH_TYPE_HJSDU                3415
+#define MACH_TYPE_TD3_REV1             3416
+#define MACH_TYPE_EAG_CI4000           3417
+#define MACH_TYPE_NET5BIG_NAND_V2      3418
+#define MACH_TYPE_CPX2                 3419
+#define MACH_TYPE_NET2BIG_NAND_V2      3420
+#define MACH_TYPE_ECUV5                3421
+#define MACH_TYPE_HSGX6D               3422
+#define MACH_TYPE_DAWAD7               3423
+#define MACH_TYPE_SAM9REPEATER         3424
+#define MACH_TYPE_GT_I5700             3425
+#define MACH_TYPE_CTERA_PLUG_C2        3426
+#define MACH_TYPE_MARVELCT             3427
+#define MACH_TYPE_AG11005              3428
+#define MACH_TYPE_VANGOGH              3430
+#define MACH_TYPE_MATRIX505            3431
+#define MACH_TYPE_OCE_NIGMA            3432
+#define MACH_TYPE_T55                  3433
+#define MACH_TYPE_BIO3K                3434
+#define MACH_TYPE_EXPRESSCT            3435
+#define MACH_TYPE_CARDHU               3436
+#define MACH_TYPE_ARUBA                3437
+#define MACH_TYPE_BONAIRE              3438
+#define MACH_TYPE_NUC700EVB            3439
+#define MACH_TYPE_NUC710EVB            3440
+#define MACH_TYPE_NUC740EVB            3441
+#define MACH_TYPE_NUC745EVB            3442
+#define MACH_TYPE_TRANSCEDE            3443
+#define MACH_TYPE_MORA                 3444
+#define MACH_TYPE_NDA_EVM              3445
+#define MACH_TYPE_TIMU                 3446
+#define MACH_TYPE_EXPRESSH             3447
+#define MACH_TYPE_VERIDIS_A300         3448
+#define MACH_TYPE_DM368_LEOPARD        3449
+#define MACH_TYPE_OMAP_MCOP            3450
+#define MACH_TYPE_TRITIP               3451
+#define MACH_TYPE_SM1K                 3452
+#define MACH_TYPE_MONCH                3453
+#define MACH_TYPE_CURACAO              3454
+#define MACH_TYPE_ORIGEN               3455
+#define MACH_TYPE_EPC10                3456
+#define MACH_TYPE_SGH_I740             3457
+#define MACH_TYPE_TUNA                 3458
+#define MACH_TYPE_MX51_TULIP           3459
+#define MACH_TYPE_MX51_ASTER7          3460
+#define MACH_TYPE_ACRO37XBRD           3461
+#define MACH_TYPE_ELKE                 3462
+#define MACH_TYPE_SBC6000X             3463
+#define MACH_TYPE_R1801E               3464
+#define MACH_TYPE_H1600                3465
+#define MACH_TYPE_MINI210              3466
+#define MACH_TYPE_MINI8168             3467
+#define MACH_TYPE_PC7308               3468
+#define MACH_TYPE_KMM2M01              3470
+#define MACH_TYPE_MX51EREBUS           3471
+#define MACH_TYPE_WM8650REFBOARD       3472
+#define MACH_TYPE_TUXRAIL              3473
+#define MACH_TYPE_ARTHUR               3474
+#define MACH_TYPE_DOORBOY              3475
+#define MACH_TYPE_XARINA               3476
+#define MACH_TYPE_ROVERX7              3477
+#define MACH_TYPE_SDVR                 3478
+#define MACH_TYPE_ACER_MAYA            3479
+#define MACH_TYPE_PICO                 3480
+#define MACH_TYPE_CWMX233              3481
+#define MACH_TYPE_CWAM1808             3482
+#define MACH_TYPE_CWDM365              3483
+#define MACH_TYPE_MX51_MORAY           3484
+#define MACH_TYPE_THALES_CBC           3485
+#define MACH_TYPE_BLUEPOINT            3486
+#define MACH_TYPE_DIR665               3487
+#define MACH_TYPE_ACMEROVER1           3488
+#define MACH_TYPE_SHOOTER_CT           3489
+#define MACH_TYPE_BLISS                3490
+#define MACH_TYPE_BLISSC               3491
+#define MACH_TYPE_THALES_ADC           3492
+#define MACH_TYPE_UBISYS_P9D_EVP       3493
+#define MACH_TYPE_ATDGP318             3494
+#define MACH_TYPE_SMDK4212             3698
+#define MACH_TYPE_SMDK4412             3765
+#define MACH_TYPE_SLP_PQ               3766
+#define MACH_TYPE_SLP_PQ_LTE           3767
+#define MACH_TYPE_SMDK5210             3774
+#define MACH_TYPE_SMDK5250             3825
+#define MACH_TYPE_TRATS                3928
+#define MACH_TYPE_REDWOOD              3768
+#define MACH_TYPE_SLP_T0_LTE           3769
+
+#ifdef CONFIG_ARCH_EBSA110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EBSA110
+# endif
+# define machine_is_ebsa110()	(machine_arch_type == MACH_TYPE_EBSA110)
+#else
+# define machine_is_ebsa110()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_RPC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RISCPC
+# endif
+# define machine_is_riscpc()	(machine_arch_type == MACH_TYPE_RISCPC)
+#else
+# define machine_is_riscpc()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_EBSA285
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EBSA285
+# endif
+# define machine_is_ebsa285()	(machine_arch_type == MACH_TYPE_EBSA285)
+#else
+# define machine_is_ebsa285()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_NETWINDER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETWINDER
+# endif
+# define machine_is_netwinder()	(machine_arch_type == MACH_TYPE_NETWINDER)
+#else
+# define machine_is_netwinder()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CATS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CATS
+# endif
+# define machine_is_cats()	(machine_arch_type == MACH_TYPE_CATS)
+#else
+# define machine_is_cats()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SHARK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHARK
+# endif
+# define machine_is_shark()	(machine_arch_type == MACH_TYPE_SHARK)
+#else
+# define machine_is_shark()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BRUTUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BRUTUS
+# endif
+# define machine_is_brutus()	(machine_arch_type == MACH_TYPE_BRUTUS)
+#else
+# define machine_is_brutus()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PERSONAL_SERVER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PERSONAL_SERVER
+# endif
+# define machine_is_personal_server()	(machine_arch_type == MACH_TYPE_PERSONAL_SERVER)
+#else
+# define machine_is_personal_server()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_L7200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_L7200
+# endif
+# define machine_is_l7200()	(machine_arch_type == MACH_TYPE_L7200)
+#else
+# define machine_is_l7200()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PLEB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PLEB
+# endif
+# define machine_is_pleb()	(machine_arch_type == MACH_TYPE_PLEB)
+#else
+# define machine_is_pleb()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_INTEGRATOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INTEGRATOR
+# endif
+# define machine_is_integrator()	(machine_arch_type == MACH_TYPE_INTEGRATOR)
+#else
+# define machine_is_integrator()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_H3600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H3600
+# endif
+# define machine_is_h3600()	(machine_arch_type == MACH_TYPE_H3600)
+#else
+# define machine_is_h3600()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_P720T
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_P720T
+# endif
+# define machine_is_p720t()	(machine_arch_type == MACH_TYPE_P720T)
+#else
+# define machine_is_p720t()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ASSABET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASSABET
+# endif
+# define machine_is_assabet()	(machine_arch_type == MACH_TYPE_ASSABET)
+#else
+# define machine_is_assabet()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_LART
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LART
+# endif
+# define machine_is_lart()	(machine_arch_type == MACH_TYPE_LART)
+#else
+# define machine_is_lart()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_GRAPHICSCLIENT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GRAPHICSCLIENT
+# endif
+# define machine_is_graphicsclient()	(machine_arch_type == MACH_TYPE_GRAPHICSCLIENT)
+#else
+# define machine_is_graphicsclient()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_XP860
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XP860
+# endif
+# define machine_is_xp860()	(machine_arch_type == MACH_TYPE_XP860)
+#else
+# define machine_is_xp860()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_CERF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CERF
+# endif
+# define machine_is_cerf()	(machine_arch_type == MACH_TYPE_CERF)
+#else
+# define machine_is_cerf()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_NANOENGINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NANOENGINE
+# endif
+# define machine_is_nanoengine()	(machine_arch_type == MACH_TYPE_NANOENGINE)
+#else
+# define machine_is_nanoengine()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_JORNADA720
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JORNADA720
+# endif
+# define machine_is_jornada720()	(machine_arch_type == MACH_TYPE_JORNADA720)
+#else
+# define machine_is_jornada720()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_EDB7211
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB7211
+# endif
+# define machine_is_edb7211()	(machine_arch_type == MACH_TYPE_EDB7211)
+#else
+# define machine_is_edb7211()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PFS168
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PFS168
+# endif
+# define machine_is_pfs168()	(machine_arch_type == MACH_TYPE_PFS168)
+#else
+# define machine_is_pfs168()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_FLEXANET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FLEXANET
+# endif
+# define machine_is_flexanet()	(machine_arch_type == MACH_TYPE_FLEXANET)
+#else
+# define machine_is_flexanet()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SIMPAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIMPAD
+# endif
+# define machine_is_simpad()	(machine_arch_type == MACH_TYPE_SIMPAD)
+#else
+# define machine_is_simpad()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_LUBBOCK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LUBBOCK
+# endif
+# define machine_is_lubbock()	(machine_arch_type == MACH_TYPE_LUBBOCK)
+#else
+# define machine_is_lubbock()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CLEP7212
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CLEP7212
+# endif
+# define machine_is_clep7212()	(machine_arch_type == MACH_TYPE_CLEP7212)
+#else
+# define machine_is_clep7212()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_SHANNON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHANNON
+# endif
+# define machine_is_shannon()	(machine_arch_type == MACH_TYPE_SHANNON)
+#else
+# define machine_is_shannon()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_CONSUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CONSUS
+# endif
+# define machine_is_consus()	(machine_arch_type == MACH_TYPE_CONSUS)
+#else
+# define machine_is_consus()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AAED2000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AAED2000
+# endif
+# define machine_is_aaed2000()	(machine_arch_type == MACH_TYPE_AAED2000)
+#else
+# define machine_is_aaed2000()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CDB89712
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CDB89712
+# endif
+# define machine_is_cdb89712()	(machine_arch_type == MACH_TYPE_CDB89712)
+#else
+# define machine_is_cdb89712()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_GRAPHICSMASTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GRAPHICSMASTER
+# endif
+# define machine_is_graphicsmaster()	(machine_arch_type == MACH_TYPE_GRAPHICSMASTER)
+#else
+# define machine_is_graphicsmaster()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_ADSBITSY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSBITSY
+# endif
+# define machine_is_adsbitsy()	(machine_arch_type == MACH_TYPE_ADSBITSY)
+#else
+# define machine_is_adsbitsy()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_PXA_IDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXA_IDP
+# endif
+# define machine_is_pxa_idp()	(machine_arch_type == MACH_TYPE_PXA_IDP)
+#else
+# define machine_is_pxa_idp()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_PT_SYSTEM3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PT_SYSTEM3
+# endif
+# define machine_is_pt_system3()	(machine_arch_type == MACH_TYPE_PT_SYSTEM3)
+#else
+# define machine_is_pt_system3()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AUTCPU12
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AUTCPU12
+# endif
+# define machine_is_autcpu12()	(machine_arch_type == MACH_TYPE_AUTCPU12)
+#else
+# define machine_is_autcpu12()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_H3100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H3100
+# endif
+# define machine_is_h3100()	(machine_arch_type == MACH_TYPE_H3100)
+#else
+# define machine_is_h3100()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_COLLIE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COLLIE
+# endif
+# define machine_is_collie()	(machine_arch_type == MACH_TYPE_COLLIE)
+#else
+# define machine_is_collie()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_BADGE4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BADGE4
+# endif
+# define machine_is_badge4()	(machine_arch_type == MACH_TYPE_BADGE4)
+#else
+# define machine_is_badge4()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_FORTUNET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FORTUNET
+# endif
+# define machine_is_fortunet()	(machine_arch_type == MACH_TYPE_FORTUNET)
+#else
+# define machine_is_fortunet()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_MX1ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX1ADS
+# endif
+# define machine_is_mx1ads()	(machine_arch_type == MACH_TYPE_MX1ADS)
+#else
+# define machine_is_mx1ads()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H7201
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H7201
+# endif
+# define machine_is_h7201()	(machine_arch_type == MACH_TYPE_H7201)
+#else
+# define machine_is_h7201()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H7202
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H7202
+# endif
+# define machine_is_h7202()	(machine_arch_type == MACH_TYPE_H7202)
+#else
+# define machine_is_h7202()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IQ80321
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ80321
+# endif
+# define machine_is_iq80321()	(machine_arch_type == MACH_TYPE_IQ80321)
+#else
+# define machine_is_iq80321()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_KS8695
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KS8695
+# endif
+# define machine_is_ks8695()	(machine_arch_type == MACH_TYPE_KS8695)
+#else
+# define machine_is_ks8695()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_SMDK2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2410
+# endif
+# define machine_is_smdk2410()	(machine_arch_type == MACH_TYPE_SMDK2410)
+#else
+# define machine_is_smdk2410()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CEIVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CEIVA
+# endif
+# define machine_is_ceiva()	(machine_arch_type == MACH_TYPE_CEIVA)
+#else
+# define machine_is_ceiva()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VOICEBLUE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VOICEBLUE
+# endif
+# define machine_is_voiceblue()	(machine_arch_type == MACH_TYPE_VOICEBLUE)
+#else
+# define machine_is_voiceblue()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H5400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H5400
+# endif
+# define machine_is_h5400()	(machine_arch_type == MACH_TYPE_H5400)
+#else
+# define machine_is_h5400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_INNOVATOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_INNOVATOR
+# endif
+# define machine_is_omap_innovator()	(machine_arch_type == MACH_TYPE_OMAP_INNOVATOR)
+#else
+# define machine_is_omap_innovator()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP2400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2400
+# endif
+# define machine_is_ixdp2400()	(machine_arch_type == MACH_TYPE_IXDP2400)
+#else
+# define machine_is_ixdp2400()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP2800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2800
+# endif
+# define machine_is_ixdp2800()	(machine_arch_type == MACH_TYPE_IXDP2800)
+#else
+# define machine_is_ixdp2800()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP425
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP425
+# endif
+# define machine_is_ixdp425()	(machine_arch_type == MACH_TYPE_IXDP425)
+#else
+# define machine_is_ixdp425()	(0)
+#endif
+
+#ifdef CONFIG_SA1100_HACKKIT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HACKKIT
+# endif
+# define machine_is_hackkit()	(machine_arch_type == MACH_TYPE_HACKKIT)
+#else
+# define machine_is_hackkit()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXCDP1100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXCDP1100
+# endif
+# define machine_is_ixcdp1100()	(machine_arch_type == MACH_TYPE_IXCDP1100)
+#else
+# define machine_is_ixcdp1100()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_AT91RM9200DK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200DK
+# endif
+# define machine_is_at91rm9200dk()	(machine_arch_type == MACH_TYPE_AT91RM9200DK)
+#else
+# define machine_is_at91rm9200dk()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_CINTEGRATOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CINTEGRATOR
+# endif
+# define machine_is_cintegrator()	(machine_arch_type == MACH_TYPE_CINTEGRATOR)
+#else
+# define machine_is_cintegrator()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_VIPER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VIPER
+# endif
+# define machine_is_viper()	(machine_arch_type == MACH_TYPE_VIPER)
+#else
+# define machine_is_viper()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ADI_COYOTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADI_COYOTE
+# endif
+# define machine_is_adi_coyote()	(machine_arch_type == MACH_TYPE_ADI_COYOTE)
+#else
+# define machine_is_adi_coyote()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP2401
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2401
+# endif
+# define machine_is_ixdp2401()	(machine_arch_type == MACH_TYPE_IXDP2401)
+#else
+# define machine_is_ixdp2401()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IXDP2801
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2801
+# endif
+# define machine_is_ixdp2801()	(machine_arch_type == MACH_TYPE_IXDP2801)
+#else
+# define machine_is_ixdp2801()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IQ31244
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ31244
+# endif
+# define machine_is_iq31244()	(machine_arch_type == MACH_TYPE_IQ31244)
+#else
+# define machine_is_iq31244()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_BAST
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BAST
+# endif
+# define machine_is_bast()	(machine_arch_type == MACH_TYPE_BAST)
+#else
+# define machine_is_bast()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_H1940
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H1940
+# endif
+# define machine_is_h1940()	(machine_arch_type == MACH_TYPE_H1940)
+#else
+# define machine_is_h1940()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_ENP2611
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENP2611
+# endif
+# define machine_is_enp2611()	(machine_arch_type == MACH_TYPE_ENP2611)
+#else
+# define machine_is_enp2611()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_S3C2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2440
+# endif
+# define machine_is_s3c2440()	(machine_arch_type == MACH_TYPE_S3C2440)
+#else
+# define machine_is_s3c2440()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_GUMSTIX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GUMSTIX
+# endif
+# define machine_is_gumstix()	(machine_arch_type == MACH_TYPE_GUMSTIX)
+#else
+# define machine_is_gumstix()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_H2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_H2
+# endif
+# define machine_is_omap_h2()	(machine_arch_type == MACH_TYPE_OMAP_H2)
+#else
+# define machine_is_omap_h2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E740
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E740
+# endif
+# define machine_is_e740()	(machine_arch_type == MACH_TYPE_E740)
+#else
+# define machine_is_e740()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_IQ80331
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ80331
+# endif
+# define machine_is_iq80331()	(machine_arch_type == MACH_TYPE_IQ80331)
+#else
+# define machine_is_iq80331()	(0)
+#endif
+
+#ifdef CONFIG_ARCH_VERSATILE_PB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VERSATILE_PB
+# endif
+# define machine_is_versatile_pb()	(machine_arch_type == MACH_TYPE_VERSATILE_PB)
+#else
+# define machine_is_versatile_pb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KEV7A400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KEV7A400
+# endif
+# define machine_is_kev7a400()	(machine_arch_type == MACH_TYPE_KEV7A400)
+#else
+# define machine_is_kev7a400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPD7A400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPD7A400
+# endif
+# define machine_is_lpd7a400()	(machine_arch_type == MACH_TYPE_LPD7A400)
+#else
+# define machine_is_lpd7a400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPD7A404
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPD7A404
+# endif
+# define machine_is_lpd7a404()	(machine_arch_type == MACH_TYPE_LPD7A404)
+#else
+# define machine_is_lpd7a404()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB337
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB337
+# endif
+# define machine_is_csb337()	(machine_arch_type == MACH_TYPE_CSB337)
+#else
+# define machine_is_csb337()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAINSTONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAINSTONE
+# endif
+# define machine_is_mainstone()	(machine_arch_type == MACH_TYPE_MAINSTONE)
+#else
+# define machine_is_mainstone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XCEP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XCEP
+# endif
+# define machine_is_xcep()	(machine_arch_type == MACH_TYPE_XCEP)
+#else
+# define machine_is_xcep()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARCOM_VULCAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARCOM_VULCAN
+# endif
+# define machine_is_arcom_vulcan()	(machine_arch_type == MACH_TYPE_ARCOM_VULCAN)
+#else
+# define machine_is_arcom_vulcan()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOMADIK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOMADIK
+# endif
+# define machine_is_nomadik()	(machine_arch_type == MACH_TYPE_NOMADIK)
+#else
+# define machine_is_nomadik()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CORGI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CORGI
+# endif
+# define machine_is_corgi()	(machine_arch_type == MACH_TYPE_CORGI)
+#else
+# define machine_is_corgi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_POODLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POODLE
+# endif
+# define machine_is_poodle()	(machine_arch_type == MACH_TYPE_POODLE)
+#else
+# define machine_is_poodle()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMCORE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMCORE
+# endif
+# define machine_is_armcore()	(machine_arch_type == MACH_TYPE_ARMCORE)
+#else
+# define machine_is_armcore()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX31ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX31ADS
+# endif
+# define machine_is_mx31ads()	(machine_arch_type == MACH_TYPE_MX31ADS)
+#else
+# define machine_is_mx31ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HIMALAYA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HIMALAYA
+# endif
+# define machine_is_himalaya()	(machine_arch_type == MACH_TYPE_HIMALAYA)
+#else
+# define machine_is_himalaya()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9312
+# endif
+# define machine_is_edb9312()	(machine_arch_type == MACH_TYPE_EDB9312)
+#else
+# define machine_is_edb9312()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_GENERIC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_GENERIC
+# endif
+# define machine_is_omap_generic()	(machine_arch_type == MACH_TYPE_OMAP_GENERIC)
+#else
+# define machine_is_omap_generic()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9301
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9301
+# endif
+# define machine_is_edb9301()	(machine_arch_type == MACH_TYPE_EDB9301)
+#else
+# define machine_is_edb9301()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9315
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9315
+# endif
+# define machine_is_edb9315()	(machine_arch_type == MACH_TYPE_EDB9315)
+#else
+# define machine_is_edb9315()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VR1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VR1000
+# endif
+# define machine_is_vr1000()	(machine_arch_type == MACH_TYPE_VR1000)
+#else
+# define machine_is_vr1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PERSEUS2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PERSEUS2
+# endif
+# define machine_is_omap_perseus2()	(machine_arch_type == MACH_TYPE_OMAP_PERSEUS2)
+#else
+# define machine_is_omap_perseus2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E800
+# endif
+# define machine_is_e800()	(machine_arch_type == MACH_TYPE_E800)
+#else
+# define machine_is_e800()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E750
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E750
+# endif
+# define machine_is_e750()	(machine_arch_type == MACH_TYPE_E750)
+#else
+# define machine_is_e750()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SCB9328
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SCB9328
+# endif
+# define machine_is_scb9328()	(machine_arch_type == MACH_TYPE_SCB9328)
+#else
+# define machine_is_scb9328()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_H3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_H3
+# endif
+# define machine_is_omap_h3()	(machine_arch_type == MACH_TYPE_OMAP_H3)
+#else
+# define machine_is_omap_h3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_H4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_H4
+# endif
+# define machine_is_omap_h4()	(machine_arch_type == MACH_TYPE_OMAP_H4)
+#else
+# define machine_is_omap_h4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_OSK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_OSK
+# endif
+# define machine_is_omap_osk()	(machine_arch_type == MACH_TYPE_OMAP_OSK)
+#else
+# define machine_is_omap_osk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOSA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOSA
+# endif
+# define machine_is_tosa()	(machine_arch_type == MACH_TYPE_TOSA)
+#else
+# define machine_is_tosa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AVILA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AVILA
+# endif
+# define machine_is_avila()	(machine_arch_type == MACH_TYPE_AVILA)
+#else
+# define machine_is_avila()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9302
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9302
+# endif
+# define machine_is_edb9302()	(machine_arch_type == MACH_TYPE_EDB9302)
+#else
+# define machine_is_edb9302()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HUSKY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HUSKY
+# endif
+# define machine_is_husky()	(machine_arch_type == MACH_TYPE_HUSKY)
+#else
+# define machine_is_husky()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHEPHERD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHEPHERD
+# endif
+# define machine_is_shepherd()	(machine_arch_type == MACH_TYPE_SHEPHERD)
+#else
+# define machine_is_shepherd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_H4700
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H4700
+# endif
+# define machine_is_h4700()	(machine_arch_type == MACH_TYPE_H4700)
+#else
+# define machine_is_h4700()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RX3715
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RX3715
+# endif
+# define machine_is_rx3715()	(machine_arch_type == MACH_TYPE_RX3715)
+#else
+# define machine_is_rx3715()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NSLU2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NSLU2
+# endif
+# define machine_is_nslu2()	(machine_arch_type == MACH_TYPE_NSLU2)
+#else
+# define machine_is_nslu2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E400
+# endif
+# define machine_is_e400()	(machine_arch_type == MACH_TYPE_E400)
+#else
+# define machine_is_e400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDPG425
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDPG425
+# endif
+# define machine_is_ixdpg425()	(machine_arch_type == MACH_TYPE_IXDPG425)
+#else
+# define machine_is_ixdpg425()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VERSATILE_AB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VERSATILE_AB
+# endif
+# define machine_is_versatile_ab()	(machine_arch_type == MACH_TYPE_VERSATILE_AB)
+#else
+# define machine_is_versatile_ab()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9307
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9307
+# endif
+# define machine_is_edb9307()	(machine_arch_type == MACH_TYPE_EDB9307)
+#else
+# define machine_is_edb9307()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KB9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KB9200
+# endif
+# define machine_is_kb9200()	(machine_arch_type == MACH_TYPE_KB9200)
+#else
+# define machine_is_kb9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SX1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SX1
+# endif
+# define machine_is_sx1()	(machine_arch_type == MACH_TYPE_SX1)
+#else
+# define machine_is_sx1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDP465
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP465
+# endif
+# define machine_is_ixdp465()	(machine_arch_type == MACH_TYPE_IXDP465)
+#else
+# define machine_is_ixdp465()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDP2351
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP2351
+# endif
+# define machine_is_ixdp2351()	(machine_arch_type == MACH_TYPE_IXDP2351)
+#else
+# define machine_is_ixdp2351()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ80332
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ80332
+# endif
+# define machine_is_iq80332()	(machine_arch_type == MACH_TYPE_IQ80332)
+#else
+# define machine_is_iq80332()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GTWX5715
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GTWX5715
+# endif
+# define machine_is_gtwx5715()	(machine_arch_type == MACH_TYPE_GTWX5715)
+#else
+# define machine_is_gtwx5715()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB637
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB637
+# endif
+# define machine_is_csb637()	(machine_arch_type == MACH_TYPE_CSB637)
+#else
+# define machine_is_csb637()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N30
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N30
+# endif
+# define machine_is_n30()	(machine_arch_type == MACH_TYPE_N30)
+#else
+# define machine_is_n30()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEC_MP900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEC_MP900
+# endif
+# define machine_is_nec_mp900()	(machine_arch_type == MACH_TYPE_NEC_MP900)
+#else
+# define machine_is_nec_mp900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KAFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KAFA
+# endif
+# define machine_is_kafa()	(machine_arch_type == MACH_TYPE_KAFA)
+#else
+# define machine_is_kafa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS72XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS72XX
+# endif
+# define machine_is_ts72xx()	(machine_arch_type == MACH_TYPE_TS72XX)
+#else
+# define machine_is_ts72xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OTOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OTOM
+# endif
+# define machine_is_otom()	(machine_arch_type == MACH_TYPE_OTOM)
+#else
+# define machine_is_otom()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEXCODER_2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEXCODER_2440
+# endif
+# define machine_is_nexcoder_2440()	(machine_arch_type == MACH_TYPE_NEXCODER_2440)
+#else
+# define machine_is_nexcoder_2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ECO920
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ECO920
+# endif
+# define machine_is_eco920()	(machine_arch_type == MACH_TYPE_ECO920)
+#else
+# define machine_is_eco920()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROADRUNNER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROADRUNNER
+# endif
+# define machine_is_roadrunner()	(machine_arch_type == MACH_TYPE_ROADRUNNER)
+#else
+# define machine_is_roadrunner()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91RM9200EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91RM9200EK
+# endif
+# define machine_is_at91rm9200ek()	(machine_arch_type == MACH_TYPE_AT91RM9200EK)
+#else
+# define machine_is_at91rm9200ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPITZ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPITZ
+# endif
+# define machine_is_spitz()	(machine_arch_type == MACH_TYPE_SPITZ)
+#else
+# define machine_is_spitz()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSSPHERE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSSPHERE
+# endif
+# define machine_is_adssphere()	(machine_arch_type == MACH_TYPE_ADSSPHERE)
+#else
+# define machine_is_adssphere()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COLIBRI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COLIBRI
+# endif
+# define machine_is_colibri()	(machine_arch_type == MACH_TYPE_COLIBRI)
+#else
+# define machine_is_colibri()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GATEWAY7001
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GATEWAY7001
+# endif
+# define machine_is_gateway7001()	(machine_arch_type == MACH_TYPE_GATEWAY7001)
+#else
+# define machine_is_gateway7001()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM027
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM027
+# endif
+# define machine_is_pcm027()	(machine_arch_type == MACH_TYPE_PCM027)
+#else
+# define machine_is_pcm027()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ANUBIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANUBIS
+# endif
+# define machine_is_anubis()	(machine_arch_type == MACH_TYPE_ANUBIS)
+#else
+# define machine_is_anubis()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AKITA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AKITA
+# endif
+# define machine_is_akita()	(machine_arch_type == MACH_TYPE_AKITA)
+#else
+# define machine_is_akita()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E330
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E330
+# endif
+# define machine_is_e330()	(machine_arch_type == MACH_TYPE_E330)
+#else
+# define machine_is_e330()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA770
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA770
+# endif
+# define machine_is_nokia770()	(machine_arch_type == MACH_TYPE_NOKIA770)
+#else
+# define machine_is_nokia770()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CARMEVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CARMEVA
+# endif
+# define machine_is_carmeva()	(machine_arch_type == MACH_TYPE_CARMEVA)
+#else
+# define machine_is_carmeva()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9315A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9315A
+# endif
+# define machine_is_edb9315a()	(machine_arch_type == MACH_TYPE_EDB9315A)
+#else
+# define machine_is_edb9315a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STARGATE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STARGATE2
+# endif
+# define machine_is_stargate2()	(machine_arch_type == MACH_TYPE_STARGATE2)
+#else
+# define machine_is_stargate2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INTELMOTE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INTELMOTE2
+# endif
+# define machine_is_intelmote2()	(machine_arch_type == MACH_TYPE_INTELMOTE2)
+#else
+# define machine_is_intelmote2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRIZEPS4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIZEPS4
+# endif
+# define machine_is_trizeps4()	(machine_arch_type == MACH_TYPE_TRIZEPS4)
+#else
+# define machine_is_trizeps4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PNX4008
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNX4008
+# endif
+# define machine_is_pnx4008()	(machine_arch_type == MACH_TYPE_PNX4008)
+#else
+# define machine_is_pnx4008()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPUAT91
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPUAT91
+# endif
+# define machine_is_cpuat91()	(machine_arch_type == MACH_TYPE_CPUAT91)
+#else
+# define machine_is_cpuat91()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ81340SC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ81340SC
+# endif
+# define machine_is_iq81340sc()	(machine_arch_type == MACH_TYPE_IQ81340SC)
+#else
+# define machine_is_iq81340sc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IQ81340MC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IQ81340MC
+# endif
+# define machine_is_iq81340mc()	(machine_arch_type == MACH_TYPE_IQ81340MC)
+#else
+# define machine_is_iq81340mc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MICRO9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MICRO9
+# endif
+# define machine_is_micro9()	(machine_arch_type == MACH_TYPE_MICRO9)
+#else
+# define machine_is_micro9()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MICRO9L
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MICRO9L
+# endif
+# define machine_is_micro9l()	(machine_arch_type == MACH_TYPE_MICRO9L)
+#else
+# define machine_is_micro9l()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PALMTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PALMTE
+# endif
+# define machine_is_omap_palmte()	(machine_arch_type == MACH_TYPE_OMAP_PALMTE)
+#else
+# define machine_is_omap_palmte()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REALVIEW_EB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REALVIEW_EB
+# endif
+# define machine_is_realview_eb()	(machine_arch_type == MACH_TYPE_REALVIEW_EB)
+#else
+# define machine_is_realview_eb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BORZOI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BORZOI
+# endif
+# define machine_is_borzoi()	(machine_arch_type == MACH_TYPE_BORZOI)
+#else
+# define machine_is_borzoi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PALMLD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PALMLD
+# endif
+# define machine_is_palmld()	(machine_arch_type == MACH_TYPE_PALMLD)
+#else
+# define machine_is_palmld()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IXDP28X5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IXDP28X5
+# endif
+# define machine_is_ixdp28x5()	(machine_arch_type == MACH_TYPE_IXDP28X5)
+#else
+# define machine_is_ixdp28x5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PALMTT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PALMTT
+# endif
+# define machine_is_omap_palmtt()	(machine_arch_type == MACH_TYPE_OMAP_PALMTT)
+#else
+# define machine_is_omap_palmtt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARCOM_ZEUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARCOM_ZEUS
+# endif
+# define machine_is_arcom_zeus()	(machine_arch_type == MACH_TYPE_ARCOM_ZEUS)
+#else
+# define machine_is_arcom_zeus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OSIRIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OSIRIS
+# endif
+# define machine_is_osiris()	(machine_arch_type == MACH_TYPE_OSIRIS)
+#else
+# define machine_is_osiris()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PALMTE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PALMTE2
+# endif
+# define machine_is_palmte2()	(machine_arch_type == MACH_TYPE_PALMTE2)
+#else
+# define machine_is_palmte2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX27ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX27ADS
+# endif
+# define machine_is_mx27ads()	(machine_arch_type == MACH_TYPE_MX27ADS)
+#else
+# define machine_is_mx27ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9261EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9261EK
+# endif
+# define machine_is_at91sam9261ek()	(machine_arch_type == MACH_TYPE_AT91SAM9261EK)
+#else
+# define machine_is_at91sam9261ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LOFT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOFT
+# endif
+# define machine_is_loft()	(machine_arch_type == MACH_TYPE_LOFT)
+#else
+# define machine_is_loft()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX21ADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX21ADS
+# endif
+# define machine_is_mx21ads()	(machine_arch_type == MACH_TYPE_MX21ADS)
+#else
+# define machine_is_mx21ads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AMS_DELTA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AMS_DELTA
+# endif
+# define machine_is_ams_delta()	(machine_arch_type == MACH_TYPE_AMS_DELTA)
+#else
+# define machine_is_ams_delta()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAS100D
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAS100D
+# endif
+# define machine_is_nas100d()	(machine_arch_type == MACH_TYPE_NAS100D)
+#else
+# define machine_is_nas100d()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAGICIAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAGICIAN
+# endif
+# define machine_is_magician()	(machine_arch_type == MACH_TYPE_MAGICIAN)
+#else
+# define machine_is_magician()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NXDKN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NXDKN
+# endif
+# define machine_is_nxdkn()	(machine_arch_type == MACH_TYPE_NXDKN)
+#else
+# define machine_is_nxdkn()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PALMTX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PALMTX
+# endif
+# define machine_is_palmtx()	(machine_arch_type == MACH_TYPE_PALMTX)
+#else
+# define machine_is_palmtx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S3C2413
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2413
+# endif
+# define machine_is_s3c2413()	(machine_arch_type == MACH_TYPE_S3C2413)
+#else
+# define machine_is_s3c2413()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WG302V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WG302V2
+# endif
+# define machine_is_wg302v2()	(machine_arch_type == MACH_TYPE_WG302V2)
+#else
+# define machine_is_wg302v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_2430SDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_2430SDP
+# endif
+# define machine_is_omap_2430sdp()	(machine_arch_type == MACH_TYPE_OMAP_2430SDP)
+#else
+# define machine_is_omap_2430sdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_EVM
+# endif
+# define machine_is_davinci_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_EVM)
+#else
+# define machine_is_davinci_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PALMZ72
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PALMZ72
+# endif
+# define machine_is_palmz72()	(machine_arch_type == MACH_TYPE_PALMZ72)
+#else
+# define machine_is_palmz72()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NXDB500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NXDB500
+# endif
+# define machine_is_nxdb500()	(machine_arch_type == MACH_TYPE_NXDB500)
+#else
+# define machine_is_nxdb500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PALMT5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PALMT5
+# endif
+# define machine_is_palmt5()	(machine_arch_type == MACH_TYPE_PALMT5)
+#else
+# define machine_is_palmt5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PALMTC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PALMTC
+# endif
+# define machine_is_palmtc()	(machine_arch_type == MACH_TYPE_PALMTC)
+#else
+# define machine_is_palmtc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_APOLLON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_APOLLON
+# endif
+# define machine_is_omap_apollon()	(machine_arch_type == MACH_TYPE_OMAP_APOLLON)
+#else
+# define machine_is_omap_apollon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATEB9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATEB9200
+# endif
+# define machine_is_ateb9200()	(machine_arch_type == MACH_TYPE_ATEB9200)
+#else
+# define machine_is_ateb9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N35
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N35
+# endif
+# define machine_is_n35()	(machine_arch_type == MACH_TYPE_N35)
+#else
+# define machine_is_n35()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LOGICPD_PXA270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOGICPD_PXA270
+# endif
+# define machine_is_logicpd_pxa270()	(machine_arch_type == MACH_TYPE_LOGICPD_PXA270)
+#else
+# define machine_is_logicpd_pxa270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NXEB500HMI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NXEB500HMI
+# endif
+# define machine_is_nxeb500hmi()	(machine_arch_type == MACH_TYPE_NXEB500HMI)
+#else
+# define machine_is_nxeb500hmi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESPRESSO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESPRESSO
+# endif
+# define machine_is_espresso()	(machine_arch_type == MACH_TYPE_ESPRESSO)
+#else
+# define machine_is_espresso()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RX1950
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RX1950
+# endif
+# define machine_is_rx1950()	(machine_arch_type == MACH_TYPE_RX1950)
+#else
+# define machine_is_rx1950()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GESBC9312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GESBC9312
+# endif
+# define machine_is_gesbc9312()	(machine_arch_type == MACH_TYPE_GESBC9312)
+#else
+# define machine_is_gesbc9312()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICOTUX2XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICOTUX2XX
+# endif
+# define machine_is_picotux2xx()	(machine_arch_type == MACH_TYPE_PICOTUX2XX)
+#else
+# define machine_is_picotux2xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DSMG600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSMG600
+# endif
+# define machine_is_dsmg600()	(machine_arch_type == MACH_TYPE_DSMG600)
+#else
+# define machine_is_dsmg600()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_FSAMPLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_FSAMPLE
+# endif
+# define machine_is_omap_fsample()	(machine_arch_type == MACH_TYPE_OMAP_FSAMPLE)
+#else
+# define machine_is_omap_fsample()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SNAPPER_CL15
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SNAPPER_CL15
+# endif
+# define machine_is_snapper_cl15()	(machine_arch_type == MACH_TYPE_SNAPPER_CL15)
+#else
+# define machine_is_snapper_cl15()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_PALMZ71
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_PALMZ71
+# endif
+# define machine_is_omap_palmz71()	(machine_arch_type == MACH_TYPE_OMAP_PALMZ71)
+#else
+# define machine_is_omap_palmz71()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2412
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2412
+# endif
+# define machine_is_smdk2412()	(machine_arch_type == MACH_TYPE_SMDK2412)
+#else
+# define machine_is_smdk2412()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2413
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2413
+# endif
+# define machine_is_smdk2413()	(machine_arch_type == MACH_TYPE_SMDK2413)
+#else
+# define machine_is_smdk2413()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AML_M5900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AML_M5900
+# endif
+# define machine_is_aml_m5900()	(machine_arch_type == MACH_TYPE_AML_M5900)
+#else
+# define machine_is_aml_m5900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BALLOON3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BALLOON3
+# endif
+# define machine_is_balloon3()	(machine_arch_type == MACH_TYPE_BALLOON3)
+#else
+# define machine_is_balloon3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ECBAT91
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ECBAT91
+# endif
+# define machine_is_ecbat91()	(machine_arch_type == MACH_TYPE_ECBAT91)
+#else
+# define machine_is_ecbat91()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ONEARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ONEARM
+# endif
+# define machine_is_onearm()	(machine_arch_type == MACH_TYPE_ONEARM)
+#else
+# define machine_is_onearm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2443
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2443
+# endif
+# define machine_is_smdk2443()	(machine_arch_type == MACH_TYPE_SMDK2443)
+#else
+# define machine_is_smdk2443()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FSG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FSG
+# endif
+# define machine_is_fsg()	(machine_arch_type == MACH_TYPE_FSG)
+#else
+# define machine_is_fsg()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9260EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9260EK
+# endif
+# define machine_is_at91sam9260ek()	(machine_arch_type == MACH_TYPE_AT91SAM9260EK)
+#else
+# define machine_is_at91sam9260ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GLANTANK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GLANTANK
+# endif
+# define machine_is_glantank()	(machine_arch_type == MACH_TYPE_GLANTANK)
+#else
+# define machine_is_glantank()	(0)
+#endif
+
+#ifdef CONFIG_MACH_N2100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_N2100
+# endif
+# define machine_is_n2100()	(machine_arch_type == MACH_TYPE_N2100)
+#else
+# define machine_is_n2100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QT2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QT2410
+# endif
+# define machine_is_qt2410()	(machine_arch_type == MACH_TYPE_QT2410)
+#else
+# define machine_is_qt2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KIXRP435
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KIXRP435
+# endif
+# define machine_is_kixrp435()	(machine_arch_type == MACH_TYPE_KIXRP435)
+#else
+# define machine_is_kixrp435()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9P9360DEV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9P9360DEV
+# endif
+# define machine_is_cc9p9360dev()	(machine_arch_type == MACH_TYPE_CC9P9360DEV)
+#else
+# define machine_is_cc9p9360dev()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9302A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9302A
+# endif
+# define machine_is_edb9302a()	(machine_arch_type == MACH_TYPE_EDB9302A)
+#else
+# define machine_is_edb9302a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9307A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9307A
+# endif
+# define machine_is_edb9307a()	(machine_arch_type == MACH_TYPE_EDB9307A)
+#else
+# define machine_is_edb9307a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_3430SDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_3430SDP
+# endif
+# define machine_is_omap_3430sdp()	(machine_arch_type == MACH_TYPE_OMAP_3430SDP)
+#else
+# define machine_is_omap_3430sdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VSTMS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VSTMS
+# endif
+# define machine_is_vstms()	(machine_arch_type == MACH_TYPE_VSTMS)
+#else
+# define machine_is_vstms()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MICRO9M
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MICRO9M
+# endif
+# define machine_is_micro9m()	(machine_arch_type == MACH_TYPE_MICRO9M)
+#else
+# define machine_is_micro9m()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BUG
+# endif
+# define machine_is_bug()	(machine_arch_type == MACH_TYPE_BUG)
+#else
+# define machine_is_bug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9263EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9263EK
+# endif
+# define machine_is_at91sam9263ek()	(machine_arch_type == MACH_TYPE_AT91SAM9263EK)
+#else
+# define machine_is_at91sam9263ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EM7210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EM7210
+# endif
+# define machine_is_em7210()	(machine_arch_type == MACH_TYPE_EM7210)
+#else
+# define machine_is_em7210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VPAC270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VPAC270
+# endif
+# define machine_is_vpac270()	(machine_arch_type == MACH_TYPE_VPAC270)
+#else
+# define machine_is_vpac270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TREO680
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TREO680
+# endif
+# define machine_is_treo680()	(machine_arch_type == MACH_TYPE_TREO680)
+#else
+# define machine_is_treo680()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZYLONITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZYLONITE
+# endif
+# define machine_is_zylonite()	(machine_arch_type == MACH_TYPE_ZYLONITE)
+#else
+# define machine_is_zylonite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX31LITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX31LITE
+# endif
+# define machine_is_mx31lite()	(machine_arch_type == MACH_TYPE_MX31LITE)
+#else
+# define machine_is_mx31lite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIOA701
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIOA701
+# endif
+# define machine_is_mioa701()	(machine_arch_type == MACH_TYPE_MIOA701)
+#else
+# define machine_is_mioa701()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMADILLO5X0
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMADILLO5X0
+# endif
+# define machine_is_armadillo5x0()	(machine_arch_type == MACH_TYPE_ARMADILLO5X0)
+#else
+# define machine_is_armadillo5x0()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9P9360JS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9P9360JS
+# endif
+# define machine_is_cc9p9360js()	(machine_arch_type == MACH_TYPE_CC9P9360JS)
+#else
+# define machine_is_cc9p9360js()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK6400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK6400
+# endif
+# define machine_is_smdk6400()	(machine_arch_type == MACH_TYPE_SMDK6400)
+#else
+# define machine_is_smdk6400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA_N800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA_N800
+# endif
+# define machine_is_nokia_n800()	(machine_arch_type == MACH_TYPE_NOKIA_N800)
+#else
+# define machine_is_nokia_n800()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EP80219
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EP80219
+# endif
+# define machine_is_ep80219()	(machine_arch_type == MACH_TYPE_EP80219)
+#else
+# define machine_is_ep80219()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GORAMO_MLR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GORAMO_MLR
+# endif
+# define machine_is_goramo_mlr()	(machine_arch_type == MACH_TYPE_GORAMO_MLR)
+#else
+# define machine_is_goramo_mlr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EM_X270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EM_X270
+# endif
+# define machine_is_em_x270()	(machine_arch_type == MACH_TYPE_EM_X270)
+#else
+# define machine_is_em_x270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEO1973_GTA02
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEO1973_GTA02
+# endif
+# define machine_is_neo1973_gta02()	(machine_arch_type == MACH_TYPE_NEO1973_GTA02)
+#else
+# define machine_is_neo1973_gta02()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9RLEK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9RLEK
+# endif
+# define machine_is_at91sam9rlek()	(machine_arch_type == MACH_TYPE_AT91SAM9RLEK)
+#else
+# define machine_is_at91sam9rlek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COLIBRI320
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COLIBRI320
+# endif
+# define machine_is_colibri320()	(machine_arch_type == MACH_TYPE_COLIBRI320)
+#else
+# define machine_is_colibri320()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CAM60
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CAM60
+# endif
+# define machine_is_cam60()	(machine_arch_type == MACH_TYPE_CAM60)
+#else
+# define machine_is_cam60()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91EB01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91EB01
+# endif
+# define machine_is_at91eb01()	(machine_arch_type == MACH_TYPE_AT91EB01)
+#else
+# define machine_is_at91eb01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DB88F5281
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DB88F5281
+# endif
+# define machine_is_db88f5281()	(machine_arch_type == MACH_TYPE_DB88F5281)
+#else
+# define machine_is_db88f5281()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB726
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB726
+# endif
+# define machine_is_csb726()	(machine_arch_type == MACH_TYPE_CSB726)
+#else
+# define machine_is_csb726()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DM6467_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DM6467_EVM
+# endif
+# define machine_is_davinci_dm6467_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DM6467_EVM)
+#else
+# define machine_is_davinci_dm6467_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DM355_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DM355_EVM
+# endif
+# define machine_is_davinci_dm355_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DM355_EVM)
+#else
+# define machine_is_davinci_dm355_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LITTLETON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LITTLETON
+# endif
+# define machine_is_littleton()	(machine_arch_type == MACH_TYPE_LITTLETON)
+#else
+# define machine_is_littleton()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REALVIEW_PB11MP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REALVIEW_PB11MP
+# endif
+# define machine_is_realview_pb11mp()	(machine_arch_type == MACH_TYPE_REALVIEW_PB11MP)
+#else
+# define machine_is_realview_pb11mp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX27_3DS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX27_3DS
+# endif
+# define machine_is_mx27_3ds()	(machine_arch_type == MACH_TYPE_MX27_3DS)
+#else
+# define machine_is_mx27_3ds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HALIBUT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HALIBUT
+# endif
+# define machine_is_halibut()	(machine_arch_type == MACH_TYPE_HALIBUT)
+#else
+# define machine_is_halibut()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TROUT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TROUT
+# endif
+# define machine_is_trout()	(machine_arch_type == MACH_TYPE_TROUT)
+#else
+# define machine_is_trout()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TCT_HAMMER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TCT_HAMMER
+# endif
+# define machine_is_tct_hammer()	(machine_arch_type == MACH_TYPE_TCT_HAMMER)
+#else
+# define machine_is_tct_hammer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HERALD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HERALD
+# endif
+# define machine_is_herald()	(machine_arch_type == MACH_TYPE_HERALD)
+#else
+# define machine_is_herald()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIM_ONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIM_ONE
+# endif
+# define machine_is_sim_one()	(machine_arch_type == MACH_TYPE_SIM_ONE)
+#else
+# define machine_is_sim_one()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JIVE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JIVE
+# endif
+# define machine_is_jive()	(machine_arch_type == MACH_TYPE_JIVE)
+#else
+# define machine_is_jive()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAM9_L9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAM9_L9260
+# endif
+# define machine_is_sam9_l9260()	(machine_arch_type == MACH_TYPE_SAM9_L9260)
+#else
+# define machine_is_sam9_l9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REALVIEW_PB1176
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REALVIEW_PB1176
+# endif
+# define machine_is_realview_pb1176()	(machine_arch_type == MACH_TYPE_REALVIEW_PB1176)
+#else
+# define machine_is_realview_pb1176()	(0)
+#endif
+
+#ifdef CONFIG_MACH_YL9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_YL9200
+# endif
+# define machine_is_yl9200()	(machine_arch_type == MACH_TYPE_YL9200)
+#else
+# define machine_is_yl9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD88F5182
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD88F5182
+# endif
+# define machine_is_rd88f5182()	(machine_arch_type == MACH_TYPE_RD88F5182)
+#else
+# define machine_is_rd88f5182()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KUROBOX_PRO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KUROBOX_PRO
+# endif
+# define machine_is_kurobox_pro()	(machine_arch_type == MACH_TYPE_KUROBOX_PRO)
+#else
+# define machine_is_kurobox_pro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX31_3DS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX31_3DS
+# endif
+# define machine_is_mx31_3ds()	(machine_arch_type == MACH_TYPE_MX31_3DS)
+#else
+# define machine_is_mx31_3ds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QONG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QONG
+# endif
+# define machine_is_qong()	(machine_arch_type == MACH_TYPE_QONG)
+#else
+# define machine_is_qong()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP2EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP2EVM
+# endif
+# define machine_is_omap2evm()	(machine_arch_type == MACH_TYPE_OMAP2EVM)
+#else
+# define machine_is_omap2evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3EVM
+# endif
+# define machine_is_omap3evm()	(machine_arch_type == MACH_TYPE_OMAP3EVM)
+#else
+# define machine_is_omap3evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DNS323
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DNS323
+# endif
+# define machine_is_dns323()	(machine_arch_type == MACH_TYPE_DNS323)
+#else
+# define machine_is_dns323()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_BEAGLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_BEAGLE
+# endif
+# define machine_is_omap3_beagle()	(machine_arch_type == MACH_TYPE_OMAP3_BEAGLE)
+#else
+# define machine_is_omap3_beagle()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA_N810
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA_N810
+# endif
+# define machine_is_nokia_n810()	(machine_arch_type == MACH_TYPE_NOKIA_N810)
+#else
+# define machine_is_nokia_n810()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM038
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM038
+# endif
+# define machine_is_pcm038()	(machine_arch_type == MACH_TYPE_PCM038)
+#else
+# define machine_is_pcm038()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS209
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS209
+# endif
+# define machine_is_ts_x09()	(machine_arch_type == MACH_TYPE_TS209)
+#else
+# define machine_is_ts_x09()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91CAP9ADK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91CAP9ADK
+# endif
+# define machine_is_at91cap9adk()	(machine_arch_type == MACH_TYPE_AT91CAP9ADK)
+#else
+# define machine_is_at91cap9adk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX31MOBOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX31MOBOARD
+# endif
+# define machine_is_mx31moboard()	(machine_arch_type == MACH_TYPE_MX31MOBOARD)
+#else
+# define machine_is_mx31moboard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TERASTATION_PRO2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TERASTATION_PRO2
+# endif
+# define machine_is_terastation_pro2()	(machine_arch_type == MACH_TYPE_TERASTATION_PRO2)
+#else
+# define machine_is_terastation_pro2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LINKSTATION_PRO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LINKSTATION_PRO
+# endif
+# define machine_is_linkstation_pro()	(machine_arch_type == MACH_TYPE_LINKSTATION_PRO)
+#else
+# define machine_is_linkstation_pro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E350
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E350
+# endif
+# define machine_is_e350()	(machine_arch_type == MACH_TYPE_E350)
+#else
+# define machine_is_e350()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS409
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS409
+# endif
+# define machine_is_ts409()	(machine_arch_type == MACH_TYPE_TS409)
+#else
+# define machine_is_ts409()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM_X300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM_X300
+# endif
+# define machine_is_cm_x300()	(machine_arch_type == MACH_TYPE_CM_X300)
+#else
+# define machine_is_cm_x300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9G20EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9G20EK
+# endif
+# define machine_is_at91sam9g20ek()	(machine_arch_type == MACH_TYPE_AT91SAM9G20EK)
+#else
+# define machine_is_at91sam9g20ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK6410
+# endif
+# define machine_is_smdk6410()	(machine_arch_type == MACH_TYPE_SMDK6410)
+#else
+# define machine_is_smdk6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_U300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_U300
+# endif
+# define machine_is_u300()	(machine_arch_type == MACH_TYPE_U300)
+#else
+# define machine_is_u300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WRT350N_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WRT350N_V2
+# endif
+# define machine_is_wrt350n_v2()	(machine_arch_type == MACH_TYPE_WRT350N_V2)
+#else
+# define machine_is_wrt350n_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_LDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_LDP
+# endif
+# define machine_is_omap_ldp()	(machine_arch_type == MACH_TYPE_OMAP_LDP)
+#else
+# define machine_is_omap_ldp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX35_3DS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX35_3DS
+# endif
+# define machine_is_mx35_3ds()	(machine_arch_type == MACH_TYPE_MX35_3DS)
+#else
+# define machine_is_mx35_3ds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEUROS_OSD2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEUROS_OSD2
+# endif
+# define machine_is_neuros_osd2()	(machine_arch_type == MACH_TYPE_NEUROS_OSD2)
+#else
+# define machine_is_neuros_osd2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRIZEPS4WL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIZEPS4WL
+# endif
+# define machine_is_trizeps4wl()	(machine_arch_type == MACH_TYPE_TRIZEPS4WL)
+#else
+# define machine_is_trizeps4wl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS78XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS78XX
+# endif
+# define machine_is_ts78xx()	(machine_arch_type == MACH_TYPE_TS78XX)
+#else
+# define machine_is_ts78xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SFFSDR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SFFSDR
+# endif
+# define machine_is_sffsdr()	(machine_arch_type == MACH_TYPE_SFFSDR)
+#else
+# define machine_is_sffsdr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM037
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM037
+# endif
+# define machine_is_pcm037()	(machine_arch_type == MACH_TYPE_PCM037)
+#else
+# define machine_is_pcm037()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DB88F6281_BP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DB88F6281_BP
+# endif
+# define machine_is_db88f6281_bp()	(machine_arch_type == MACH_TYPE_DB88F6281_BP)
+#else
+# define machine_is_db88f6281_bp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD88F6192_NAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD88F6192_NAS
+# endif
+# define machine_is_rd88f6192_nas()	(machine_arch_type == MACH_TYPE_RD88F6192_NAS)
+#else
+# define machine_is_rd88f6192_nas()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD88F6281
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD88F6281
+# endif
+# define machine_is_rd88f6281()	(machine_arch_type == MACH_TYPE_RD88F6281)
+#else
+# define machine_is_rd88f6281()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DB78X00_BP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DB78X00_BP
+# endif
+# define machine_is_db78x00_bp()	(machine_arch_type == MACH_TYPE_DB78X00_BP)
+#else
+# define machine_is_db78x00_bp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2416
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2416
+# endif
+# define machine_is_smdk2416()	(machine_arch_type == MACH_TYPE_SMDK2416)
+#else
+# define machine_is_smdk2416()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WBD111
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WBD111
+# endif
+# define machine_is_wbd111()	(machine_arch_type == MACH_TYPE_WBD111)
+#else
+# define machine_is_wbd111()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MV2120
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MV2120
+# endif
+# define machine_is_mv2120()	(machine_arch_type == MACH_TYPE_MV2120)
+#else
+# define machine_is_mv2120()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_3DS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_3DS
+# endif
+# define machine_is_mx51_3ds()	(machine_arch_type == MACH_TYPE_MX51_3DS)
+#else
+# define machine_is_mx51_3ds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMX27LITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMX27LITE
+# endif
+# define machine_is_imx27lite()	(machine_arch_type == MACH_TYPE_IMX27LITE)
+#else
+# define machine_is_imx27lite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_USB_A9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_USB_A9260
+# endif
+# define machine_is_usb_a9260()	(machine_arch_type == MACH_TYPE_USB_A9260)
+#else
+# define machine_is_usb_a9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_USB_A9263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_USB_A9263
+# endif
+# define machine_is_usb_a9263()	(machine_arch_type == MACH_TYPE_USB_A9263)
+#else
+# define machine_is_usb_a9263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QIL_A9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QIL_A9260
+# endif
+# define machine_is_qil_a9260()	(machine_arch_type == MACH_TYPE_QIL_A9260)
+#else
+# define machine_is_qil_a9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KZM_ARM11_01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KZM_ARM11_01
+# endif
+# define machine_is_kzm_arm11_01()	(machine_arch_type == MACH_TYPE_KZM_ARM11_01)
+#else
+# define machine_is_kzm_arm11_01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA_N810_WIMAX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA_N810_WIMAX
+# endif
+# define machine_is_nokia_n810_wimax()	(machine_arch_type == MACH_TYPE_NOKIA_N810_WIMAX)
+#else
+# define machine_is_nokia_n810_wimax()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAPPHIRE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAPPHIRE
+# endif
+# define machine_is_sapphire()	(machine_arch_type == MACH_TYPE_SAPPHIRE)
+#else
+# define machine_is_sapphire()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STMP37XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STMP37XX
+# endif
+# define machine_is_stmp37xx()	(machine_arch_type == MACH_TYPE_STMP37XX)
+#else
+# define machine_is_stmp37xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STMP378X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STMP378X
+# endif
+# define machine_is_stmp378x()	(machine_arch_type == MACH_TYPE_STMP378X)
+#else
+# define machine_is_stmp378x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX_A780
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX_A780
+# endif
+# define machine_is_ezx_a780()	(machine_arch_type == MACH_TYPE_EZX_A780)
+#else
+# define machine_is_ezx_a780()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX_E680
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX_E680
+# endif
+# define machine_is_ezx_e680()	(machine_arch_type == MACH_TYPE_EZX_E680)
+#else
+# define machine_is_ezx_e680()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX_A1200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX_A1200
+# endif
+# define machine_is_ezx_a1200()	(machine_arch_type == MACH_TYPE_EZX_A1200)
+#else
+# define machine_is_ezx_a1200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX_E6
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX_E6
+# endif
+# define machine_is_ezx_e6()	(machine_arch_type == MACH_TYPE_EZX_E6)
+#else
+# define machine_is_ezx_e6()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX_E2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX_E2
+# endif
+# define machine_is_ezx_e2()	(machine_arch_type == MACH_TYPE_EZX_E2)
+#else
+# define machine_is_ezx_e2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX_A910
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX_A910
+# endif
+# define machine_is_ezx_a910()	(machine_arch_type == MACH_TYPE_EZX_A910)
+#else
+# define machine_is_ezx_a910()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDMINI_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDMINI_V2
+# endif
+# define machine_is_edmini_v2()	(machine_arch_type == MACH_TYPE_EDMINI_V2)
+#else
+# define machine_is_edmini_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZIPIT2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZIPIT2
+# endif
+# define machine_is_zipit2()	(machine_arch_type == MACH_TYPE_ZIPIT2)
+#else
+# define machine_is_zipit2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_PANDORA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_PANDORA
+# endif
+# define machine_is_omap3_pandora()	(machine_arch_type == MACH_TYPE_OMAP3_PANDORA)
+#else
+# define machine_is_omap3_pandora()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSS2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSS2
+# endif
+# define machine_is_mss2()	(machine_arch_type == MACH_TYPE_MSS2)
+#else
+# define machine_is_mss2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LB88RC8480
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LB88RC8480
+# endif
+# define machine_is_lb88rc8480()	(machine_arch_type == MACH_TYPE_LB88RC8480)
+#else
+# define machine_is_lb88rc8480()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX25_3DS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX25_3DS
+# endif
+# define machine_is_mx25_3ds()	(machine_arch_type == MACH_TYPE_MX25_3DS)
+#else
+# define machine_is_mx25_3ds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3530_LV_SOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3530_LV_SOM
+# endif
+# define machine_is_omap3530_lv_som()	(machine_arch_type == MACH_TYPE_OMAP3530_LV_SOM)
+#else
+# define machine_is_omap3530_lv_som()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DA830_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DA830_EVM
+# endif
+# define machine_is_davinci_da830_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DA830_EVM)
+#else
+# define machine_is_davinci_da830_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT572D940HFEB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT572D940HFEB
+# endif
+# define machine_is_at572d940hfek()	(machine_arch_type == MACH_TYPE_AT572D940HFEB)
+#else
+# define machine_is_at572d940hfek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DOVE_DB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DOVE_DB
+# endif
+# define machine_is_dove_db()	(machine_arch_type == MACH_TYPE_DOVE_DB)
+#else
+# define machine_is_dove_db()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OVERO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OVERO
+# endif
+# define machine_is_overo()	(machine_arch_type == MACH_TYPE_OVERO)
+#else
+# define machine_is_overo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT2440EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT2440EVB
+# endif
+# define machine_is_at2440evb()	(machine_arch_type == MACH_TYPE_AT2440EVB)
+#else
+# define machine_is_at2440evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEOCORE926
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEOCORE926
+# endif
+# define machine_is_neocore926()	(machine_arch_type == MACH_TYPE_NEOCORE926)
+#else
+# define machine_is_neocore926()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WNR854T
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WNR854T
+# endif
+# define machine_is_wnr854t()	(machine_arch_type == MACH_TYPE_WNR854T)
+#else
+# define machine_is_wnr854t()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD88F5181L_GE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD88F5181L_GE
+# endif
+# define machine_is_rd88f5181l_ge()	(machine_arch_type == MACH_TYPE_RD88F5181L_GE)
+#else
+# define machine_is_rd88f5181l_ge()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD88F5181L_FXO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD88F5181L_FXO
+# endif
+# define machine_is_rd88f5181l_fxo()	(machine_arch_type == MACH_TYPE_RD88F5181L_FXO)
+#else
+# define machine_is_rd88f5181l_fxo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STAMP9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STAMP9G20
+# endif
+# define machine_is_stamp9g20()	(machine_arch_type == MACH_TYPE_STAMP9G20)
+#else
+# define machine_is_stamp9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDKC100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDKC100
+# endif
+# define machine_is_smdkc100()	(machine_arch_type == MACH_TYPE_SMDKC100)
+#else
+# define machine_is_smdkc100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAVOREVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAVOREVB
+# endif
+# define machine_is_tavorevb()	(machine_arch_type == MACH_TYPE_TAVOREVB)
+#else
+# define machine_is_tavorevb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAAR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAAR
+# endif
+# define machine_is_saar()	(machine_arch_type == MACH_TYPE_SAAR)
+#else
+# define machine_is_saar()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9M10G45EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9M10G45EK
+# endif
+# define machine_is_at91sam9m10g45ek()	(machine_arch_type == MACH_TYPE_AT91SAM9M10G45EK)
+#else
+# define machine_is_at91sam9m10g45ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXLADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXLADS
+# endif
+# define machine_is_mxlads()	(machine_arch_type == MACH_TYPE_MXLADS)
+#else
+# define machine_is_mxlads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LINKSTATION_MINI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LINKSTATION_MINI
+# endif
+# define machine_is_linkstation_mini()	(machine_arch_type == MACH_TYPE_LINKSTATION_MINI)
+#else
+# define machine_is_linkstation_mini()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AFEB9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AFEB9260
+# endif
+# define machine_is_afeb9260()	(machine_arch_type == MACH_TYPE_AFEB9260)
+#else
+# define machine_is_afeb9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMX27IPCAM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMX27IPCAM
+# endif
+# define machine_is_imx27ipcam()	(machine_arch_type == MACH_TYPE_IMX27IPCAM)
+#else
+# define machine_is_imx27ipcam()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD88F6183AP_GE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD88F6183AP_GE
+# endif
+# define machine_is_rd88f6183ap_ge()	(machine_arch_type == MACH_TYPE_RD88F6183AP_GE)
+#else
+# define machine_is_rd88f6183ap_ge()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REALVIEW_PBA8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REALVIEW_PBA8
+# endif
+# define machine_is_realview_pba8()	(machine_arch_type == MACH_TYPE_REALVIEW_PBA8)
+#else
+# define machine_is_realview_pba8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REALVIEW_PBX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REALVIEW_PBX
+# endif
+# define machine_is_realview_pbx()	(machine_arch_type == MACH_TYPE_REALVIEW_PBX)
+#else
+# define machine_is_realview_pbx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MICRO9S
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MICRO9S
+# endif
+# define machine_is_micro9s()	(machine_arch_type == MACH_TYPE_MICRO9S)
+#else
+# define machine_is_micro9s()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RUT100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RUT100
+# endif
+# define machine_is_rut100()	(machine_arch_type == MACH_TYPE_RUT100)
+#else
+# define machine_is_rut100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_G3EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_G3EVM
+# endif
+# define machine_is_g3evm()	(machine_arch_type == MACH_TYPE_G3EVM)
+#else
+# define machine_is_g3evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W90P910EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W90P910EVB
+# endif
+# define machine_is_w90p910evb()	(machine_arch_type == MACH_TYPE_W90P910EVB)
+#else
+# define machine_is_w90p910evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W90P950EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W90P950EVB
+# endif
+# define machine_is_w90p950evb()	(machine_arch_type == MACH_TYPE_W90P950EVB)
+#else
+# define machine_is_w90p950evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W90N960EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W90N960EVB
+# endif
+# define machine_is_w90n960evb()	(machine_arch_type == MACH_TYPE_W90N960EVB)
+#else
+# define machine_is_w90n960evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MV88F6281GTW_GE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MV88F6281GTW_GE
+# endif
+# define machine_is_mv88f6281gtw_ge()	(machine_arch_type == MACH_TYPE_MV88F6281GTW_GE)
+#else
+# define machine_is_mv88f6281gtw_ge()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NCP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NCP
+# endif
+# define machine_is_ncp()	(machine_arch_type == MACH_TYPE_NCP)
+#else
+# define machine_is_ncp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DM365_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DM365_EVM
+# endif
+# define machine_is_davinci_dm365_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DM365_EVM)
+#else
+# define machine_is_davinci_dm365_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CENTRO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CENTRO
+# endif
+# define machine_is_centro()	(machine_arch_type == MACH_TYPE_CENTRO)
+#else
+# define machine_is_centro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA_RX51
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA_RX51
+# endif
+# define machine_is_nokia_rx51()	(machine_arch_type == MACH_TYPE_NOKIA_RX51)
+#else
+# define machine_is_nokia_rx51()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_ZOOM2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_ZOOM2
+# endif
+# define machine_is_omap_zoom2()	(machine_arch_type == MACH_TYPE_OMAP_ZOOM2)
+#else
+# define machine_is_omap_zoom2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPUAT9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPUAT9260
+# endif
+# define machine_is_cpuat9260()	(machine_arch_type == MACH_TYPE_CPUAT9260)
+#else
+# define machine_is_cpuat9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPUIMX27
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPUIMX27
+# endif
+# define machine_is_eukrea_cpuimx27()	(machine_arch_type == MACH_TYPE_CPUIMX27)
+#else
+# define machine_is_eukrea_cpuimx27()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACS5K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACS5K
+# endif
+# define machine_is_acs5k()	(machine_arch_type == MACH_TYPE_ACS5K)
+#else
+# define machine_is_acs5k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SNAPPER_9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SNAPPER_9260
+# endif
+# define machine_is_snapper_9260()	(machine_arch_type == MACH_TYPE_SNAPPER_9260)
+#else
+# define machine_is_snapper_9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DSM320
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSM320
+# endif
+# define machine_is_dsm320()	(machine_arch_type == MACH_TYPE_DSM320)
+#else
+# define machine_is_dsm320()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EXEDA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EXEDA
+# endif
+# define machine_is_exeda()	(machine_arch_type == MACH_TYPE_EXEDA)
+#else
+# define machine_is_exeda()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MINI2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINI2440
+# endif
+# define machine_is_mini2440()	(machine_arch_type == MACH_TYPE_MINI2440)
+#else
+# define machine_is_mini2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COLIBRI300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COLIBRI300
+# endif
+# define machine_is_colibri300()	(machine_arch_type == MACH_TYPE_COLIBRI300)
+#else
+# define machine_is_colibri300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LINKSTATION_LS_HGL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LINKSTATION_LS_HGL
+# endif
+# define machine_is_linkstation_ls_hgl()	(machine_arch_type == MACH_TYPE_LINKSTATION_LS_HGL)
+#else
+# define machine_is_linkstation_ls_hgl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPUAT9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPUAT9G20
+# endif
+# define machine_is_cpuat9g20()	(machine_arch_type == MACH_TYPE_CPUAT9G20)
+#else
+# define machine_is_cpuat9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK6440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK6440
+# endif
+# define machine_is_smdk6440()	(machine_arch_type == MACH_TYPE_SMDK6440)
+#else
+# define machine_is_smdk6440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAS4220B
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAS4220B
+# endif
+# define machine_is_nas4220b()	(machine_arch_type == MACH_TYPE_NAS4220B)
+#else
+# define machine_is_nas4220b()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZYLONITE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZYLONITE2
+# endif
+# define machine_is_zylonite2()	(machine_arch_type == MACH_TYPE_ZYLONITE2)
+#else
+# define machine_is_zylonite2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASPENITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASPENITE
+# endif
+# define machine_is_aspenite()	(machine_arch_type == MACH_TYPE_ASPENITE)
+#else
+# define machine_is_aspenite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TTC_DKB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TTC_DKB
+# endif
+# define machine_is_ttc_dkb()	(machine_arch_type == MACH_TYPE_TTC_DKB)
+#else
+# define machine_is_ttc_dkb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM043
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM043
+# endif
+# define machine_is_pcm043()	(machine_arch_type == MACH_TYPE_PCM043)
+#else
+# define machine_is_pcm043()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHEEVAPLUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHEEVAPLUG
+# endif
+# define machine_is_sheevaplug()	(machine_arch_type == MACH_TYPE_SHEEVAPLUG)
+#else
+# define machine_is_sheevaplug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AVENGERS_LITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AVENGERS_LITE
+# endif
+# define machine_is_avengers_lite()	(machine_arch_type == MACH_TYPE_AVENGERS_LITE)
+#else
+# define machine_is_avengers_lite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_BABBAGE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_BABBAGE
+# endif
+# define machine_is_mx51_babbage()	(machine_arch_type == MACH_TYPE_MX51_BABBAGE)
+#else
+# define machine_is_mx51_babbage()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD78X00_MASA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD78X00_MASA
+# endif
+# define machine_is_rd78x00_masa()	(machine_arch_type == MACH_TYPE_RD78X00_MASA)
+#else
+# define machine_is_rd78x00_masa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM355_LEOPARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM355_LEOPARD
+# endif
+# define machine_is_dm355_leopard()	(machine_arch_type == MACH_TYPE_DM355_LEOPARD)
+#else
+# define machine_is_dm355_leopard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS219
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS219
+# endif
+# define machine_is_ts219()	(machine_arch_type == MACH_TYPE_TS219)
+#else
+# define machine_is_ts219()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCA100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCA100
+# endif
+# define machine_is_pca100()	(machine_arch_type == MACH_TYPE_PCA100)
+#else
+# define machine_is_pca100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DA850_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DA850_EVM
+# endif
+# define machine_is_davinci_da850_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DA850_EVM)
+#else
+# define machine_is_davinci_da850_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9G10EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9G10EK
+# endif
+# define machine_is_at91sam9g10ek()	(machine_arch_type == MACH_TYPE_AT91SAM9G10EK)
+#else
+# define machine_is_at91sam9g10ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_4430SDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_4430SDP
+# endif
+# define machine_is_omap_4430sdp()	(machine_arch_type == MACH_TYPE_OMAP_4430SDP)
+#else
+# define machine_is_omap_4430sdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAGX_ZN5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAGX_ZN5
+# endif
+# define machine_is_magx_zn5()	(machine_arch_type == MACH_TYPE_MAGX_ZN5)
+#else
+# define machine_is_magx_zn5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BTMAVB101
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BTMAVB101
+# endif
+# define machine_is_btmavb101()	(machine_arch_type == MACH_TYPE_BTMAVB101)
+#else
+# define machine_is_btmavb101()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BTMAWB101
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BTMAWB101
+# endif
+# define machine_is_btmawb101()	(machine_arch_type == MACH_TYPE_BTMAWB101)
+#else
+# define machine_is_btmawb101()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_TORPEDO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_TORPEDO
+# endif
+# define machine_is_omap3_torpedo()	(machine_arch_type == MACH_TYPE_OMAP3_TORPEDO)
+#else
+# define machine_is_omap3_torpedo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ANW6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANW6410
+# endif
+# define machine_is_anw6410()	(machine_arch_type == MACH_TYPE_ANW6410)
+#else
+# define machine_is_anw6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMX27_VISSTRIM_M10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMX27_VISSTRIM_M10
+# endif
+# define machine_is_imx27_visstrim_m10()	(machine_arch_type == MACH_TYPE_IMX27_VISSTRIM_M10)
+#else
+# define machine_is_imx27_visstrim_m10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PORTUXG20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PORTUXG20
+# endif
+# define machine_is_portuxg20()	(machine_arch_type == MACH_TYPE_PORTUXG20)
+#else
+# define machine_is_portuxg20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDKC110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDKC110
+# endif
+# define machine_is_smdkc110()	(machine_arch_type == MACH_TYPE_SMDKC110)
+#else
+# define machine_is_smdkc110()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3517EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3517EVM
+# endif
+# define machine_is_omap3517evm()	(machine_arch_type == MACH_TYPE_OMAP3517EVM)
+#else
+# define machine_is_omap3517evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETSPACE_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETSPACE_V2
+# endif
+# define machine_is_netspace_v2()	(machine_arch_type == MACH_TYPE_NETSPACE_V2)
+#else
+# define machine_is_netspace_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETSPACE_MAX_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETSPACE_MAX_V2
+# endif
+# define machine_is_netspace_max_v2()	(machine_arch_type == MACH_TYPE_NETSPACE_MAX_V2)
+#else
+# define machine_is_netspace_max_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_D2NET_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_D2NET_V2
+# endif
+# define machine_is_d2net_v2()	(machine_arch_type == MACH_TYPE_D2NET_V2)
+#else
+# define machine_is_d2net_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NET2BIG_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NET2BIG_V2
+# endif
+# define machine_is_net2big_v2()	(machine_arch_type == MACH_TYPE_NET2BIG_V2)
+#else
+# define machine_is_net2big_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NET5BIG_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NET5BIG_V2
+# endif
+# define machine_is_net5big_v2()	(machine_arch_type == MACH_TYPE_NET5BIG_V2)
+#else
+# define machine_is_net5big_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INETSPACE_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INETSPACE_V2
+# endif
+# define machine_is_inetspace_v2()	(machine_arch_type == MACH_TYPE_INETSPACE_V2)
+#else
+# define machine_is_inetspace_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9G45EKES
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9G45EKES
+# endif
+# define machine_is_at91sam9g45ekes()	(machine_arch_type == MACH_TYPE_AT91SAM9G45EKES)
+#else
+# define machine_is_at91sam9g45ekes()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PC7302
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PC7302
+# endif
+# define machine_is_pc7302()	(machine_arch_type == MACH_TYPE_PC7302)
+#else
+# define machine_is_pc7302()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEAR600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEAR600
+# endif
+# define machine_is_spear600()	(machine_arch_type == MACH_TYPE_SPEAR600)
+#else
+# define machine_is_spear600()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEAR300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEAR300
+# endif
+# define machine_is_spear300()	(machine_arch_type == MACH_TYPE_SPEAR300)
+#else
+# define machine_is_spear300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LILLY1131
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LILLY1131
+# endif
+# define machine_is_lilly1131()	(machine_arch_type == MACH_TYPE_LILLY1131)
+#else
+# define machine_is_lilly1131()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HMT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HMT
+# endif
+# define machine_is_hmt()	(machine_arch_type == MACH_TYPE_HMT)
+#else
+# define machine_is_hmt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VEXPRESS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VEXPRESS
+# endif
+# define machine_is_vexpress()	(machine_arch_type == MACH_TYPE_VEXPRESS)
+#else
+# define machine_is_vexpress()	(0)
+#endif
+
+#ifdef CONFIG_MACH_D2NET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_D2NET
+# endif
+# define machine_is_d2net()	(machine_arch_type == MACH_TYPE_D2NET)
+#else
+# define machine_is_d2net()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BIGDISK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BIGDISK
+# endif
+# define machine_is_bigdisk()	(machine_arch_type == MACH_TYPE_BIGDISK)
+#else
+# define machine_is_bigdisk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9G20EK_2MMC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9G20EK_2MMC
+# endif
+# define machine_is_at91sam9g20ek_2mmc()	(machine_arch_type == MACH_TYPE_AT91SAM9G20EK_2MMC)
+#else
+# define machine_is_at91sam9g20ek_2mmc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCMRING
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCMRING
+# endif
+# define machine_is_bcmring()	(machine_arch_type == MACH_TYPE_BCMRING)
+#else
+# define machine_is_bcmring()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DP6XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DP6XX
+# endif
+# define machine_is_dp6xx()	(machine_arch_type == MACH_TYPE_DP6XX)
+#else
+# define machine_is_dp6xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAHIMAHI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAHIMAHI
+# endif
+# define machine_is_mahimahi()	(machine_arch_type == MACH_TYPE_MAHIMAHI)
+#else
+# define machine_is_mahimahi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK6442
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK6442
+# endif
+# define machine_is_smdk6442()	(machine_arch_type == MACH_TYPE_SMDK6442)
+#else
+# define machine_is_smdk6442()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPENRD_BASE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPENRD_BASE
+# endif
+# define machine_is_openrd_base()	(machine_arch_type == MACH_TYPE_OPENRD_BASE)
+#else
+# define machine_is_openrd_base()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEVKIT8000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEVKIT8000
+# endif
+# define machine_is_devkit8000()	(machine_arch_type == MACH_TYPE_DEVKIT8000)
+#else
+# define machine_is_devkit8000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_EFIKAMX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_EFIKAMX
+# endif
+# define machine_is_mx51_efikamx()	(machine_arch_type == MACH_TYPE_MX51_EFIKAMX)
+#else
+# define machine_is_mx51_efikamx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM_T35
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM_T35
+# endif
+# define machine_is_cm_t35()	(machine_arch_type == MACH_TYPE_CM_T35)
+#else
+# define machine_is_cm_t35()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NET2BIG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NET2BIG
+# endif
+# define machine_is_net2big()	(machine_arch_type == MACH_TYPE_NET2BIG)
+#else
+# define machine_is_net2big()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IGEP0020
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IGEP0020
+# endif
+# define machine_is_igep0020()	(machine_arch_type == MACH_TYPE_IGEP0020)
+#else
+# define machine_is_igep0020()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NUC932EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NUC932EVB
+# endif
+# define machine_is_nuc932evb()	(machine_arch_type == MACH_TYPE_NUC932EVB)
+#else
+# define machine_is_nuc932evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPENRD_CLIENT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPENRD_CLIENT
+# endif
+# define machine_is_openrd_client()	(machine_arch_type == MACH_TYPE_OPENRD_CLIENT)
+#else
+# define machine_is_openrd_client()	(0)
+#endif
+
+#ifdef CONFIG_MACH_U8500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_U8500
+# endif
+# define machine_is_u8500()	(machine_arch_type == MACH_TYPE_U8500)
+#else
+# define machine_is_u8500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_EFIKASB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_EFIKASB
+# endif
+# define machine_is_mx51_efikasb()	(machine_arch_type == MACH_TYPE_MX51_EFIKASB)
+#else
+# define machine_is_mx51_efikasb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MARVELL_JASPER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARVELL_JASPER
+# endif
+# define machine_is_marvell_jasper()	(machine_arch_type == MACH_TYPE_MARVELL_JASPER)
+#else
+# define machine_is_marvell_jasper()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FLINT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FLINT
+# endif
+# define machine_is_flint()	(machine_arch_type == MACH_TYPE_FLINT)
+#else
+# define machine_is_flint()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAVOREVB3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAVOREVB3
+# endif
+# define machine_is_tavorevb3()	(machine_arch_type == MACH_TYPE_TAVOREVB3)
+#else
+# define machine_is_tavorevb3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOUCHBOOK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOUCHBOOK
+# endif
+# define machine_is_touchbook()	(machine_arch_type == MACH_TYPE_TOUCHBOOK)
+#else
+# define machine_is_touchbook()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RAUMFELD_RC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RAUMFELD_RC
+# endif
+# define machine_is_raumfeld_rc()	(machine_arch_type == MACH_TYPE_RAUMFELD_RC)
+#else
+# define machine_is_raumfeld_rc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RAUMFELD_CONNECTOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RAUMFELD_CONNECTOR
+# endif
+# define machine_is_raumfeld_connector()	(machine_arch_type == MACH_TYPE_RAUMFELD_CONNECTOR)
+#else
+# define machine_is_raumfeld_connector()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RAUMFELD_SPEAKER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RAUMFELD_SPEAKER
+# endif
+# define machine_is_raumfeld_speaker()	(machine_arch_type == MACH_TYPE_RAUMFELD_SPEAKER)
+#else
+# define machine_is_raumfeld_speaker()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TNETV107X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TNETV107X
+# endif
+# define machine_is_tnetv107x()	(machine_arch_type == MACH_TYPE_TNETV107X)
+#else
+# define machine_is_tnetv107x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDKV210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDKV210
+# endif
+# define machine_is_smdkv210()	(machine_arch_type == MACH_TYPE_SMDKV210)
+#else
+# define machine_is_smdkv210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_ZOOM3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_ZOOM3
+# endif
+# define machine_is_omap_zoom3()	(machine_arch_type == MACH_TYPE_OMAP_ZOOM3)
+#else
+# define machine_is_omap_zoom3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_3630SDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_3630SDP
+# endif
+# define machine_is_omap_3630sdp()	(machine_arch_type == MACH_TYPE_OMAP_3630SDP)
+#else
+# define machine_is_omap_3630sdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMARTQ7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMARTQ7
+# endif
+# define machine_is_smartq7()	(machine_arch_type == MACH_TYPE_SMARTQ7)
+#else
+# define machine_is_smartq7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WATSON_EFM_PLUGIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WATSON_EFM_PLUGIN
+# endif
+# define machine_is_watson_efm_plugin()	(machine_arch_type == MACH_TYPE_WATSON_EFM_PLUGIN)
+#else
+# define machine_is_watson_efm_plugin()	(0)
+#endif
+
+#ifdef CONFIG_MACH_G4EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_G4EVM
+# endif
+# define machine_is_g4evm()	(machine_arch_type == MACH_TYPE_G4EVM)
+#else
+# define machine_is_g4evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAPL138_HAWKBOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAPL138_HAWKBOARD
+# endif
+# define machine_is_omapl138_hawkboard()	(machine_arch_type == MACH_TYPE_OMAPL138_HAWKBOARD)
+#else
+# define machine_is_omapl138_hawkboard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS41X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS41X
+# endif
+# define machine_is_ts41x()	(machine_arch_type == MACH_TYPE_TS41X)
+#else
+# define machine_is_ts41x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PHY3250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PHY3250
+# endif
+# define machine_is_phy3250()	(machine_arch_type == MACH_TYPE_PHY3250)
+#else
+# define machine_is_phy3250()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MINI6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINI6410
+# endif
+# define machine_is_mini6410()	(machine_arch_type == MACH_TYPE_MINI6410)
+#else
+# define machine_is_mini6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX28EVK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX28EVK
+# endif
+# define machine_is_mx28evk()	(machine_arch_type == MACH_TYPE_MX28EVK)
+#else
+# define machine_is_mx28evk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMARTQ5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMARTQ5
+# endif
+# define machine_is_smartq5()	(machine_arch_type == MACH_TYPE_SMARTQ5)
+#else
+# define machine_is_smartq5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DM6467TEVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DM6467TEVM
+# endif
+# define machine_is_davinci_dm6467tevm()	(machine_arch_type == MACH_TYPE_DAVINCI_DM6467TEVM)
+#else
+# define machine_is_davinci_dm6467tevm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXT_TD60
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXT_TD60
+# endif
+# define machine_is_mxt_td60()	(machine_arch_type == MACH_TYPE_MXT_TD60)
+#else
+# define machine_is_mxt_td60()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RIOT_BEI2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RIOT_BEI2
+# endif
+# define machine_is_riot_bei2()	(machine_arch_type == MACH_TYPE_RIOT_BEI2)
+#else
+# define machine_is_riot_bei2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RIOT_X37
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RIOT_X37
+# endif
+# define machine_is_riot_x37()	(machine_arch_type == MACH_TYPE_RIOT_X37)
+#else
+# define machine_is_riot_x37()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CAPC7117
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CAPC7117
+# endif
+# define machine_is_capc7117()	(machine_arch_type == MACH_TYPE_CAPC7117)
+#else
+# define machine_is_capc7117()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ICONTROL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ICONTROL
+# endif
+# define machine_is_icontrol()	(machine_arch_type == MACH_TYPE_ICONTROL)
+#else
+# define machine_is_icontrol()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QSD8X50A_ST1_5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QSD8X50A_ST1_5
+# endif
+# define machine_is_qsd8x50a_st1_5()	(machine_arch_type == MACH_TYPE_QSD8X50A_ST1_5)
+#else
+# define machine_is_qsd8x50a_st1_5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX23EVK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX23EVK
+# endif
+# define machine_is_mx23evk()	(machine_arch_type == MACH_TYPE_MX23EVK)
+#else
+# define machine_is_mx23evk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AP4EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AP4EVB
+# endif
+# define machine_is_ap4evb()	(machine_arch_type == MACH_TYPE_AP4EVB)
+#else
+# define machine_is_ap4evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MITYOMAPL138
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MITYOMAPL138
+# endif
+# define machine_is_mityomapl138()	(machine_arch_type == MACH_TYPE_MITYOMAPL138)
+#else
+# define machine_is_mityomapl138()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GURUPLUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GURUPLUG
+# endif
+# define machine_is_guruplug()	(machine_arch_type == MACH_TYPE_GURUPLUG)
+#else
+# define machine_is_guruplug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEAR310
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEAR310
+# endif
+# define machine_is_spear310()	(machine_arch_type == MACH_TYPE_SPEAR310)
+#else
+# define machine_is_spear310()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEAR320
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEAR320
+# endif
+# define machine_is_spear320()	(machine_arch_type == MACH_TYPE_SPEAR320)
+#else
+# define machine_is_spear320()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AQUILA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AQUILA
+# endif
+# define machine_is_aquila()	(machine_arch_type == MACH_TYPE_AQUILA)
+#else
+# define machine_is_aquila()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESATA_SHEEVAPLUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESATA_SHEEVAPLUG
+# endif
+# define machine_is_sheeva_esata()	(machine_arch_type == MACH_TYPE_ESATA_SHEEVAPLUG)
+#else
+# define machine_is_sheeva_esata()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X30_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X30_SURF
+# endif
+# define machine_is_msm7x30_surf()	(machine_arch_type == MACH_TYPE_MSM7X30_SURF)
+#else
+# define machine_is_msm7x30_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EA2478DEVKIT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EA2478DEVKIT
+# endif
+# define machine_is_ea2478devkit()	(machine_arch_type == MACH_TYPE_EA2478DEVKIT)
+#else
+# define machine_is_ea2478devkit()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TERASTATION_WXL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TERASTATION_WXL
+# endif
+# define machine_is_terastation_wxl()	(machine_arch_type == MACH_TYPE_TERASTATION_WXL)
+#else
+# define machine_is_terastation_wxl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X25_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X25_SURF
+# endif
+# define machine_is_msm7x25_surf()	(machine_arch_type == MACH_TYPE_MSM7X25_SURF)
+#else
+# define machine_is_msm7x25_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X25_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X25_FFA
+# endif
+# define machine_is_msm7x25_ffa()	(machine_arch_type == MACH_TYPE_MSM7X25_FFA)
+#else
+# define machine_is_msm7x25_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X27_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X27_SURF
+# endif
+# define machine_is_msm7x27_surf()	(machine_arch_type == MACH_TYPE_MSM7X27_SURF)
+#else
+# define machine_is_msm7x27_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X27_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X27_FFA
+# endif
+# define machine_is_msm7x27_ffa()	(machine_arch_type == MACH_TYPE_MSM7X27_FFA)
+#else
+# define machine_is_msm7x27_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X30_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X30_FFA
+# endif
+# define machine_is_msm7x30_ffa()	(machine_arch_type == MACH_TYPE_MSM7X30_FFA)
+#else
+# define machine_is_msm7x30_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QSD8X50_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QSD8X50_SURF
+# endif
+# define machine_is_qsd8x50_surf()	(machine_arch_type == MACH_TYPE_QSD8X50_SURF)
+#else
+# define machine_is_qsd8x50_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX53_EVK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX53_EVK
+# endif
+# define machine_is_mx53_evk()	(machine_arch_type == MACH_TYPE_MX53_EVK)
+#else
+# define machine_is_mx53_evk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IGEP0030
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IGEP0030
+# endif
+# define machine_is_igep0030()	(machine_arch_type == MACH_TYPE_IGEP0030)
+#else
+# define machine_is_igep0030()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SBC3530
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBC3530
+# endif
+# define machine_is_sbc3530()	(machine_arch_type == MACH_TYPE_SBC3530)
+#else
+# define machine_is_sbc3530()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAARB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAARB
+# endif
+# define machine_is_saarb()	(machine_arch_type == MACH_TYPE_SAARB)
+#else
+# define machine_is_saarb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HARMONY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HARMONY
+# endif
+# define machine_is_harmony()	(machine_arch_type == MACH_TYPE_HARMONY)
+#else
+# define machine_is_harmony()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X30_FLUID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X30_FLUID
+# endif
+# define machine_is_msm7x30_fluid()	(machine_arch_type == MACH_TYPE_MSM7X30_FLUID)
+#else
+# define machine_is_msm7x30_fluid()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM_T3517
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM_T3517
+# endif
+# define machine_is_cm_t3517()	(machine_arch_type == MACH_TYPE_CM_T3517)
+#else
+# define machine_is_cm_t3517()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WBD222
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WBD222
+# endif
+# define machine_is_wbd222()	(machine_arch_type == MACH_TYPE_WBD222)
+#else
+# define machine_is_wbd222()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X60_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X60_SURF
+# endif
+# define machine_is_msm8x60_surf()	(machine_arch_type == MACH_TYPE_MSM8X60_SURF)
+#else
+# define machine_is_msm8x60_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X60_SIM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X60_SIM
+# endif
+# define machine_is_msm8x60_sim()	(machine_arch_type == MACH_TYPE_MSM8X60_SIM)
+#else
+# define machine_is_msm8x60_sim()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TCC8000_SDK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TCC8000_SDK
+# endif
+# define machine_is_tcc8000_sdk()	(machine_arch_type == MACH_TYPE_TCC8000_SDK)
+#else
+# define machine_is_tcc8000_sdk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NANOS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NANOS
+# endif
+# define machine_is_nanos()	(machine_arch_type == MACH_TYPE_NANOS)
+#else
+# define machine_is_nanos()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STAMP9G45
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STAMP9G45
+# endif
+# define machine_is_stamp9g45()	(machine_arch_type == MACH_TYPE_STAMP9G45)
+#else
+# define machine_is_stamp9g45()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CNS3420VB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CNS3420VB
+# endif
+# define machine_is_cns3420vb()	(machine_arch_type == MACH_TYPE_CNS3420VB)
+#else
+# define machine_is_cns3420vb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP4_PANDA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP4_PANDA
+# endif
+# define machine_is_omap4_panda()	(machine_arch_type == MACH_TYPE_OMAP4_PANDA)
+#else
+# define machine_is_omap4_panda()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TI8168EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TI8168EVM
+# endif
+# define machine_is_ti8168evm()	(machine_arch_type == MACH_TYPE_TI8168EVM)
+#else
+# define machine_is_ti8168evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TETON_BGA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TETON_BGA
+# endif
+# define machine_is_teton_bga()	(machine_arch_type == MACH_TYPE_TETON_BGA)
+#else
+# define machine_is_teton_bga()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EUKREA_CPUIMX25
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EUKREA_CPUIMX25
+# endif
+# define machine_is_eukrea_cpuimx25sd()	(machine_arch_type == MACH_TYPE_EUKREA_CPUIMX25)
+#else
+# define machine_is_eukrea_cpuimx25sd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EUKREA_CPUIMX35
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EUKREA_CPUIMX35
+# endif
+# define machine_is_eukrea_cpuimx35sd()	(machine_arch_type == MACH_TYPE_EUKREA_CPUIMX35)
+#else
+# define machine_is_eukrea_cpuimx35sd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EUKREA_CPUIMX51SD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EUKREA_CPUIMX51SD
+# endif
+# define machine_is_eukrea_cpuimx51sd()	(machine_arch_type == MACH_TYPE_EUKREA_CPUIMX51SD)
+#else
+# define machine_is_eukrea_cpuimx51sd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EUKREA_CPUIMX51
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EUKREA_CPUIMX51
+# endif
+# define machine_is_eukrea_cpuimx51()	(machine_arch_type == MACH_TYPE_EUKREA_CPUIMX51)
+#else
+# define machine_is_eukrea_cpuimx51()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDKC210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDKC210
+# endif
+# define machine_is_smdkc210()	(machine_arch_type == MACH_TYPE_SMDKC210)
+#else
+# define machine_is_smdkc210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_BRAILLO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_BRAILLO
+# endif
+# define machine_is_omap3_braillo()	(machine_arch_type == MACH_TYPE_OMAP3_BRAILLO)
+#else
+# define machine_is_omap3_braillo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPYPLUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPYPLUG
+# endif
+# define machine_is_spyplug()	(machine_arch_type == MACH_TYPE_SPYPLUG)
+#else
+# define machine_is_spyplug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GINGER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GINGER
+# endif
+# define machine_is_ginger()	(machine_arch_type == MACH_TYPE_GINGER)
+#else
+# define machine_is_ginger()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TNY_T3530
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TNY_T3530
+# endif
+# define machine_is_tny_t3530()	(machine_arch_type == MACH_TYPE_TNY_T3530)
+#else
+# define machine_is_tny_t3530()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCA102
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCA102
+# endif
+# define machine_is_pca102()	(machine_arch_type == MACH_TYPE_PCA102)
+#else
+# define machine_is_pca102()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPADE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPADE
+# endif
+# define machine_is_spade()	(machine_arch_type == MACH_TYPE_SPADE)
+#else
+# define machine_is_spade()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXC25_TOPAZ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXC25_TOPAZ
+# endif
+# define machine_is_mxc25_topaz()	(machine_arch_type == MACH_TYPE_MXC25_TOPAZ)
+#else
+# define machine_is_mxc25_topaz()	(0)
+#endif
+
+#ifdef CONFIG_MACH_T5325
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_T5325
+# endif
+# define machine_is_t5325()	(machine_arch_type == MACH_TYPE_T5325)
+#else
+# define machine_is_t5325()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GW2361
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GW2361
+# endif
+# define machine_is_gw2361()	(machine_arch_type == MACH_TYPE_GW2361)
+#else
+# define machine_is_gw2361()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ELOG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ELOG
+# endif
+# define machine_is_elog()	(machine_arch_type == MACH_TYPE_ELOG)
+#else
+# define machine_is_elog()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INCOME
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INCOME
+# endif
+# define machine_is_income()	(machine_arch_type == MACH_TYPE_INCOME)
+#else
+# define machine_is_income()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCM589X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCM589X
+# endif
+# define machine_is_bcm589x()	(machine_arch_type == MACH_TYPE_BCM589X)
+#else
+# define machine_is_bcm589x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ETNA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ETNA
+# endif
+# define machine_is_etna()	(machine_arch_type == MACH_TYPE_ETNA)
+#else
+# define machine_is_etna()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HAWKS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HAWKS
+# endif
+# define machine_is_hawks()	(machine_arch_type == MACH_TYPE_HAWKS)
+#else
+# define machine_is_hawks()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MESON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MESON
+# endif
+# define machine_is_meson()	(machine_arch_type == MACH_TYPE_MESON)
+#else
+# define machine_is_meson()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XSBASE255
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XSBASE255
+# endif
+# define machine_is_xsbase255()	(machine_arch_type == MACH_TYPE_XSBASE255)
+#else
+# define machine_is_xsbase255()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PVM2030
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PVM2030
+# endif
+# define machine_is_pvm2030()	(machine_arch_type == MACH_TYPE_PVM2030)
+#else
+# define machine_is_pvm2030()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIOA502
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIOA502
+# endif
+# define machine_is_mioa502()	(machine_arch_type == MACH_TYPE_MIOA502)
+#else
+# define machine_is_mioa502()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VVBOX_SDORIG2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VVBOX_SDORIG2
+# endif
+# define machine_is_vvbox_sdorig2()	(machine_arch_type == MACH_TYPE_VVBOX_SDORIG2)
+#else
+# define machine_is_vvbox_sdorig2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VVBOX_SDLITE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VVBOX_SDLITE2
+# endif
+# define machine_is_vvbox_sdlite2()	(machine_arch_type == MACH_TYPE_VVBOX_SDLITE2)
+#else
+# define machine_is_vvbox_sdlite2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VVBOX_SDPRO4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VVBOX_SDPRO4
+# endif
+# define machine_is_vvbox_sdpro4()	(machine_arch_type == MACH_TYPE_VVBOX_SDPRO4)
+#else
+# define machine_is_vvbox_sdpro4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTC_SPV_M700
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTC_SPV_M700
+# endif
+# define machine_is_htc_spv_m700()	(machine_arch_type == MACH_TYPE_HTC_SPV_M700)
+#else
+# define machine_is_htc_spv_m700()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX257SX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX257SX
+# endif
+# define machine_is_mx257sx()	(machine_arch_type == MACH_TYPE_MX257SX)
+#else
+# define machine_is_mx257sx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GONI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GONI
+# endif
+# define machine_is_goni()	(machine_arch_type == MACH_TYPE_GONI)
+#else
+# define machine_is_goni()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X55_SVLTE_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X55_SVLTE_FFA
+# endif
+# define machine_is_msm8x55_svlte_ffa()	(machine_arch_type == MACH_TYPE_MSM8X55_SVLTE_FFA)
+#else
+# define machine_is_msm8x55_svlte_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X55_SVLTE_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X55_SVLTE_SURF
+# endif
+# define machine_is_msm8x55_svlte_surf()	(machine_arch_type == MACH_TYPE_MSM8X55_SVLTE_SURF)
+#else
+# define machine_is_msm8x55_svlte_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QUICKSTEP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QUICKSTEP
+# endif
+# define machine_is_quickstep()	(machine_arch_type == MACH_TYPE_QUICKSTEP)
+#else
+# define machine_is_quickstep()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DMW96
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DMW96
+# endif
+# define machine_is_dmw96()	(machine_arch_type == MACH_TYPE_DMW96)
+#else
+# define machine_is_dmw96()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HAMMERHEAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HAMMERHEAD
+# endif
+# define machine_is_hammerhead()	(machine_arch_type == MACH_TYPE_HAMMERHEAD)
+#else
+# define machine_is_hammerhead()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRIDENT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIDENT
+# endif
+# define machine_is_trident()	(machine_arch_type == MACH_TYPE_TRIDENT)
+#else
+# define machine_is_trident()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LIGHTNING
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LIGHTNING
+# endif
+# define machine_is_lightning()	(machine_arch_type == MACH_TYPE_LIGHTNING)
+#else
+# define machine_is_lightning()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ICONNECT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ICONNECT
+# endif
+# define machine_is_iconnect()	(machine_arch_type == MACH_TYPE_ICONNECT)
+#else
+# define machine_is_iconnect()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AUTOBOT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AUTOBOT
+# endif
+# define machine_is_autobot()	(machine_arch_type == MACH_TYPE_AUTOBOT)
+#else
+# define machine_is_autobot()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COCONUT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COCONUT
+# endif
+# define machine_is_coconut()	(machine_arch_type == MACH_TYPE_COCONUT)
+#else
+# define machine_is_coconut()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DURIAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DURIAN
+# endif
+# define machine_is_durian()	(machine_arch_type == MACH_TYPE_DURIAN)
+#else
+# define machine_is_durian()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CAYENNE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CAYENNE
+# endif
+# define machine_is_cayenne()	(machine_arch_type == MACH_TYPE_CAYENNE)
+#else
+# define machine_is_cayenne()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FUJI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FUJI
+# endif
+# define machine_is_fuji()	(machine_arch_type == MACH_TYPE_FUJI)
+#else
+# define machine_is_fuji()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SYNOLOGY_6282
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SYNOLOGY_6282
+# endif
+# define machine_is_synology_6282()	(machine_arch_type == MACH_TYPE_SYNOLOGY_6282)
+#else
+# define machine_is_synology_6282()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EM1SY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EM1SY
+# endif
+# define machine_is_em1sy()	(machine_arch_type == MACH_TYPE_EM1SY)
+#else
+# define machine_is_em1sy()	(0)
+#endif
+
+#ifdef CONFIG_MACH_M502
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_M502
+# endif
+# define machine_is_m502()	(machine_arch_type == MACH_TYPE_M502)
+#else
+# define machine_is_m502()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MATRIX518
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MATRIX518
+# endif
+# define machine_is_matrix518()	(machine_arch_type == MACH_TYPE_MATRIX518)
+#else
+# define machine_is_matrix518()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TINY_GURNARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TINY_GURNARD
+# endif
+# define machine_is_tiny_gurnard()	(machine_arch_type == MACH_TYPE_TINY_GURNARD)
+#else
+# define machine_is_tiny_gurnard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEAR1310
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEAR1310
+# endif
+# define machine_is_spear1310()	(machine_arch_type == MACH_TYPE_SPEAR1310)
+#else
+# define machine_is_spear1310()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BV07
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BV07
+# endif
+# define machine_is_bv07()	(machine_arch_type == MACH_TYPE_BV07)
+#else
+# define machine_is_bv07()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXT_TD61
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXT_TD61
+# endif
+# define machine_is_mxt_td61()	(machine_arch_type == MACH_TYPE_MXT_TD61)
+#else
+# define machine_is_mxt_td61()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPENRD_ULTIMATE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPENRD_ULTIMATE
+# endif
+# define machine_is_openrd_ultimate()	(machine_arch_type == MACH_TYPE_OPENRD_ULTIMATE)
+#else
+# define machine_is_openrd_ultimate()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEVIXP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEVIXP
+# endif
+# define machine_is_devixp()	(machine_arch_type == MACH_TYPE_DEVIXP)
+#else
+# define machine_is_devixp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MICCPT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MICCPT
+# endif
+# define machine_is_miccpt()	(machine_arch_type == MACH_TYPE_MICCPT)
+#else
+# define machine_is_miccpt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIC256
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIC256
+# endif
+# define machine_is_mic256()	(machine_arch_type == MACH_TYPE_MIC256)
+#else
+# define machine_is_mic256()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AS1167
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AS1167
+# endif
+# define machine_is_as1167()	(machine_arch_type == MACH_TYPE_AS1167)
+#else
+# define machine_is_as1167()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_IBIZA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_IBIZA
+# endif
+# define machine_is_omap3_ibiza()	(machine_arch_type == MACH_TYPE_OMAP3_IBIZA)
+#else
+# define machine_is_omap3_ibiza()	(0)
+#endif
+
+#ifdef CONFIG_MACH_U5500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_U5500
+# endif
+# define machine_is_u5500()	(machine_arch_type == MACH_TYPE_U5500)
+#else
+# define machine_is_u5500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_PICTO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_PICTO
+# endif
+# define machine_is_davinci_picto()	(machine_arch_type == MACH_TYPE_DAVINCI_PICTO)
+#else
+# define machine_is_davinci_picto()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MECHA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MECHA
+# endif
+# define machine_is_mecha()	(machine_arch_type == MACH_TYPE_MECHA)
+#else
+# define machine_is_mecha()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BUBBA3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BUBBA3
+# endif
+# define machine_is_bubba3()	(machine_arch_type == MACH_TYPE_BUBBA3)
+#else
+# define machine_is_bubba3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PUPITRE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PUPITRE
+# endif
+# define machine_is_pupitre()	(machine_arch_type == MACH_TYPE_PUPITRE)
+#else
+# define machine_is_pupitre()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TEGRA_VOGUE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TEGRA_VOGUE
+# endif
+# define machine_is_tegra_vogue()	(machine_arch_type == MACH_TYPE_TEGRA_VOGUE)
+#else
+# define machine_is_tegra_vogue()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TEGRA_E1165
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TEGRA_E1165
+# endif
+# define machine_is_tegra_e1165()	(machine_arch_type == MACH_TYPE_TEGRA_E1165)
+#else
+# define machine_is_tegra_e1165()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIMPLENET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIMPLENET
+# endif
+# define machine_is_simplenet()	(machine_arch_type == MACH_TYPE_SIMPLENET)
+#else
+# define machine_is_simplenet()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EC4350TBM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EC4350TBM
+# endif
+# define machine_is_ec4350tbm()	(machine_arch_type == MACH_TYPE_EC4350TBM)
+#else
+# define machine_is_ec4350tbm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PEC_TC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PEC_TC
+# endif
+# define machine_is_pec_tc()	(machine_arch_type == MACH_TYPE_PEC_TC)
+#else
+# define machine_is_pec_tc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PEC_HC2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PEC_HC2
+# endif
+# define machine_is_pec_hc2()	(machine_arch_type == MACH_TYPE_PEC_HC2)
+#else
+# define machine_is_pec_hc2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESL_MOBILIS_A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_MOBILIS_A
+# endif
+# define machine_is_esl_mobilis_a()	(machine_arch_type == MACH_TYPE_ESL_MOBILIS_A)
+#else
+# define machine_is_esl_mobilis_a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESL_MOBILIS_B
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_MOBILIS_B
+# endif
+# define machine_is_esl_mobilis_b()	(machine_arch_type == MACH_TYPE_ESL_MOBILIS_B)
+#else
+# define machine_is_esl_mobilis_b()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESL_WAVE_A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_WAVE_A
+# endif
+# define machine_is_esl_wave_a()	(machine_arch_type == MACH_TYPE_ESL_WAVE_A)
+#else
+# define machine_is_esl_wave_a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESL_WAVE_B
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_WAVE_B
+# endif
+# define machine_is_esl_wave_b()	(machine_arch_type == MACH_TYPE_ESL_WAVE_B)
+#else
+# define machine_is_esl_wave_b()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UNISENSE_MMM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UNISENSE_MMM
+# endif
+# define machine_is_unisense_mmm()	(machine_arch_type == MACH_TYPE_UNISENSE_MMM)
+#else
+# define machine_is_unisense_mmm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLUESHARK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLUESHARK
+# endif
+# define machine_is_blueshark()	(machine_arch_type == MACH_TYPE_BLUESHARK)
+#else
+# define machine_is_blueshark()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E10
+# endif
+# define machine_is_e10()	(machine_arch_type == MACH_TYPE_E10)
+#else
+# define machine_is_e10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APP3K_ROBIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APP3K_ROBIN
+# endif
+# define machine_is_app3k_robin()	(machine_arch_type == MACH_TYPE_APP3K_ROBIN)
+#else
+# define machine_is_app3k_robin()	(0)
+#endif
+
+#ifdef CONFIG_MACH_POV15HD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POV15HD
+# endif
+# define machine_is_pov15hd()	(machine_arch_type == MACH_TYPE_POV15HD)
+#else
+# define machine_is_pov15hd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STELLA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STELLA
+# endif
+# define machine_is_stella()	(machine_arch_type == MACH_TYPE_STELLA)
+#else
+# define machine_is_stella()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LINKSTATION_LSCHL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LINKSTATION_LSCHL
+# endif
+# define machine_is_linkstation_lschl()	(machine_arch_type == MACH_TYPE_LINKSTATION_LSCHL)
+#else
+# define machine_is_linkstation_lschl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETWALKER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETWALKER
+# endif
+# define machine_is_netwalker()	(machine_arch_type == MACH_TYPE_NETWALKER)
+#else
+# define machine_is_netwalker()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACSX106
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACSX106
+# endif
+# define machine_is_acsx106()	(machine_arch_type == MACH_TYPE_ACSX106)
+#else
+# define machine_is_acsx106()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATLAS5_C1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATLAS5_C1
+# endif
+# define machine_is_atlas5_c1()	(machine_arch_type == MACH_TYPE_ATLAS5_C1)
+#else
+# define machine_is_atlas5_c1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NSB3AST
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NSB3AST
+# endif
+# define machine_is_nsb3ast()	(machine_arch_type == MACH_TYPE_NSB3AST)
+#else
+# define machine_is_nsb3ast()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GNET_SLC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GNET_SLC
+# endif
+# define machine_is_gnet_slc()	(machine_arch_type == MACH_TYPE_GNET_SLC)
+#else
+# define machine_is_gnet_slc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AF4000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AF4000
+# endif
+# define machine_is_af4000()	(machine_arch_type == MACH_TYPE_AF4000)
+#else
+# define machine_is_af4000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARK9431
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARK9431
+# endif
+# define machine_is_ark9431()	(machine_arch_type == MACH_TYPE_ARK9431)
+#else
+# define machine_is_ark9431()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FS_S5PC100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FS_S5PC100
+# endif
+# define machine_is_fs_s5pc100()	(machine_arch_type == MACH_TYPE_FS_S5PC100)
+#else
+# define machine_is_fs_s5pc100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3505NOVA8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3505NOVA8
+# endif
+# define machine_is_omap3505nova8()	(machine_arch_type == MACH_TYPE_OMAP3505NOVA8)
+#else
+# define machine_is_omap3505nova8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3621_EDP1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3621_EDP1
+# endif
+# define machine_is_omap3621_edp1()	(machine_arch_type == MACH_TYPE_OMAP3621_EDP1)
+#else
+# define machine_is_omap3621_edp1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ORATISAES
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ORATISAES
+# endif
+# define machine_is_oratisaes()	(machine_arch_type == MACH_TYPE_ORATISAES)
+#else
+# define machine_is_oratisaes()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDKV310
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDKV310
+# endif
+# define machine_is_smdkv310()	(machine_arch_type == MACH_TYPE_SMDKV310)
+#else
+# define machine_is_smdkv310()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIEMENS_L0
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIEMENS_L0
+# endif
+# define machine_is_siemens_l0()	(machine_arch_type == MACH_TYPE_SIEMENS_L0)
+#else
+# define machine_is_siemens_l0()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VENTANA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VENTANA
+# endif
+# define machine_is_ventana()	(machine_arch_type == MACH_TYPE_VENTANA)
+#else
+# define machine_is_ventana()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WM8505_7IN_NETBOOK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WM8505_7IN_NETBOOK
+# endif
+# define machine_is_wm8505_7in_netbook()	(machine_arch_type == MACH_TYPE_WM8505_7IN_NETBOOK)
+#else
+# define machine_is_wm8505_7in_netbook()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EC4350SDB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EC4350SDB
+# endif
+# define machine_is_ec4350sdb()	(machine_arch_type == MACH_TYPE_EC4350SDB)
+#else
+# define machine_is_ec4350sdb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIMAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIMAS
+# endif
+# define machine_is_mimas()	(machine_arch_type == MACH_TYPE_MIMAS)
+#else
+# define machine_is_mimas()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TITAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TITAN
+# endif
+# define machine_is_titan()	(machine_arch_type == MACH_TYPE_TITAN)
+#else
+# define machine_is_titan()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CRANEBOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CRANEBOARD
+# endif
+# define machine_is_craneboard()	(machine_arch_type == MACH_TYPE_CRANEBOARD)
+#else
+# define machine_is_craneboard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ES2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ES2440
+# endif
+# define machine_is_es2440()	(machine_arch_type == MACH_TYPE_ES2440)
+#else
+# define machine_is_es2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAJAY_A9263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAJAY_A9263
+# endif
+# define machine_is_najay_a9263()	(machine_arch_type == MACH_TYPE_NAJAY_A9263)
+#else
+# define machine_is_najay_a9263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCTORNADO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCTORNADO
+# endif
+# define machine_is_htctornado()	(machine_arch_type == MACH_TYPE_HTCTORNADO)
+#else
+# define machine_is_htctornado()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DIMM_MX257
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DIMM_MX257
+# endif
+# define machine_is_dimm_mx257()	(machine_arch_type == MACH_TYPE_DIMM_MX257)
+#else
+# define machine_is_dimm_mx257()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JIGEN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JIGEN
+# endif
+# define machine_is_jigen301()	(machine_arch_type == MACH_TYPE_JIGEN)
+#else
+# define machine_is_jigen301()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK6450
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK6450
+# endif
+# define machine_is_smdk6450()	(machine_arch_type == MACH_TYPE_SMDK6450)
+#else
+# define machine_is_smdk6450()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MENO_QNG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MENO_QNG
+# endif
+# define machine_is_meno_qng()	(machine_arch_type == MACH_TYPE_MENO_QNG)
+#else
+# define machine_is_meno_qng()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NS2416
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NS2416
+# endif
+# define machine_is_ns2416()	(machine_arch_type == MACH_TYPE_NS2416)
+#else
+# define machine_is_ns2416()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RPC353
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RPC353
+# endif
+# define machine_is_rpc353()	(machine_arch_type == MACH_TYPE_RPC353)
+#else
+# define machine_is_rpc353()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TQ6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TQ6410
+# endif
+# define machine_is_tq6410()	(machine_arch_type == MACH_TYPE_TQ6410)
+#else
+# define machine_is_tq6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SKY6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SKY6410
+# endif
+# define machine_is_sky6410()	(machine_arch_type == MACH_TYPE_SKY6410)
+#else
+# define machine_is_sky6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DYNASTY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DYNASTY
+# endif
+# define machine_is_dynasty()	(machine_arch_type == MACH_TYPE_DYNASTY)
+#else
+# define machine_is_dynasty()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VIVO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VIVO
+# endif
+# define machine_is_vivo()	(machine_arch_type == MACH_TYPE_VIVO)
+#else
+# define machine_is_vivo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BURY_BL7582
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BURY_BL7582
+# endif
+# define machine_is_bury_bl7582()	(machine_arch_type == MACH_TYPE_BURY_BL7582)
+#else
+# define machine_is_bury_bl7582()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BURY_BPS5270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BURY_BPS5270
+# endif
+# define machine_is_bury_bps5270()	(machine_arch_type == MACH_TYPE_BURY_BPS5270)
+#else
+# define machine_is_bury_bps5270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BASI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BASI
+# endif
+# define machine_is_basi()	(machine_arch_type == MACH_TYPE_BASI)
+#else
+# define machine_is_basi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TN200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TN200
+# endif
+# define machine_is_tn200()	(machine_arch_type == MACH_TYPE_TN200)
+#else
+# define machine_is_tn200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_M3MMI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_C2MMI
+# endif
+# define machine_is_c2mmi()	(machine_arch_type == MACH_TYPE_C2MMI)
+#else
+# define machine_is_c2mmi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MESON_6236M
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MESON_6236M
+# endif
+# define machine_is_meson_6236m()	(machine_arch_type == MACH_TYPE_MESON_6236M)
+#else
+# define machine_is_meson_6236m()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MESON_8626M
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MESON_8626M
+# endif
+# define machine_is_meson_8626m()	(machine_arch_type == MACH_TYPE_MESON_8626M)
+#else
+# define machine_is_meson_8626m()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TUBE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TUBE
+# endif
+# define machine_is_tube()	(machine_arch_type == MACH_TYPE_TUBE)
+#else
+# define machine_is_tube()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MESSINA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MESSINA
+# endif
+# define machine_is_messina()	(machine_arch_type == MACH_TYPE_MESSINA)
+#else
+# define machine_is_messina()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX50_ARM2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX50_ARM2
+# endif
+# define machine_is_mx50_arm2()	(machine_arch_type == MACH_TYPE_MX50_ARM2)
+#else
+# define machine_is_mx50_arm2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CETUS9263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CETUS9263
+# endif
+# define machine_is_cetus9263()	(machine_arch_type == MACH_TYPE_CETUS9263)
+#else
+# define machine_is_cetus9263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BROWNSTONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BROWNSTONE
+# endif
+# define machine_is_brownstone()	(machine_arch_type == MACH_TYPE_BROWNSTONE)
+#else
+# define machine_is_brownstone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VMX25
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VMX25
+# endif
+# define machine_is_vmx25()	(machine_arch_type == MACH_TYPE_VMX25)
+#else
+# define machine_is_vmx25()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VMX51
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VMX51
+# endif
+# define machine_is_vmx51()	(machine_arch_type == MACH_TYPE_VMX51)
+#else
+# define machine_is_vmx51()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ABACUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ABACUS
+# endif
+# define machine_is_abacus()	(machine_arch_type == MACH_TYPE_ABACUS)
+#else
+# define machine_is_abacus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM4745
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM4745
+# endif
+# define machine_is_cm4745()	(machine_arch_type == MACH_TYPE_CM4745)
+#else
+# define machine_is_cm4745()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ORATISLINK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ORATISLINK
+# endif
+# define machine_is_oratislink()	(machine_arch_type == MACH_TYPE_ORATISLINK)
+#else
+# define machine_is_oratislink()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DM365_DVR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DM365_DVR
+# endif
+# define machine_is_davinci_dm365_dvr()	(machine_arch_type == MACH_TYPE_DAVINCI_DM365_DVR)
+#else
+# define machine_is_davinci_dm365_dvr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETVIZ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETVIZ
+# endif
+# define machine_is_netviz()	(machine_arch_type == MACH_TYPE_NETVIZ)
+#else
+# define machine_is_netviz()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FLEXIBITY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FLEXIBITY
+# endif
+# define machine_is_flexibity()	(machine_arch_type == MACH_TYPE_FLEXIBITY)
+#else
+# define machine_is_flexibity()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WLAN_COMPUTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WLAN_COMPUTER
+# endif
+# define machine_is_wlan_computer()	(machine_arch_type == MACH_TYPE_WLAN_COMPUTER)
+#else
+# define machine_is_wlan_computer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPC24XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPC24XX
+# endif
+# define machine_is_lpc24xx()	(machine_arch_type == MACH_TYPE_LPC24XX)
+#else
+# define machine_is_lpc24xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPICA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPICA
+# endif
+# define machine_is_spica()	(machine_arch_type == MACH_TYPE_SPICA)
+#else
+# define machine_is_spica()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GPSDISPLAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GPSDISPLAY
+# endif
+# define machine_is_gpsdisplay()	(machine_arch_type == MACH_TYPE_GPSDISPLAY)
+#else
+# define machine_is_gpsdisplay()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BIPNET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BIPNET
+# endif
+# define machine_is_bipnet()	(machine_arch_type == MACH_TYPE_BIPNET)
+#else
+# define machine_is_bipnet()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OVERO_CTU_INERTIAL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OVERO_CTU_INERTIAL
+# endif
+# define machine_is_overo_ctu_inertial()	(machine_arch_type == MACH_TYPE_OVERO_CTU_INERTIAL)
+#else
+# define machine_is_overo_ctu_inertial()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DM355_MMM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DM355_MMM
+# endif
+# define machine_is_davinci_dm355_mmm()	(machine_arch_type == MACH_TYPE_DAVINCI_DM355_MMM)
+#else
+# define machine_is_davinci_dm355_mmm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PC9260_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PC9260_V2
+# endif
+# define machine_is_pc9260_v2()	(machine_arch_type == MACH_TYPE_PC9260_V2)
+#else
+# define machine_is_pc9260_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PTX7545
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PTX7545
+# endif
+# define machine_is_ptx7545()	(machine_arch_type == MACH_TYPE_PTX7545)
+#else
+# define machine_is_ptx7545()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TM_EFDC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TM_EFDC
+# endif
+# define machine_is_tm_efdc()	(machine_arch_type == MACH_TYPE_TM_EFDC)
+#else
+# define machine_is_tm_efdc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_WALDO1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_WALDO1
+# endif
+# define machine_is_omap3_waldo1()	(machine_arch_type == MACH_TYPE_OMAP3_WALDO1)
+#else
+# define machine_is_omap3_waldo1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FLYER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FLYER
+# endif
+# define machine_is_flyer()	(machine_arch_type == MACH_TYPE_FLYER)
+#else
+# define machine_is_flyer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TORNADO3240
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TORNADO3240
+# endif
+# define machine_is_tornado3240()	(machine_arch_type == MACH_TYPE_TORNADO3240)
+#else
+# define machine_is_tornado3240()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SOLI_01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SOLI_01
+# endif
+# define machine_is_soli_01()	(machine_arch_type == MACH_TYPE_SOLI_01)
+#else
+# define machine_is_soli_01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAPL138_EUROPALC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAPL138_EUROPALC
+# endif
+# define machine_is_omapl138_europalc()	(machine_arch_type == MACH_TYPE_OMAPL138_EUROPALC)
+#else
+# define machine_is_omapl138_europalc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HELIOS_V1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HELIOS_V1
+# endif
+# define machine_is_helios_v1()	(machine_arch_type == MACH_TYPE_HELIOS_V1)
+#else
+# define machine_is_helios_v1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETSPACE_LITE_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETSPACE_LITE_V2
+# endif
+# define machine_is_netspace_lite_v2()	(machine_arch_type == MACH_TYPE_NETSPACE_LITE_V2)
+#else
+# define machine_is_netspace_lite_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SSC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SSC
+# endif
+# define machine_is_ssc()	(machine_arch_type == MACH_TYPE_SSC)
+#else
+# define machine_is_ssc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PREMIERWAVE_EN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PREMIERWAVE_EN
+# endif
+# define machine_is_premierwave_en()	(machine_arch_type == MACH_TYPE_PREMIERWAVE_EN)
+#else
+# define machine_is_premierwave_en()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WASABI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WASABI
+# endif
+# define machine_is_wasabi()	(machine_arch_type == MACH_TYPE_WASABI)
+#else
+# define machine_is_wasabi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX50_RDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX50_RDP
+# endif
+# define machine_is_mx50_rdp()	(machine_arch_type == MACH_TYPE_MX50_RDP)
+#else
+# define machine_is_mx50_rdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UNIVERSAL_C210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UNIVERSAL_C210
+# endif
+# define machine_is_universal_c210()	(machine_arch_type == MACH_TYPE_UNIVERSAL_C210)
+#else
+# define machine_is_universal_c210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REAL6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REAL6410
+# endif
+# define machine_is_real6410()	(machine_arch_type == MACH_TYPE_REAL6410)
+#else
+# define machine_is_real6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPX_SAKURA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPX_SAKURA
+# endif
+# define machine_is_spx_sakura()	(machine_arch_type == MACH_TYPE_SPX_SAKURA)
+#else
+# define machine_is_spx_sakura()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IJ3K_2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IJ3K_2440
+# endif
+# define machine_is_ij3k_2440()	(machine_arch_type == MACH_TYPE_IJ3K_2440)
+#else
+# define machine_is_ij3k_2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_BC10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_BC10
+# endif
+# define machine_is_omap3_bc10()	(machine_arch_type == MACH_TYPE_OMAP3_BC10)
+#else
+# define machine_is_omap3_bc10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_THEBE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_THEBE
+# endif
+# define machine_is_thebe()	(machine_arch_type == MACH_TYPE_THEBE)
+#else
+# define machine_is_thebe()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RV082
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RV082
+# endif
+# define machine_is_rv082()	(machine_arch_type == MACH_TYPE_RV082)
+#else
+# define machine_is_rv082()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMLGUEST
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMLGUEST
+# endif
+# define machine_is_armlguest()	(machine_arch_type == MACH_TYPE_ARMLGUEST)
+#else
+# define machine_is_armlguest()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TJINC1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TJINC1000
+# endif
+# define machine_is_tjinc1000()	(machine_arch_type == MACH_TYPE_TJINC1000)
+#else
+# define machine_is_tjinc1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DOCKSTAR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DOCKSTAR
+# endif
+# define machine_is_dockstar()	(machine_arch_type == MACH_TYPE_DOCKSTAR)
+#else
+# define machine_is_dockstar()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AX8008
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AX8008
+# endif
+# define machine_is_ax8008()	(machine_arch_type == MACH_TYPE_AX8008)
+#else
+# define machine_is_ax8008()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GNET_SGCE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GNET_SGCE
+# endif
+# define machine_is_gnet_sgce()	(machine_arch_type == MACH_TYPE_GNET_SGCE)
+#else
+# define machine_is_gnet_sgce()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PXWNAS_500_1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PXWNAS_500_1000
+# endif
+# define machine_is_pxwnas_500_1000()	(machine_arch_type == MACH_TYPE_PXWNAS_500_1000)
+#else
+# define machine_is_pxwnas_500_1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EA20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EA20
+# endif
+# define machine_is_ea20()	(machine_arch_type == MACH_TYPE_EA20)
+#else
+# define machine_is_ea20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AWM2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AWM2
+# endif
+# define machine_is_awm2()	(machine_arch_type == MACH_TYPE_AWM2)
+#else
+# define machine_is_awm2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TI8148EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TI8148EVM
+# endif
+# define machine_is_ti8148evm()	(machine_arch_type == MACH_TYPE_TI8148EVM)
+#else
+# define machine_is_ti8148evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SEABOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SEABOARD
+# endif
+# define machine_is_seaboard()	(machine_arch_type == MACH_TYPE_SEABOARD)
+#else
+# define machine_is_seaboard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LINKSTATION_CHLV2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LINKSTATION_CHLV2
+# endif
+# define machine_is_linkstation_chlv2()	(machine_arch_type == MACH_TYPE_LINKSTATION_CHLV2)
+#else
+# define machine_is_linkstation_chlv2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TERA_PRO2_RACK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TERA_PRO2_RACK
+# endif
+# define machine_is_tera_pro2_rack()	(machine_arch_type == MACH_TYPE_TERA_PRO2_RACK)
+#else
+# define machine_is_tera_pro2_rack()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RUBYS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RUBYS
+# endif
+# define machine_is_rubys()	(machine_arch_type == MACH_TYPE_RUBYS)
+#else
+# define machine_is_rubys()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AQUARIUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AQUARIUS
+# endif
+# define machine_is_aquarius()	(machine_arch_type == MACH_TYPE_AQUARIUS)
+#else
+# define machine_is_aquarius()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX53_ARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX53_ARD
+# endif
+# define machine_is_mx53_ard()	(machine_arch_type == MACH_TYPE_MX53_ARD)
+#else
+# define machine_is_mx53_ard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX53_SMD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX53_SMD
+# endif
+# define machine_is_mx53_smd()	(machine_arch_type == MACH_TYPE_MX53_SMD)
+#else
+# define machine_is_mx53_smd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LSWXL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LSWXL
+# endif
+# define machine_is_lswxl()	(machine_arch_type == MACH_TYPE_LSWXL)
+#else
+# define machine_is_lswxl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DOVE_AVNG_V3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DOVE_AVNG_V3
+# endif
+# define machine_is_dove_avng_v3()	(machine_arch_type == MACH_TYPE_DOVE_AVNG_V3)
+#else
+# define machine_is_dove_avng_v3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SDI_ESS_9263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SDI_ESS_9263
+# endif
+# define machine_is_sdi_ess_9263()	(machine_arch_type == MACH_TYPE_SDI_ESS_9263)
+#else
+# define machine_is_sdi_ess_9263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JOCPU550
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JOCPU550
+# endif
+# define machine_is_jocpu550()	(machine_arch_type == MACH_TYPE_JOCPU550)
+#else
+# define machine_is_jocpu550()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X60_RUMI3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X60_RUMI3
+# endif
+# define machine_is_msm8x60_rumi3()	(machine_arch_type == MACH_TYPE_MSM8X60_RUMI3)
+#else
+# define machine_is_msm8x60_rumi3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X60_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X60_FFA
+# endif
+# define machine_is_msm8x60_ffa()	(machine_arch_type == MACH_TYPE_MSM8X60_FFA)
+#else
+# define machine_is_msm8x60_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_YANOMAMI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_YANOMAMI
+# endif
+# define machine_is_yanomami()	(machine_arch_type == MACH_TYPE_YANOMAMI)
+#else
+# define machine_is_yanomami()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GTA04
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GTA04
+# endif
+# define machine_is_gta04()	(machine_arch_type == MACH_TYPE_GTA04)
+#else
+# define machine_is_gta04()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM_A510
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM_A510
+# endif
+# define machine_is_cm_a510()	(machine_arch_type == MACH_TYPE_CM_A510)
+#else
+# define machine_is_cm_a510()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_RFS200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_RFS200
+# endif
+# define machine_is_omap3_rfs200()	(machine_arch_type == MACH_TYPE_OMAP3_RFS200)
+#else
+# define machine_is_omap3_rfs200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KX33XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KX33XX
+# endif
+# define machine_is_kx33xx()	(machine_arch_type == MACH_TYPE_KX33XX)
+#else
+# define machine_is_kx33xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PTX7510
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PTX7510
+# endif
+# define machine_is_ptx7510()	(machine_arch_type == MACH_TYPE_PTX7510)
+#else
+# define machine_is_ptx7510()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOP9000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOP9000
+# endif
+# define machine_is_top9000()	(machine_arch_type == MACH_TYPE_TOP9000)
+#else
+# define machine_is_top9000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TEENOTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TEENOTE
+# endif
+# define machine_is_teenote()	(machine_arch_type == MACH_TYPE_TEENOTE)
+#else
+# define machine_is_teenote()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS3
+# endif
+# define machine_is_ts3()	(machine_arch_type == MACH_TYPE_TS3)
+#else
+# define machine_is_ts3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A0
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A0
+# endif
+# define machine_is_a0()	(machine_arch_type == MACH_TYPE_A0)
+#else
+# define machine_is_a0()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FSM9XXX_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FSM9XXX_SURF
+# endif
+# define machine_is_fsm9xxx_surf()	(machine_arch_type == MACH_TYPE_FSM9XXX_SURF)
+#else
+# define machine_is_fsm9xxx_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FSM9XXX_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FSM9XXX_FFA
+# endif
+# define machine_is_fsm9xxx_ffa()	(machine_arch_type == MACH_TYPE_FSM9XXX_FFA)
+#else
+# define machine_is_fsm9xxx_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FRRHWCDMA60W
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FRRHWCDMA60W
+# endif
+# define machine_is_frrhwcdma60w()	(machine_arch_type == MACH_TYPE_FRRHWCDMA60W)
+#else
+# define machine_is_frrhwcdma60w()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REMUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REMUS
+# endif
+# define machine_is_remus()	(machine_arch_type == MACH_TYPE_REMUS)
+#else
+# define machine_is_remus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91CAP7XDK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91CAP7XDK
+# endif
+# define machine_is_at91cap7xdk()	(machine_arch_type == MACH_TYPE_AT91CAP7XDK)
+#else
+# define machine_is_at91cap7xdk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91CAP7STK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91CAP7STK
+# endif
+# define machine_is_at91cap7stk()	(machine_arch_type == MACH_TYPE_AT91CAP7STK)
+#else
+# define machine_is_at91cap7stk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KT_SBC_SAM9_1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KT_SBC_SAM9_1
+# endif
+# define machine_is_kt_sbc_sam9_1()	(machine_arch_type == MACH_TYPE_KT_SBC_SAM9_1)
+#else
+# define machine_is_kt_sbc_sam9_1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMADA_XP_DB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMADA_XP_DB
+# endif
+# define machine_is_armada_xp_db()	(machine_arch_type == MACH_TYPE_ARMADA_XP_DB)
+#else
+# define machine_is_armada_xp_db()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPDM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPDM
+# endif
+# define machine_is_spdm()	(machine_arch_type == MACH_TYPE_SPDM)
+#else
+# define machine_is_spdm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GTIB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GTIB
+# endif
+# define machine_is_gtib()	(machine_arch_type == MACH_TYPE_GTIB)
+#else
+# define machine_is_gtib()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DGM3240
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DGM3240
+# endif
+# define machine_is_dgm3240()	(machine_arch_type == MACH_TYPE_DGM3240)
+#else
+# define machine_is_dgm3240()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCMEGA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCMEGA
+# endif
+# define machine_is_htcmega()	(machine_arch_type == MACH_TYPE_HTCMEGA)
+#else
+# define machine_is_htcmega()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRICORDER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRICORDER
+# endif
+# define machine_is_tricorder()	(machine_arch_type == MACH_TYPE_TRICORDER)
+#else
+# define machine_is_tricorder()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TX28
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TX28
+# endif
+# define machine_is_tx28()	(machine_arch_type == MACH_TYPE_TX28)
+#else
+# define machine_is_tx28()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BSTBRD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BSTBRD
+# endif
+# define machine_is_bstbrd()	(machine_arch_type == MACH_TYPE_BSTBRD)
+#else
+# define machine_is_bstbrd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PWB3090
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PWB3090
+# endif
+# define machine_is_pwb3090()	(machine_arch_type == MACH_TYPE_PWB3090)
+#else
+# define machine_is_pwb3090()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IDEA6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IDEA6410
+# endif
+# define machine_is_idea6410()	(machine_arch_type == MACH_TYPE_IDEA6410)
+#else
+# define machine_is_idea6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QBC9263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QBC9263
+# endif
+# define machine_is_qbc9263()	(machine_arch_type == MACH_TYPE_QBC9263)
+#else
+# define machine_is_qbc9263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BORABORA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BORABORA
+# endif
+# define machine_is_borabora()	(machine_arch_type == MACH_TYPE_BORABORA)
+#else
+# define machine_is_borabora()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VALDEZ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VALDEZ
+# endif
+# define machine_is_valdez()	(machine_arch_type == MACH_TYPE_VALDEZ)
+#else
+# define machine_is_valdez()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LS9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LS9G20
+# endif
+# define machine_is_ls9g20()	(machine_arch_type == MACH_TYPE_LS9G20)
+#else
+# define machine_is_ls9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIOS_V1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIOS_V1
+# endif
+# define machine_is_mios_v1()	(machine_arch_type == MACH_TYPE_MIOS_V1)
+#else
+# define machine_is_mios_v1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S5PC110_CRESPO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S5PC110_CRESPO
+# endif
+# define machine_is_s5pc110_crespo()	(machine_arch_type == MACH_TYPE_S5PC110_CRESPO)
+#else
+# define machine_is_s5pc110_crespo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CONTROLTEK9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CONTROLTEK9G20
+# endif
+# define machine_is_controltek9g20()	(machine_arch_type == MACH_TYPE_CONTROLTEK9G20)
+#else
+# define machine_is_controltek9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TIN307
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TIN307
+# endif
+# define machine_is_tin307()	(machine_arch_type == MACH_TYPE_TIN307)
+#else
+# define machine_is_tin307()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TIN510
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TIN510
+# endif
+# define machine_is_tin510()	(machine_arch_type == MACH_TYPE_TIN510)
+#else
+# define machine_is_tin510()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLUECHEESE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLUECHEESE
+# endif
+# define machine_is_bluecheese()	(machine_arch_type == MACH_TYPE_BLUECHEESE)
+#else
+# define machine_is_bluecheese()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TEM3X30
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TEM3X30
+# endif
+# define machine_is_tem3x30()	(machine_arch_type == MACH_TYPE_TEM3X30)
+#else
+# define machine_is_tem3x30()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HARVEST_DESOTO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HARVEST_DESOTO
+# endif
+# define machine_is_harvest_desoto()	(machine_arch_type == MACH_TYPE_HARVEST_DESOTO)
+#else
+# define machine_is_harvest_desoto()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X60_QRDC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X60_QRDC
+# endif
+# define machine_is_msm8x60_qrdc()	(machine_arch_type == MACH_TYPE_MSM8X60_QRDC)
+#else
+# define machine_is_msm8x60_qrdc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEAR900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEAR900
+# endif
+# define machine_is_spear900()	(machine_arch_type == MACH_TYPE_SPEAR900)
+#else
+# define machine_is_spear900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCONTROL_G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCONTROL_G20
+# endif
+# define machine_is_pcontrol_g20()	(machine_arch_type == MACH_TYPE_PCONTROL_G20)
+#else
+# define machine_is_pcontrol_g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RDSTOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RDSTOR
+# endif
+# define machine_is_rdstor()	(machine_arch_type == MACH_TYPE_RDSTOR)
+#else
+# define machine_is_rdstor()	(0)
+#endif
+
+#ifdef CONFIG_MACH_USDLOADER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_USDLOADER
+# endif
+# define machine_is_usdloader()	(machine_arch_type == MACH_TYPE_USDLOADER)
+#else
+# define machine_is_usdloader()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TSOPLOADER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TSOPLOADER
+# endif
+# define machine_is_tsoploader()	(machine_arch_type == MACH_TYPE_TSOPLOADER)
+#else
+# define machine_is_tsoploader()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KRONOS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KRONOS
+# endif
+# define machine_is_kronos()	(machine_arch_type == MACH_TYPE_KRONOS)
+#else
+# define machine_is_kronos()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FFCORE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FFCORE
+# endif
+# define machine_is_ffcore()	(machine_arch_type == MACH_TYPE_FFCORE)
+#else
+# define machine_is_ffcore()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MONE
+# endif
+# define machine_is_mone()	(machine_arch_type == MACH_TYPE_MONE)
+#else
+# define machine_is_mone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UNIT2S
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UNIT2S
+# endif
+# define machine_is_unit2s()	(machine_arch_type == MACH_TYPE_UNIT2S)
+#else
+# define machine_is_unit2s()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACER_A5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACER_A5
+# endif
+# define machine_is_acer_a5()	(machine_arch_type == MACH_TYPE_ACER_A5)
+#else
+# define machine_is_acer_a5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ETHERPRO_ISP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ETHERPRO_ISP
+# endif
+# define machine_is_etherpro_isp()	(machine_arch_type == MACH_TYPE_ETHERPRO_ISP)
+#else
+# define machine_is_etherpro_isp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STRETCHS7000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STRETCHS7000
+# endif
+# define machine_is_stretchs7000()	(machine_arch_type == MACH_TYPE_STRETCHS7000)
+#else
+# define machine_is_stretchs7000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_P87_SMARTSIM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_P87_SMARTSIM
+# endif
+# define machine_is_p87_smartsim()	(machine_arch_type == MACH_TYPE_P87_SMARTSIM)
+#else
+# define machine_is_p87_smartsim()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TULIP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TULIP
+# endif
+# define machine_is_tulip()	(machine_arch_type == MACH_TYPE_TULIP)
+#else
+# define machine_is_tulip()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SUNFLOWER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SUNFLOWER
+# endif
+# define machine_is_sunflower()	(machine_arch_type == MACH_TYPE_SUNFLOWER)
+#else
+# define machine_is_sunflower()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RIB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RIB
+# endif
+# define machine_is_rib()	(machine_arch_type == MACH_TYPE_RIB)
+#else
+# define machine_is_rib()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CLOD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CLOD
+# endif
+# define machine_is_clod()	(machine_arch_type == MACH_TYPE_CLOD)
+#else
+# define machine_is_clod()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RUMP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RUMP
+# endif
+# define machine_is_rump()	(machine_arch_type == MACH_TYPE_RUMP)
+#else
+# define machine_is_rump()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TENDERLOIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TENDERLOIN
+# endif
+# define machine_is_tenderloin()	(machine_arch_type == MACH_TYPE_TENDERLOIN)
+#else
+# define machine_is_tenderloin()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHORTLOIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHORTLOIN
+# endif
+# define machine_is_shortloin()	(machine_arch_type == MACH_TYPE_SHORTLOIN)
+#else
+# define machine_is_shortloin()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ANTARES
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANTARES
+# endif
+# define machine_is_antares()	(machine_arch_type == MACH_TYPE_ANTARES)
+#else
+# define machine_is_antares()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WB40N
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WB40N
+# endif
+# define machine_is_wb40n()	(machine_arch_type == MACH_TYPE_WB40N)
+#else
+# define machine_is_wb40n()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HERRING
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HERRING
+# endif
+# define machine_is_herring()	(machine_arch_type == MACH_TYPE_HERRING)
+#else
+# define machine_is_herring()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAXY400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAXY400
+# endif
+# define machine_is_naxy400()	(machine_arch_type == MACH_TYPE_NAXY400)
+#else
+# define machine_is_naxy400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAXY1200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAXY1200
+# endif
+# define machine_is_naxy1200()	(machine_arch_type == MACH_TYPE_NAXY1200)
+#else
+# define machine_is_naxy1200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VPR200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VPR200
+# endif
+# define machine_is_vpr200()	(machine_arch_type == MACH_TYPE_VPR200)
+#else
+# define machine_is_vpr200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BUG20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BUG20
+# endif
+# define machine_is_bug20()	(machine_arch_type == MACH_TYPE_BUG20)
+#else
+# define machine_is_bug20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GOFLEXNET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GOFLEXNET
+# endif
+# define machine_is_goflexnet()	(machine_arch_type == MACH_TYPE_GOFLEXNET)
+#else
+# define machine_is_goflexnet()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TORBRECK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TORBRECK
+# endif
+# define machine_is_torbreck()	(machine_arch_type == MACH_TYPE_TORBRECK)
+#else
+# define machine_is_torbreck()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAARB_MG1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAARB_MG1
+# endif
+# define machine_is_saarb_mg1()	(machine_arch_type == MACH_TYPE_SAARB_MG1)
+#else
+# define machine_is_saarb_mg1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CALLISTO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CALLISTO
+# endif
+# define machine_is_callisto()	(machine_arch_type == MACH_TYPE_CALLISTO)
+#else
+# define machine_is_callisto()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MULTHSU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MULTHSU
+# endif
+# define machine_is_multhsu()	(machine_arch_type == MACH_TYPE_MULTHSU)
+#else
+# define machine_is_multhsu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SALUDA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SALUDA
+# endif
+# define machine_is_saluda()	(machine_arch_type == MACH_TYPE_SALUDA)
+#else
+# define machine_is_saluda()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PEMP_OMAP3_APOLLO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PEMP_OMAP3_APOLLO
+# endif
+# define machine_is_pemp_omap3_apollo()	(machine_arch_type == MACH_TYPE_PEMP_OMAP3_APOLLO)
+#else
+# define machine_is_pemp_omap3_apollo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VC0718
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VC0718
+# endif
+# define machine_is_vc0718()	(machine_arch_type == MACH_TYPE_VC0718)
+#else
+# define machine_is_vc0718()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MVBLX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MVBLX
+# endif
+# define machine_is_mvblx()	(machine_arch_type == MACH_TYPE_MVBLX)
+#else
+# define machine_is_mvblx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INHAND_APEIRON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INHAND_APEIRON
+# endif
+# define machine_is_inhand_apeiron()	(machine_arch_type == MACH_TYPE_INHAND_APEIRON)
+#else
+# define machine_is_inhand_apeiron()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INHAND_FURY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INHAND_FURY
+# endif
+# define machine_is_inhand_fury()	(machine_arch_type == MACH_TYPE_INHAND_FURY)
+#else
+# define machine_is_inhand_fury()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INHAND_SIREN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INHAND_SIREN
+# endif
+# define machine_is_inhand_siren()	(machine_arch_type == MACH_TYPE_INHAND_SIREN)
+#else
+# define machine_is_inhand_siren()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HDNVP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HDNVP
+# endif
+# define machine_is_hdnvp()	(machine_arch_type == MACH_TYPE_HDNVP)
+#else
+# define machine_is_hdnvp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SOFTWINNER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SOFTWINNER
+# endif
+# define machine_is_softwinner()	(machine_arch_type == MACH_TYPE_SOFTWINNER)
+#else
+# define machine_is_softwinner()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PRIMA2_EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PRIMA2_EVB
+# endif
+# define machine_is_prima2_evb()	(machine_arch_type == MACH_TYPE_PRIMA2_EVB)
+#else
+# define machine_is_prima2_evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAS6210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAS6210
+# endif
+# define machine_is_nas6210()	(machine_arch_type == MACH_TYPE_NAS6210)
+#else
+# define machine_is_nas6210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UNISDEV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UNISDEV
+# endif
+# define machine_is_unisdev()	(machine_arch_type == MACH_TYPE_UNISDEV)
+#else
+# define machine_is_unisdev()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SBCA11
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBCA11
+# endif
+# define machine_is_sbca11()	(machine_arch_type == MACH_TYPE_SBCA11)
+#else
+# define machine_is_sbca11()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAGA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAGA
+# endif
+# define machine_is_saga()	(machine_arch_type == MACH_TYPE_SAGA)
+#else
+# define machine_is_saga()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NS_K330
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NS_K330
+# endif
+# define machine_is_ns_k330()	(machine_arch_type == MACH_TYPE_NS_K330)
+#else
+# define machine_is_ns_k330()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TANNA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TANNA
+# endif
+# define machine_is_tanna()	(machine_arch_type == MACH_TYPE_TANNA)
+#else
+# define machine_is_tanna()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMATE8502
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMATE8502
+# endif
+# define machine_is_imate8502()	(machine_arch_type == MACH_TYPE_IMATE8502)
+#else
+# define machine_is_imate8502()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASPEN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASPEN
+# endif
+# define machine_is_aspen()	(machine_arch_type == MACH_TYPE_ASPEN)
+#else
+# define machine_is_aspen()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAINTREE_CWAC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAINTREE_CWAC
+# endif
+# define machine_is_daintree_cwac()	(machine_arch_type == MACH_TYPE_DAINTREE_CWAC)
+#else
+# define machine_is_daintree_cwac()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZMX25
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZMX25
+# endif
+# define machine_is_zmx25()	(machine_arch_type == MACH_TYPE_ZMX25)
+#else
+# define machine_is_zmx25()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAPLE1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAPLE1
+# endif
+# define machine_is_maple1()	(machine_arch_type == MACH_TYPE_MAPLE1)
+#else
+# define machine_is_maple1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QSD8X72_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QSD8X72_SURF
+# endif
+# define machine_is_qsd8x72_surf()	(machine_arch_type == MACH_TYPE_QSD8X72_SURF)
+#else
+# define machine_is_qsd8x72_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QSD8X72_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QSD8X72_FFA
+# endif
+# define machine_is_qsd8x72_ffa()	(machine_arch_type == MACH_TYPE_QSD8X72_FFA)
+#else
+# define machine_is_qsd8x72_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ABILENE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ABILENE
+# endif
+# define machine_is_abilene()	(machine_arch_type == MACH_TYPE_ABILENE)
+#else
+# define machine_is_abilene()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EIGEN_TTR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EIGEN_TTR
+# endif
+# define machine_is_eigen_ttr()	(machine_arch_type == MACH_TYPE_EIGEN_TTR)
+#else
+# define machine_is_eigen_ttr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IOMEGA_IX2_200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IOMEGA_IX2_200
+# endif
+# define machine_is_iomega_ix2_200()	(machine_arch_type == MACH_TYPE_IOMEGA_IX2_200)
+#else
+# define machine_is_iomega_ix2_200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CORETEC_VCX7400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CORETEC_VCX7400
+# endif
+# define machine_is_coretec_vcx7400()	(machine_arch_type == MACH_TYPE_CORETEC_VCX7400)
+#else
+# define machine_is_coretec_vcx7400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SANTIAGO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SANTIAGO
+# endif
+# define machine_is_santiago()	(machine_arch_type == MACH_TYPE_SANTIAGO)
+#else
+# define machine_is_santiago()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX257SOL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX257SOL
+# endif
+# define machine_is_mx257sol()	(machine_arch_type == MACH_TYPE_MX257SOL)
+#else
+# define machine_is_mx257sol()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STRASBOURG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STRASBOURG
+# endif
+# define machine_is_strasbourg()	(machine_arch_type == MACH_TYPE_STRASBOURG)
+#else
+# define machine_is_strasbourg()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X60_FLUID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X60_FLUID
+# endif
+# define machine_is_msm8x60_fluid()	(machine_arch_type == MACH_TYPE_MSM8X60_FLUID)
+#else
+# define machine_is_msm8x60_fluid()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMARTQV5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMARTQV5
+# endif
+# define machine_is_smartqv5()	(machine_arch_type == MACH_TYPE_SMARTQV5)
+#else
+# define machine_is_smartqv5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMARTQV3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMARTQV3
+# endif
+# define machine_is_smartqv3()	(machine_arch_type == MACH_TYPE_SMARTQV3)
+#else
+# define machine_is_smartqv3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMARTQV7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMARTQV7
+# endif
+# define machine_is_smartqv7()	(machine_arch_type == MACH_TYPE_SMARTQV7)
+#else
+# define machine_is_smartqv7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PAZ00
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PAZ00
+# endif
+# define machine_is_paz00()	(machine_arch_type == MACH_TYPE_PAZ00)
+#else
+# define machine_is_paz00()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACMENETUSFOXG20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACMENETUSFOXG20
+# endif
+# define machine_is_acmenetusfoxg20()	(machine_arch_type == MACH_TYPE_ACMENETUSFOXG20)
+#else
+# define machine_is_acmenetusfoxg20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FWBD_0404
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FWBD_0404
+# endif
+# define machine_is_fwbd_0404()	(machine_arch_type == MACH_TYPE_FWBD_0404)
+#else
+# define machine_is_fwbd_0404()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HDGU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HDGU
+# endif
+# define machine_is_hdgu()	(machine_arch_type == MACH_TYPE_HDGU)
+#else
+# define machine_is_hdgu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PYRAMID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PYRAMID
+# endif
+# define machine_is_pyramid()	(machine_arch_type == MACH_TYPE_PYRAMID)
+#else
+# define machine_is_pyramid()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EPIPHAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EPIPHAN
+# endif
+# define machine_is_epiphan()	(machine_arch_type == MACH_TYPE_EPIPHAN)
+#else
+# define machine_is_epiphan()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_BENDER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_BENDER
+# endif
+# define machine_is_omap_bender()	(machine_arch_type == MACH_TYPE_OMAP_BENDER)
+#else
+# define machine_is_omap_bender()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GURNARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GURNARD
+# endif
+# define machine_is_gurnard()	(machine_arch_type == MACH_TYPE_GURNARD)
+#else
+# define machine_is_gurnard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GTL_IT5100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GTL_IT5100
+# endif
+# define machine_is_gtl_it5100()	(machine_arch_type == MACH_TYPE_GTL_IT5100)
+#else
+# define machine_is_gtl_it5100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCM2708
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCM2708
+# endif
+# define machine_is_bcm2708()	(machine_arch_type == MACH_TYPE_BCM2708)
+#else
+# define machine_is_bcm2708()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_GGC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_GGC
+# endif
+# define machine_is_mx51_ggc()	(machine_arch_type == MACH_TYPE_MX51_GGC)
+#else
+# define machine_is_mx51_ggc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHARESPACE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHARESPACE
+# endif
+# define machine_is_sharespace()	(machine_arch_type == MACH_TYPE_SHARESPACE)
+#else
+# define machine_is_sharespace()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HABA_KNX_EXPLORER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HABA_KNX_EXPLORER
+# endif
+# define machine_is_haba_knx_explorer()	(machine_arch_type == MACH_TYPE_HABA_KNX_EXPLORER)
+#else
+# define machine_is_haba_knx_explorer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIMTEC_KIRKMOD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIMTEC_KIRKMOD
+# endif
+# define machine_is_simtec_kirkmod()	(machine_arch_type == MACH_TYPE_SIMTEC_KIRKMOD)
+#else
+# define machine_is_simtec_kirkmod()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CRUX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CRUX
+# endif
+# define machine_is_crux()	(machine_arch_type == MACH_TYPE_CRUX)
+#else
+# define machine_is_crux()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_BRAVO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_BRAVO
+# endif
+# define machine_is_mx51_bravo()	(machine_arch_type == MACH_TYPE_MX51_BRAVO)
+#else
+# define machine_is_mx51_bravo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CHARON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CHARON
+# endif
+# define machine_is_charon()	(machine_arch_type == MACH_TYPE_CHARON)
+#else
+# define machine_is_charon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICOCOM3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICOCOM3
+# endif
+# define machine_is_picocom3()	(machine_arch_type == MACH_TYPE_PICOCOM3)
+#else
+# define machine_is_picocom3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICOCOM4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICOCOM4
+# endif
+# define machine_is_picocom4()	(machine_arch_type == MACH_TYPE_PICOCOM4)
+#else
+# define machine_is_picocom4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SERRANO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SERRANO
+# endif
+# define machine_is_serrano()	(machine_arch_type == MACH_TYPE_SERRANO)
+#else
+# define machine_is_serrano()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DOUBLESHOT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DOUBLESHOT
+# endif
+# define machine_is_doubleshot()	(machine_arch_type == MACH_TYPE_DOUBLESHOT)
+#else
+# define machine_is_doubleshot()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EVSY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EVSY
+# endif
+# define machine_is_evsy()	(machine_arch_type == MACH_TYPE_EVSY)
+#else
+# define machine_is_evsy()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HUASHAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HUASHAN
+# endif
+# define machine_is_huashan()	(machine_arch_type == MACH_TYPE_HUASHAN)
+#else
+# define machine_is_huashan()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LAUSANNE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LAUSANNE
+# endif
+# define machine_is_lausanne()	(machine_arch_type == MACH_TYPE_LAUSANNE)
+#else
+# define machine_is_lausanne()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMERALD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMERALD
+# endif
+# define machine_is_emerald()	(machine_arch_type == MACH_TYPE_EMERALD)
+#else
+# define machine_is_emerald()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TQMA35
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TQMA35
+# endif
+# define machine_is_tqma35()	(machine_arch_type == MACH_TYPE_TQMA35)
+#else
+# define machine_is_tqma35()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MARVEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARVEL
+# endif
+# define machine_is_marvel()	(machine_arch_type == MACH_TYPE_MARVEL)
+#else
+# define machine_is_marvel()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MANUAE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MANUAE
+# endif
+# define machine_is_manuae()	(machine_arch_type == MACH_TYPE_MANUAE)
+#else
+# define machine_is_manuae()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CHACHA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CHACHA
+# endif
+# define machine_is_chacha()	(machine_arch_type == MACH_TYPE_CHACHA)
+#else
+# define machine_is_chacha()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LEMON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LEMON
+# endif
+# define machine_is_lemon()	(machine_arch_type == MACH_TYPE_LEMON)
+#else
+# define machine_is_lemon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSC
+# endif
+# define machine_is_csc()	(machine_arch_type == MACH_TYPE_CSC)
+#else
+# define machine_is_csc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GIRA_KNXIP_ROUTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GIRA_KNXIP_ROUTER
+# endif
+# define machine_is_gira_knxip_router()	(machine_arch_type == MACH_TYPE_GIRA_KNXIP_ROUTER)
+#else
+# define machine_is_gira_knxip_router()	(0)
+#endif
+
+#ifdef CONFIG_MACH_T20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_T20
+# endif
+# define machine_is_t20()	(machine_arch_type == MACH_TYPE_T20)
+#else
+# define machine_is_t20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HDMINI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HDMINI
+# endif
+# define machine_is_hdmini()	(machine_arch_type == MACH_TYPE_HDMINI)
+#else
+# define machine_is_hdmini()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SCIPHONE_G2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SCIPHONE_G2
+# endif
+# define machine_is_sciphone_g2()	(machine_arch_type == MACH_TYPE_SCIPHONE_G2)
+#else
+# define machine_is_sciphone_g2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EXPRESS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EXPRESS
+# endif
+# define machine_is_express()	(machine_arch_type == MACH_TYPE_EXPRESS)
+#else
+# define machine_is_express()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EXPRESS_KT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EXPRESS_KT
+# endif
+# define machine_is_express_kt()	(machine_arch_type == MACH_TYPE_EXPRESS_KT)
+#else
+# define machine_is_express_kt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAXIMASP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAXIMASP
+# endif
+# define machine_is_maximasp()	(machine_arch_type == MACH_TYPE_MAXIMASP)
+#else
+# define machine_is_maximasp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NITROGEN_IMX51
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NITROGEN_IMX51
+# endif
+# define machine_is_nitrogen_imx51()	(machine_arch_type == MACH_TYPE_NITROGEN_IMX51)
+#else
+# define machine_is_nitrogen_imx51()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NITROGEN_IMX53
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NITROGEN_IMX53
+# endif
+# define machine_is_nitrogen_imx53()	(machine_arch_type == MACH_TYPE_NITROGEN_IMX53)
+#else
+# define machine_is_nitrogen_imx53()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SUNFIRE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SUNFIRE
+# endif
+# define machine_is_sunfire()	(machine_arch_type == MACH_TYPE_SUNFIRE)
+#else
+# define machine_is_sunfire()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AROWANA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AROWANA
+# endif
+# define machine_is_arowana()	(machine_arch_type == MACH_TYPE_AROWANA)
+#else
+# define machine_is_arowana()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TEGRA_DAYTONA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TEGRA_DAYTONA
+# endif
+# define machine_is_tegra_daytona()	(machine_arch_type == MACH_TYPE_TEGRA_DAYTONA)
+#else
+# define machine_is_tegra_daytona()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TEGRA_SWORDFISH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TEGRA_SWORDFISH
+# endif
+# define machine_is_tegra_swordfish()	(machine_arch_type == MACH_TYPE_TEGRA_SWORDFISH)
+#else
+# define machine_is_tegra_swordfish()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDISON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDISON
+# endif
+# define machine_is_edison()	(machine_arch_type == MACH_TYPE_EDISON)
+#else
+# define machine_is_edison()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SVP8500V1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SVP8500V1
+# endif
+# define machine_is_svp8500v1()	(machine_arch_type == MACH_TYPE_SVP8500V1)
+#else
+# define machine_is_svp8500v1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SVP8500V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SVP8500V2
+# endif
+# define machine_is_svp8500v2()	(machine_arch_type == MACH_TYPE_SVP8500V2)
+#else
+# define machine_is_svp8500v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SVP5500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SVP5500
+# endif
+# define machine_is_svp5500()	(machine_arch_type == MACH_TYPE_SVP5500)
+#else
+# define machine_is_svp5500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_B5500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_B5500
+# endif
+# define machine_is_b5500()	(machine_arch_type == MACH_TYPE_B5500)
+#else
+# define machine_is_b5500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S5500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S5500
+# endif
+# define machine_is_s5500()	(machine_arch_type == MACH_TYPE_S5500)
+#else
+# define machine_is_s5500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ICON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ICON
+# endif
+# define machine_is_icon()	(machine_arch_type == MACH_TYPE_ICON)
+#else
+# define machine_is_icon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ELEPHANT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ELEPHANT
+# endif
+# define machine_is_elephant()	(machine_arch_type == MACH_TYPE_ELEPHANT)
+#else
+# define machine_is_elephant()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHOOTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHOOTER
+# endif
+# define machine_is_shooter()	(machine_arch_type == MACH_TYPE_SHOOTER)
+#else
+# define machine_is_shooter()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPADE_LTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPADE_LTE
+# endif
+# define machine_is_spade_lte()	(machine_arch_type == MACH_TYPE_SPADE_LTE)
+#else
+# define machine_is_spade_lte()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PHILHWANI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PHILHWANI
+# endif
+# define machine_is_philhwani()	(machine_arch_type == MACH_TYPE_PHILHWANI)
+#else
+# define machine_is_philhwani()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GSNCOMM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GSNCOMM
+# endif
+# define machine_is_gsncomm()	(machine_arch_type == MACH_TYPE_GSNCOMM)
+#else
+# define machine_is_gsncomm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STRASBOURG_A2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STRASBOURG_A2
+# endif
+# define machine_is_strasbourg_a2()	(machine_arch_type == MACH_TYPE_STRASBOURG_A2)
+#else
+# define machine_is_strasbourg_a2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MMM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MMM
+# endif
+# define machine_is_mmm()	(machine_arch_type == MACH_TYPE_MMM)
+#else
+# define machine_is_mmm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DM365_BV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DM365_BV
+# endif
+# define machine_is_davinci_dm365_bv()	(machine_arch_type == MACH_TYPE_DAVINCI_DM365_BV)
+#else
+# define machine_is_davinci_dm365_bv()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AG5EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AG5EVM
+# endif
+# define machine_is_ag5evm()	(machine_arch_type == MACH_TYPE_AG5EVM)
+#else
+# define machine_is_ag5evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SC575PLC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SC575PLC
+# endif
+# define machine_is_sc575plc()	(machine_arch_type == MACH_TYPE_SC575PLC)
+#else
+# define machine_is_sc575plc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SC575IPC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SC575IPC
+# endif
+# define machine_is_sc575hmi()	(machine_arch_type == MACH_TYPE_SC575IPC)
+#else
+# define machine_is_sc575hmi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_TDM3730
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_TDM3730
+# endif
+# define machine_is_omap3_tdm3730()	(machine_arch_type == MACH_TYPE_OMAP3_TDM3730)
+#else
+# define machine_is_omap3_tdm3730()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOP9000_EVAL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOP9000_EVAL
+# endif
+# define machine_is_top9000_eval()	(machine_arch_type == MACH_TYPE_TOP9000_EVAL)
+#else
+# define machine_is_top9000_eval()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOP9000_SU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOP9000_SU
+# endif
+# define machine_is_top9000_su()	(machine_arch_type == MACH_TYPE_TOP9000_SU)
+#else
+# define machine_is_top9000_su()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UTM300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UTM300
+# endif
+# define machine_is_utm300()	(machine_arch_type == MACH_TYPE_UTM300)
+#else
+# define machine_is_utm300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TSUNAGI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TSUNAGI
+# endif
+# define machine_is_tsunagi()	(machine_arch_type == MACH_TYPE_TSUNAGI)
+#else
+# define machine_is_tsunagi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS75XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS75XX
+# endif
+# define machine_is_ts75xx()	(machine_arch_type == MACH_TYPE_TS75XX)
+#else
+# define machine_is_ts75xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS47XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS47XX
+# endif
+# define machine_is_ts47xx()	(machine_arch_type == MACH_TYPE_TS47XX)
+#else
+# define machine_is_ts47xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DA850_K5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DA850_K5
+# endif
+# define machine_is_da850_k5()	(machine_arch_type == MACH_TYPE_DA850_K5)
+#else
+# define machine_is_da850_k5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AX502
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AX502
+# endif
+# define machine_is_ax502()	(machine_arch_type == MACH_TYPE_AX502)
+#else
+# define machine_is_ax502()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IGEP0032
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IGEP0032
+# endif
+# define machine_is_igep0032()	(machine_arch_type == MACH_TYPE_IGEP0032)
+#else
+# define machine_is_igep0032()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ANTERO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANTERO
+# endif
+# define machine_is_antero()	(machine_arch_type == MACH_TYPE_ANTERO)
+#else
+# define machine_is_antero()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SYNERGY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SYNERGY
+# endif
+# define machine_is_synergy()	(machine_arch_type == MACH_TYPE_SYNERGY)
+#else
+# define machine_is_synergy()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ICS_IF_VOIP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ICS_IF_VOIP
+# endif
+# define machine_is_ics_if_voip()	(machine_arch_type == MACH_TYPE_ICS_IF_VOIP)
+#else
+# define machine_is_ics_if_voip()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WLF_CRAGG_6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WLF_CRAGG_6410
+# endif
+# define machine_is_wlf_cragg_6410()	(machine_arch_type == MACH_TYPE_WLF_CRAGG_6410)
+#else
+# define machine_is_wlf_cragg_6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PUNICA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PUNICA
+# endif
+# define machine_is_punica()	(machine_arch_type == MACH_TYPE_PUNICA)
+#else
+# define machine_is_punica()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRIMSLICE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIMSLICE
+# endif
+# define machine_is_trimslice()	(machine_arch_type == MACH_TYPE_TRIMSLICE)
+#else
+# define machine_is_trimslice()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX27_WMULTRA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX27_WMULTRA
+# endif
+# define machine_is_mx27_wmultra()	(machine_arch_type == MACH_TYPE_MX27_WMULTRA)
+#else
+# define machine_is_mx27_wmultra()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MACKEREL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MACKEREL
+# endif
+# define machine_is_mackerel()	(machine_arch_type == MACH_TYPE_MACKEREL)
+#else
+# define machine_is_mackerel()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FA9X27
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FA9X27
+# endif
+# define machine_is_fa9x27()	(machine_arch_type == MACH_TYPE_FA9X27)
+#else
+# define machine_is_fa9x27()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NS2816TB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NS2816TB
+# endif
+# define machine_is_ns2816tb()	(machine_arch_type == MACH_TYPE_NS2816TB)
+#else
+# define machine_is_ns2816tb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NS2816_NTPAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NS2816_NTPAD
+# endif
+# define machine_is_ns2816_ntpad()	(machine_arch_type == MACH_TYPE_NS2816_NTPAD)
+#else
+# define machine_is_ns2816_ntpad()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NS2816_NTNB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NS2816_NTNB
+# endif
+# define machine_is_ns2816_ntnb()	(machine_arch_type == MACH_TYPE_NS2816_NTNB)
+#else
+# define machine_is_ns2816_ntnb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KAEN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KAEN
+# endif
+# define machine_is_kaen()	(machine_arch_type == MACH_TYPE_KAEN)
+#else
+# define machine_is_kaen()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NV1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NV1000
+# endif
+# define machine_is_nv1000()	(machine_arch_type == MACH_TYPE_NV1000)
+#else
+# define machine_is_nv1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NUC950TS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NUC950TS
+# endif
+# define machine_is_nuc950ts()	(machine_arch_type == MACH_TYPE_NUC950TS)
+#else
+# define machine_is_nuc950ts()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA_RM680
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA_RM680
+# endif
+# define machine_is_nokia_rm680()	(machine_arch_type == MACH_TYPE_NOKIA_RM680)
+#else
+# define machine_is_nokia_rm680()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AST2200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AST2200
+# endif
+# define machine_is_ast2200()	(machine_arch_type == MACH_TYPE_AST2200)
+#else
+# define machine_is_ast2200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LEAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LEAD
+# endif
+# define machine_is_lead()	(machine_arch_type == MACH_TYPE_LEAD)
+#else
+# define machine_is_lead()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UNINO1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UNINO1
+# endif
+# define machine_is_unino1()	(machine_arch_type == MACH_TYPE_UNINO1)
+#else
+# define machine_is_unino1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GREECO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GREECO
+# endif
+# define machine_is_greeco()	(machine_arch_type == MACH_TYPE_GREECO)
+#else
+# define machine_is_greeco()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VERDI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VERDI
+# endif
+# define machine_is_verdi()	(machine_arch_type == MACH_TYPE_VERDI)
+#else
+# define machine_is_verdi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM6446_ADBOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM6446_ADBOX
+# endif
+# define machine_is_dm6446_adbox()	(machine_arch_type == MACH_TYPE_DM6446_ADBOX)
+#else
+# define machine_is_dm6446_adbox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QUAD_SALSA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QUAD_SALSA
+# endif
+# define machine_is_quad_salsa()	(machine_arch_type == MACH_TYPE_QUAD_SALSA)
+#else
+# define machine_is_quad_salsa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ABB_GMA_1_1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ABB_GMA_1_1
+# endif
+# define machine_is_abb_gma_1_1()	(machine_arch_type == MACH_TYPE_ABB_GMA_1_1)
+#else
+# define machine_is_abb_gma_1_1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SVCID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SVCID
+# endif
+# define machine_is_svcid()	(machine_arch_type == MACH_TYPE_SVCID)
+#else
+# define machine_is_svcid()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8960_SIM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8960_SIM
+# endif
+# define machine_is_msm8960_sim()	(machine_arch_type == MACH_TYPE_MSM8960_SIM)
+#else
+# define machine_is_msm8960_sim()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8960_RUMI3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8960_RUMI3
+# endif
+# define machine_is_msm8960_rumi3()	(machine_arch_type == MACH_TYPE_MSM8960_RUMI3)
+#else
+# define machine_is_msm8960_rumi3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ICON_G
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ICON_G
+# endif
+# define machine_is_icon_g()	(machine_arch_type == MACH_TYPE_ICON_G)
+#else
+# define machine_is_icon_g()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MB3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MB3
+# endif
+# define machine_is_mb3()	(machine_arch_type == MACH_TYPE_MB3)
+#else
+# define machine_is_mb3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GSIA18S
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GSIA18S
+# endif
+# define machine_is_gsia18s()	(machine_arch_type == MACH_TYPE_GSIA18S)
+#else
+# define machine_is_gsia18s()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PIVICC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PIVICC
+# endif
+# define machine_is_pivicc()	(machine_arch_type == MACH_TYPE_PIVICC)
+#else
+# define machine_is_pivicc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM048
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM048
+# endif
+# define machine_is_pcm048()	(machine_arch_type == MACH_TYPE_PCM048)
+#else
+# define machine_is_pcm048()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DDS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DDS
+# endif
+# define machine_is_dds()	(machine_arch_type == MACH_TYPE_DDS)
+#else
+# define machine_is_dds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CHALTEN_XA1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CHALTEN_XA1
+# endif
+# define machine_is_chalten_xa1()	(machine_arch_type == MACH_TYPE_CHALTEN_XA1)
+#else
+# define machine_is_chalten_xa1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS48XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS48XX
+# endif
+# define machine_is_ts48xx()	(machine_arch_type == MACH_TYPE_TS48XX)
+#else
+# define machine_is_ts48xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TONGA2_TFTTIMER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TONGA2_TFTTIMER
+# endif
+# define machine_is_tonga2_tfttimer()	(machine_arch_type == MACH_TYPE_TONGA2_TFTTIMER)
+#else
+# define machine_is_tonga2_tfttimer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WHISTLER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WHISTLER
+# endif
+# define machine_is_whistler()	(machine_arch_type == MACH_TYPE_WHISTLER)
+#else
+# define machine_is_whistler()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASL_PHOENIX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASL_PHOENIX
+# endif
+# define machine_is_asl_phoenix()	(machine_arch_type == MACH_TYPE_ASL_PHOENIX)
+#else
+# define machine_is_asl_phoenix()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9263OTLITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9263OTLITE
+# endif
+# define machine_is_at91sam9263otlite()	(machine_arch_type == MACH_TYPE_AT91SAM9263OTLITE)
+#else
+# define machine_is_at91sam9263otlite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DDPLUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DDPLUG
+# endif
+# define machine_is_ddplug()	(machine_arch_type == MACH_TYPE_DDPLUG)
+#else
+# define machine_is_ddplug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_D2PLUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_D2PLUG
+# endif
+# define machine_is_d2plug()	(machine_arch_type == MACH_TYPE_D2PLUG)
+#else
+# define machine_is_d2plug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KZM9D
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KZM9D
+# endif
+# define machine_is_kzm9d()	(machine_arch_type == MACH_TYPE_KZM9D)
+#else
+# define machine_is_kzm9d()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VERDI_LTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VERDI_LTE
+# endif
+# define machine_is_verdi_lte()	(machine_arch_type == MACH_TYPE_VERDI_LTE)
+#else
+# define machine_is_verdi_lte()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NANOZOOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NANOZOOM
+# endif
+# define machine_is_nanozoom()	(machine_arch_type == MACH_TYPE_NANOZOOM)
+#else
+# define machine_is_nanozoom()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM3730_SOM_LV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM3730_SOM_LV
+# endif
+# define machine_is_dm3730_som_lv()	(machine_arch_type == MACH_TYPE_DM3730_SOM_LV)
+#else
+# define machine_is_dm3730_som_lv()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM3730_TORPEDO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM3730_TORPEDO
+# endif
+# define machine_is_dm3730_torpedo()	(machine_arch_type == MACH_TYPE_DM3730_TORPEDO)
+#else
+# define machine_is_dm3730_torpedo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ANCHOVY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANCHOVY
+# endif
+# define machine_is_anchovy()	(machine_arch_type == MACH_TYPE_ANCHOVY)
+#else
+# define machine_is_anchovy()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RE2REV20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RE2REV20
+# endif
+# define machine_is_re2rev20()	(machine_arch_type == MACH_TYPE_RE2REV20)
+#else
+# define machine_is_re2rev20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RE2REV21
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RE2REV21
+# endif
+# define machine_is_re2rev21()	(machine_arch_type == MACH_TYPE_RE2REV21)
+#else
+# define machine_is_re2rev21()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CNS21XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CNS21XX
+# endif
+# define machine_is_cns21xx()	(machine_arch_type == MACH_TYPE_CNS21XX)
+#else
+# define machine_is_cns21xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RIDER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RIDER
+# endif
+# define machine_is_rider()	(machine_arch_type == MACH_TYPE_RIDER)
+#else
+# define machine_is_rider()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NSK330
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NSK330
+# endif
+# define machine_is_nsk330()	(machine_arch_type == MACH_TYPE_NSK330)
+#else
+# define machine_is_nsk330()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CNS2133EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CNS2133EVB
+# endif
+# define machine_is_cns2133evb()	(machine_arch_type == MACH_TYPE_CNS2133EVB)
+#else
+# define machine_is_cns2133evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_Z3_816X_MOD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_Z3_816X_MOD
+# endif
+# define machine_is_z3_816x_mod()	(machine_arch_type == MACH_TYPE_Z3_816X_MOD)
+#else
+# define machine_is_z3_816x_mod()	(0)
+#endif
+
+#ifdef CONFIG_MACH_Z3_814X_MOD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_Z3_814X_MOD
+# endif
+# define machine_is_z3_814x_mod()	(machine_arch_type == MACH_TYPE_Z3_814X_MOD)
+#else
+# define machine_is_z3_814x_mod()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BEECT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BEECT
+# endif
+# define machine_is_beect()	(machine_arch_type == MACH_TYPE_BEECT)
+#else
+# define machine_is_beect()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DMA_THUNDERBUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DMA_THUNDERBUG
+# endif
+# define machine_is_dma_thunderbug()	(machine_arch_type == MACH_TYPE_DMA_THUNDERBUG)
+#else
+# define machine_is_dma_thunderbug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMN_AT91SAM9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMN_AT91SAM9G20
+# endif
+# define machine_is_omn_at91sam9g20()	(machine_arch_type == MACH_TYPE_OMN_AT91SAM9G20)
+#else
+# define machine_is_omn_at91sam9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX25_E2S_UC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX25_E2S_UC
+# endif
+# define machine_is_mx25_e2s_uc()	(machine_arch_type == MACH_TYPE_MX25_E2S_UC)
+#else
+# define machine_is_mx25_e2s_uc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIONE
+# endif
+# define machine_is_mione()	(machine_arch_type == MACH_TYPE_MIONE)
+#else
+# define machine_is_mione()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOP9000_TCU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOP9000_TCU
+# endif
+# define machine_is_top9000_tcu()	(machine_arch_type == MACH_TYPE_TOP9000_TCU)
+#else
+# define machine_is_top9000_tcu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOP9000_BSL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOP9000_BSL
+# endif
+# define machine_is_top9000_bsl()	(machine_arch_type == MACH_TYPE_TOP9000_BSL)
+#else
+# define machine_is_top9000_bsl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KINGDOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KINGDOM
+# endif
+# define machine_is_kingdom()	(machine_arch_type == MACH_TYPE_KINGDOM)
+#else
+# define machine_is_kingdom()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMADILLO460
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMADILLO460
+# endif
+# define machine_is_armadillo460()	(machine_arch_type == MACH_TYPE_ARMADILLO460)
+#else
+# define machine_is_armadillo460()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LQ2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LQ2
+# endif
+# define machine_is_lq2()	(machine_arch_type == MACH_TYPE_LQ2)
+#else
+# define machine_is_lq2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWEDA_TMS2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWEDA_TMS2
+# endif
+# define machine_is_sweda_tms2()	(machine_arch_type == MACH_TYPE_SWEDA_TMS2)
+#else
+# define machine_is_sweda_tms2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX53_LOCO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX53_LOCO
+# endif
+# define machine_is_mx53_loco()	(machine_arch_type == MACH_TYPE_MX53_LOCO)
+#else
+# define machine_is_mx53_loco()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACER_A8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACER_A8
+# endif
+# define machine_is_acer_a8()	(machine_arch_type == MACH_TYPE_ACER_A8)
+#else
+# define machine_is_acer_a8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACER_GAUGUIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACER_GAUGUIN
+# endif
+# define machine_is_acer_gauguin()	(machine_arch_type == MACH_TYPE_ACER_GAUGUIN)
+#else
+# define machine_is_acer_gauguin()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GUPPY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GUPPY
+# endif
+# define machine_is_guppy()	(machine_arch_type == MACH_TYPE_GUPPY)
+#else
+# define machine_is_guppy()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX61_ARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX61_ARD
+# endif
+# define machine_is_mx61_ard()	(machine_arch_type == MACH_TYPE_MX61_ARD)
+#else
+# define machine_is_mx61_ard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TX53
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TX53
+# endif
+# define machine_is_tx53()	(machine_arch_type == MACH_TYPE_TX53)
+#else
+# define machine_is_tx53()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAPL138_CASE_A3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAPL138_CASE_A3
+# endif
+# define machine_is_omapl138_case_a3()	(machine_arch_type == MACH_TYPE_OMAPL138_CASE_A3)
+#else
+# define machine_is_omapl138_case_a3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UEMD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UEMD
+# endif
+# define machine_is_uemd()	(machine_arch_type == MACH_TYPE_UEMD)
+#else
+# define machine_is_uemd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCWMX51MUT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCWMX51MUT
+# endif
+# define machine_is_ccwmx51mut()	(machine_arch_type == MACH_TYPE_CCWMX51MUT)
+#else
+# define machine_is_ccwmx51mut()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROCKHOPPER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROCKHOPPER
+# endif
+# define machine_is_rockhopper()	(machine_arch_type == MACH_TYPE_ROCKHOPPER)
+#else
+# define machine_is_rockhopper()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOOKCOLOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOOKCOLOR
+# endif
+# define machine_is_nookcolor()	(machine_arch_type == MACH_TYPE_NOOKCOLOR)
+#else
+# define machine_is_nookcolor()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HKDKC100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HKDKC100
+# endif
+# define machine_is_hkdkc100()	(machine_arch_type == MACH_TYPE_HKDKC100)
+#else
+# define machine_is_hkdkc100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS42XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS42XX
+# endif
+# define machine_is_ts42xx()	(machine_arch_type == MACH_TYPE_TS42XX)
+#else
+# define machine_is_ts42xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AEBL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AEBL
+# endif
+# define machine_is_aebl()	(machine_arch_type == MACH_TYPE_AEBL)
+#else
+# define machine_is_aebl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WARIO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WARIO
+# endif
+# define machine_is_wario()	(machine_arch_type == MACH_TYPE_WARIO)
+#else
+# define machine_is_wario()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GFS_SPM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GFS_SPM
+# endif
+# define machine_is_gfs_spm()	(machine_arch_type == MACH_TYPE_GFS_SPM)
+#else
+# define machine_is_gfs_spm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM_T3730
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM_T3730
+# endif
+# define machine_is_cm_t3730()	(machine_arch_type == MACH_TYPE_CM_T3730)
+#else
+# define machine_is_cm_t3730()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ISC3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ISC3
+# endif
+# define machine_is_isc3()	(machine_arch_type == MACH_TYPE_ISC3)
+#else
+# define machine_is_isc3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RASCAL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RASCAL
+# endif
+# define machine_is_rascal()	(machine_arch_type == MACH_TYPE_RASCAL)
+#else
+# define machine_is_rascal()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HREFV60
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HREFV60
+# endif
+# define machine_is_hrefv60()	(machine_arch_type == MACH_TYPE_HREFV60)
+#else
+# define machine_is_hrefv60()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TPT_2_0
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TPT_2_0
+# endif
+# define machine_is_tpt_2_0()	(machine_arch_type == MACH_TYPE_TPT_2_0)
+#else
+# define machine_is_tpt_2_0()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPLENDOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPLENDOR
+# endif
+# define machine_is_splendor()	(machine_arch_type == MACH_TYPE_SPLENDOR)
+#else
+# define machine_is_splendor()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8X60_QT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8X60_QT
+# endif
+# define machine_is_msm8x60_qt()	(machine_arch_type == MACH_TYPE_MSM8X60_QT)
+#else
+# define machine_is_msm8x60_qt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTC_HD_MINI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTC_HD_MINI
+# endif
+# define machine_is_htc_hd_mini()	(machine_arch_type == MACH_TYPE_HTC_HD_MINI)
+#else
+# define machine_is_htc_hd_mini()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATHENE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATHENE
+# endif
+# define machine_is_athene()	(machine_arch_type == MACH_TYPE_ATHENE)
+#else
+# define machine_is_athene()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEEP_R_EK_1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEEP_R_EK_1
+# endif
+# define machine_is_deep_r_ek_1()	(machine_arch_type == MACH_TYPE_DEEP_R_EK_1)
+#else
+# define machine_is_deep_r_ek_1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VIVOW_CT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VIVOW_CT
+# endif
+# define machine_is_vivow_ct()	(machine_arch_type == MACH_TYPE_VIVOW_CT)
+#else
+# define machine_is_vivow_ct()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NERY_1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NERY_1000
+# endif
+# define machine_is_nery_1000()	(machine_arch_type == MACH_TYPE_NERY_1000)
+#else
+# define machine_is_nery_1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RFL109145_SSRV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RFL109145_SSRV
+# endif
+# define machine_is_rfl109145_ssrv()	(machine_arch_type == MACH_TYPE_RFL109145_SSRV)
+#else
+# define machine_is_rfl109145_ssrv()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NMH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NMH
+# endif
+# define machine_is_nmh()	(machine_arch_type == MACH_TYPE_NMH)
+#else
+# define machine_is_nmh()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WN802T
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WN802T
+# endif
+# define machine_is_wn802t()	(machine_arch_type == MACH_TYPE_WN802T)
+#else
+# define machine_is_wn802t()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DRAGONET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DRAGONET
+# endif
+# define machine_is_dragonet()	(machine_arch_type == MACH_TYPE_DRAGONET)
+#else
+# define machine_is_dragonet()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9263DESK16L
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9263DESK16L
+# endif
+# define machine_is_at91sam9263desk16l()	(machine_arch_type == MACH_TYPE_AT91SAM9263DESK16L)
+#else
+# define machine_is_at91sam9263desk16l()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCMHANA_SV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCMHANA_SV
+# endif
+# define machine_is_bcmhana_sv()	(machine_arch_type == MACH_TYPE_BCMHANA_SV)
+#else
+# define machine_is_bcmhana_sv()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCMHANA_TABLET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCMHANA_TABLET
+# endif
+# define machine_is_bcmhana_tablet()	(machine_arch_type == MACH_TYPE_BCMHANA_TABLET)
+#else
+# define machine_is_bcmhana_tablet()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KOI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KOI
+# endif
+# define machine_is_koi()	(machine_arch_type == MACH_TYPE_KOI)
+#else
+# define machine_is_koi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS4800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS4800
+# endif
+# define machine_is_ts4800()	(machine_arch_type == MACH_TYPE_TS4800)
+#else
+# define machine_is_ts4800()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TQMA9263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TQMA9263
+# endif
+# define machine_is_tqma9263()	(machine_arch_type == MACH_TYPE_TQMA9263)
+#else
+# define machine_is_tqma9263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HOLIDAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HOLIDAY
+# endif
+# define machine_is_holiday()	(machine_arch_type == MACH_TYPE_HOLIDAY)
+#else
+# define machine_is_holiday()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DMA6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DMA6410
+# endif
+# define machine_is_dma_6410()	(machine_arch_type == MACH_TYPE_DMA6410)
+#else
+# define machine_is_dma_6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCATS_OVERLAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCATS_OVERLAY
+# endif
+# define machine_is_pcats_overlay()	(machine_arch_type == MACH_TYPE_PCATS_OVERLAY)
+#else
+# define machine_is_pcats_overlay()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HWGW6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HWGW6410
+# endif
+# define machine_is_hwgw6410()	(machine_arch_type == MACH_TYPE_HWGW6410)
+#else
+# define machine_is_hwgw6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHENZHOU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHENZHOU
+# endif
+# define machine_is_shenzhou()	(machine_arch_type == MACH_TYPE_SHENZHOU)
+#else
+# define machine_is_shenzhou()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CWME9210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CWME9210
+# endif
+# define machine_is_cwme9210()	(machine_arch_type == MACH_TYPE_CWME9210)
+#else
+# define machine_is_cwme9210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CWME9210JS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CWME9210JS
+# endif
+# define machine_is_cwme9210js()	(machine_arch_type == MACH_TYPE_CWME9210JS)
+#else
+# define machine_is_cwme9210js()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PGS_SITARA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PGS_SITARA
+# endif
+# define machine_is_pgs_v1()	(machine_arch_type == MACH_TYPE_PGS_SITARA)
+#else
+# define machine_is_pgs_v1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COLIBRI_TEGRA2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COLIBRI_TEGRA2
+# endif
+# define machine_is_colibri_tegra2()	(machine_arch_type == MACH_TYPE_COLIBRI_TEGRA2)
+#else
+# define machine_is_colibri_tegra2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W21
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W21
+# endif
+# define machine_is_w21()	(machine_arch_type == MACH_TYPE_W21)
+#else
+# define machine_is_w21()	(0)
+#endif
+
+#ifdef CONFIG_MACH_POLYSAT1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POLYSAT1
+# endif
+# define machine_is_polysat1()	(machine_arch_type == MACH_TYPE_POLYSAT1)
+#else
+# define machine_is_polysat1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DATAWAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DATAWAY
+# endif
+# define machine_is_dataway()	(machine_arch_type == MACH_TYPE_DATAWAY)
+#else
+# define machine_is_dataway()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COBRAL138
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COBRAL138
+# endif
+# define machine_is_cobral138()	(machine_arch_type == MACH_TYPE_COBRAL138)
+#else
+# define machine_is_cobral138()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROVERPCS8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROVERPCS8
+# endif
+# define machine_is_roverpcs8()	(machine_arch_type == MACH_TYPE_ROVERPCS8)
+#else
+# define machine_is_roverpcs8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MARVELC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARVELC
+# endif
+# define machine_is_marvelc()	(machine_arch_type == MACH_TYPE_MARVELC)
+#else
+# define machine_is_marvelc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAVEFIHID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAVEFIHID
+# endif
+# define machine_is_navefihid()	(machine_arch_type == MACH_TYPE_NAVEFIHID)
+#else
+# define machine_is_navefihid()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM365_CV100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM365_CV100
+# endif
+# define machine_is_dm365_cv100()	(machine_arch_type == MACH_TYPE_DM365_CV100)
+#else
+# define machine_is_dm365_cv100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ABLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ABLE
+# endif
+# define machine_is_able()	(machine_arch_type == MACH_TYPE_ABLE)
+#else
+# define machine_is_able()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LEGACY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LEGACY
+# endif
+# define machine_is_legacy()	(machine_arch_type == MACH_TYPE_LEGACY)
+#else
+# define machine_is_legacy()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ICONG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ICONG
+# endif
+# define machine_is_icong()	(machine_arch_type == MACH_TYPE_ICONG)
+#else
+# define machine_is_icong()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROVER_G8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROVER_G8
+# endif
+# define machine_is_rover_g8()	(machine_arch_type == MACH_TYPE_ROVER_G8)
+#else
+# define machine_is_rover_g8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_T5388P
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_T5388P
+# endif
+# define machine_is_t5388p()	(machine_arch_type == MACH_TYPE_T5388P)
+#else
+# define machine_is_t5388p()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DINGO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DINGO
+# endif
+# define machine_is_dingo()	(machine_arch_type == MACH_TYPE_DINGO)
+#else
+# define machine_is_dingo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GOFLEXHOME
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GOFLEXHOME
+# endif
+# define machine_is_goflexhome()	(machine_arch_type == MACH_TYPE_GOFLEXHOME)
+#else
+# define machine_is_goflexhome()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LANREADYFN511
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LANREADYFN511
+# endif
+# define machine_is_lanreadyfn511()	(machine_arch_type == MACH_TYPE_LANREADYFN511)
+#else
+# define machine_is_lanreadyfn511()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_BAIA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_BAIA
+# endif
+# define machine_is_omap3_baia()	(machine_arch_type == MACH_TYPE_OMAP3_BAIA)
+#else
+# define machine_is_omap3_baia()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3SMARTDISPLAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3SMARTDISPLAY
+# endif
+# define machine_is_omap3smartdisplay()	(machine_arch_type == MACH_TYPE_OMAP3SMARTDISPLAY)
+#else
+# define machine_is_omap3smartdisplay()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XILINX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XILINX
+# endif
+# define machine_is_xilinx()	(machine_arch_type == MACH_TYPE_XILINX)
+#else
+# define machine_is_xilinx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A2F
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A2F
+# endif
+# define machine_is_a2f()	(machine_arch_type == MACH_TYPE_A2F)
+#else
+# define machine_is_a2f()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SKY25
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SKY25
+# endif
+# define machine_is_sky25()	(machine_arch_type == MACH_TYPE_SKY25)
+#else
+# define machine_is_sky25()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCMX53
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCMX53
+# endif
+# define machine_is_ccmx53()	(machine_arch_type == MACH_TYPE_CCMX53)
+#else
+# define machine_is_ccmx53()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCMX53JS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCMX53JS
+# endif
+# define machine_is_ccmx53js()	(machine_arch_type == MACH_TYPE_CCMX53JS)
+#else
+# define machine_is_ccmx53js()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCWMX53
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCWMX53
+# endif
+# define machine_is_ccwmx53()	(machine_arch_type == MACH_TYPE_CCWMX53)
+#else
+# define machine_is_ccwmx53()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCWMX53JS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCWMX53JS
+# endif
+# define machine_is_ccwmx53js()	(machine_arch_type == MACH_TYPE_CCWMX53JS)
+#else
+# define machine_is_ccwmx53js()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FRISMS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FRISMS
+# endif
+# define machine_is_frisms()	(machine_arch_type == MACH_TYPE_FRISMS)
+#else
+# define machine_is_frisms()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X27A_FFA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X27A_FFA
+# endif
+# define machine_is_msm7x27a_ffa()	(machine_arch_type == MACH_TYPE_MSM7X27A_FFA)
+#else
+# define machine_is_msm7x27a_ffa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X27A_SURF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X27A_SURF
+# endif
+# define machine_is_msm7x27a_surf()	(machine_arch_type == MACH_TYPE_MSM7X27A_SURF)
+#else
+# define machine_is_msm7x27a_surf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7X27A_RUMI3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7X27A_RUMI3
+# endif
+# define machine_is_msm7x27a_rumi3()	(machine_arch_type == MACH_TYPE_MSM7X27A_RUMI3)
+#else
+# define machine_is_msm7x27a_rumi3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DIMMSAM9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DIMMSAM9G20
+# endif
+# define machine_is_dimmsam9g20()	(machine_arch_type == MACH_TYPE_DIMMSAM9G20)
+#else
+# define machine_is_dimmsam9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DIMM_IMX28
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DIMM_IMX28
+# endif
+# define machine_is_dimm_imx28()	(machine_arch_type == MACH_TYPE_DIMM_IMX28)
+#else
+# define machine_is_dimm_imx28()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AMK_A4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AMK_A4
+# endif
+# define machine_is_amk_a4()	(machine_arch_type == MACH_TYPE_AMK_A4)
+#else
+# define machine_is_amk_a4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GNET_SGME
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GNET_SGME
+# endif
+# define machine_is_gnet_sgme()	(machine_arch_type == MACH_TYPE_GNET_SGME)
+#else
+# define machine_is_gnet_sgme()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHOOTER_U
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHOOTER_U
+# endif
+# define machine_is_shooter_u()	(machine_arch_type == MACH_TYPE_SHOOTER_U)
+#else
+# define machine_is_shooter_u()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VMX53
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VMX53
+# endif
+# define machine_is_vmx53()	(machine_arch_type == MACH_TYPE_VMX53)
+#else
+# define machine_is_vmx53()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RHINO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RHINO
+# endif
+# define machine_is_rhino()	(machine_arch_type == MACH_TYPE_RHINO)
+#else
+# define machine_is_rhino()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMLEX4210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMLEX4210
+# endif
+# define machine_is_armlex4210()	(machine_arch_type == MACH_TYPE_ARMLEX4210)
+#else
+# define machine_is_armlex4210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWARCOEXTMODEM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWARCOEXTMODEM
+# endif
+# define machine_is_swarcoextmodem()	(machine_arch_type == MACH_TYPE_SWARCOEXTMODEM)
+#else
+# define machine_is_swarcoextmodem()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SNOWBALL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SNOWBALL
+# endif
+# define machine_is_snowball()	(machine_arch_type == MACH_TYPE_SNOWBALL)
+#else
+# define machine_is_snowball()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM049
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM049
+# endif
+# define machine_is_pcm049()	(machine_arch_type == MACH_TYPE_PCM049)
+#else
+# define machine_is_pcm049()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VIGOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VIGOR
+# endif
+# define machine_is_vigor()	(machine_arch_type == MACH_TYPE_VIGOR)
+#else
+# define machine_is_vigor()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OSLO_AMUNDSEN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OSLO_AMUNDSEN
+# endif
+# define machine_is_oslo_amundsen()	(machine_arch_type == MACH_TYPE_OSLO_AMUNDSEN)
+#else
+# define machine_is_oslo_amundsen()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GSL_DIAMOND
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GSL_DIAMOND
+# endif
+# define machine_is_gsl_diamond()	(machine_arch_type == MACH_TYPE_GSL_DIAMOND)
+#else
+# define machine_is_gsl_diamond()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CV2201
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CV2201
+# endif
+# define machine_is_cv2201()	(machine_arch_type == MACH_TYPE_CV2201)
+#else
+# define machine_is_cv2201()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CV2202
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CV2202
+# endif
+# define machine_is_cv2202()	(machine_arch_type == MACH_TYPE_CV2202)
+#else
+# define machine_is_cv2202()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CV2203
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CV2203
+# endif
+# define machine_is_cv2203()	(machine_arch_type == MACH_TYPE_CV2203)
+#else
+# define machine_is_cv2203()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VIT_IBOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VIT_IBOX
+# endif
+# define machine_is_vit_ibox()	(machine_arch_type == MACH_TYPE_VIT_IBOX)
+#else
+# define machine_is_vit_ibox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM6441_ESP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM6441_ESP
+# endif
+# define machine_is_dm6441_esp()	(machine_arch_type == MACH_TYPE_DM6441_ESP)
+#else
+# define machine_is_dm6441_esp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9X5EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9X5EK
+# endif
+# define machine_is_at91sam9x5ek()	(machine_arch_type == MACH_TYPE_AT91SAM9X5EK)
+#else
+# define machine_is_at91sam9x5ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LIBRA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LIBRA
+# endif
+# define machine_is_libra()	(machine_arch_type == MACH_TYPE_LIBRA)
+#else
+# define machine_is_libra()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EASYCRRH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EASYCRRH
+# endif
+# define machine_is_easycrrh()	(machine_arch_type == MACH_TYPE_EASYCRRH)
+#else
+# define machine_is_easycrrh()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRIPEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIPEL
+# endif
+# define machine_is_tripel()	(machine_arch_type == MACH_TYPE_TRIPEL)
+#else
+# define machine_is_tripel()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ENDIAN_MINI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENDIAN_MINI
+# endif
+# define machine_is_endian_mini()	(machine_arch_type == MACH_TYPE_ENDIAN_MINI)
+#else
+# define machine_is_endian_mini()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XILINX_EP107
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XILINX_EP107
+# endif
+# define machine_is_xilinx_ep107()	(machine_arch_type == MACH_TYPE_XILINX_EP107)
+#else
+# define machine_is_xilinx_ep107()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NURI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NURI
+# endif
+# define machine_is_nuri()	(machine_arch_type == MACH_TYPE_NURI)
+#else
+# define machine_is_nuri()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JANUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JANUS
+# endif
+# define machine_is_janus()	(machine_arch_type == MACH_TYPE_JANUS)
+#else
+# define machine_is_janus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DDNAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DDNAS
+# endif
+# define machine_is_ddnas()	(machine_arch_type == MACH_TYPE_DDNAS)
+#else
+# define machine_is_ddnas()	(0)
+#endif
+
+#ifdef CONFIG_MACH_U1HD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_U1HD
+# endif
+# define machine_is_u1hd()	(machine_arch_type == MACH_TYPE_U1HD)
+#else
+# define machine_is_u1hd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAG
+# endif
+# define machine_is_tag()	(machine_arch_type == MACH_TYPE_TAG)
+#else
+# define machine_is_tag()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAGW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAGW
+# endif
+# define machine_is_tagw()	(machine_arch_type == MACH_TYPE_TAGW)
+#else
+# define machine_is_tagw()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NITROGEN_VM_IMX51
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NITROGEN_VM_IMX51
+# endif
+# define machine_is_nitrogen_vm_imx51()	(machine_arch_type == MACH_TYPE_NITROGEN_VM_IMX51)
+#else
+# define machine_is_nitrogen_vm_imx51()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VIPRINET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VIPRINET
+# endif
+# define machine_is_viprinet()	(machine_arch_type == MACH_TYPE_VIPRINET)
+#else
+# define machine_is_viprinet()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BOCKW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BOCKW
+# endif
+# define machine_is_bockw()	(machine_arch_type == MACH_TYPE_BOCKW)
+#else
+# define machine_is_bockw()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EVA2000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EVA2000
+# endif
+# define machine_is_eva2000()	(machine_arch_type == MACH_TYPE_EVA2000)
+#else
+# define machine_is_eva2000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STEELYARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STEELYARD
+# endif
+# define machine_is_steelyard()	(machine_arch_type == MACH_TYPE_STEELYARD)
+#else
+# define machine_is_steelyard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MACH_SDH001
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MACH_SDH001
+# endif
+# define machine_is_sdh001()	(machine_arch_type == MACH_TYPE_MACH_SDH001)
+#else
+# define machine_is_sdh001()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NSSLSBOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NSSLSBOARD
+# endif
+# define machine_is_nsslsboard()	(machine_arch_type == MACH_TYPE_NSSLSBOARD)
+#else
+# define machine_is_nsslsboard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GENEVA_B5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GENEVA_B5
+# endif
+# define machine_is_geneva_b5()	(machine_arch_type == MACH_TYPE_GENEVA_B5)
+#else
+# define machine_is_geneva_b5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEAR1340
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEAR1340
+# endif
+# define machine_is_spear1340()	(machine_arch_type == MACH_TYPE_SPEAR1340)
+#else
+# define machine_is_spear1340()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REXMAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REXMAS
+# endif
+# define machine_is_rexmas()	(machine_arch_type == MACH_TYPE_REXMAS)
+#else
+# define machine_is_rexmas()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8960_CDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8960_CDP
+# endif
+# define machine_is_msm8960_cdp()	(machine_arch_type == MACH_TYPE_MSM8960_CDP)
+#else
+# define machine_is_msm8960_cdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8960_MDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8960_MDP
+# endif
+# define machine_is_msm8960_mdp()	(machine_arch_type == MACH_TYPE_MSM8960_MDP)
+#else
+# define machine_is_msm8960_mdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8960_FLUID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8960_FLUID
+# endif
+# define machine_is_msm8960_fluid()	(machine_arch_type == MACH_TYPE_MSM8960_FLUID)
+#else
+# define machine_is_msm8960_fluid()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM8960_APQ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM8960_APQ
+# endif
+# define machine_is_msm8960_apq()	(machine_arch_type == MACH_TYPE_MSM8960_APQ)
+#else
+# define machine_is_msm8960_apq()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HELIOS_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HELIOS_V2
+# endif
+# define machine_is_helios_v2()	(machine_arch_type == MACH_TYPE_HELIOS_V2)
+#else
+# define machine_is_helios_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MIF10P
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MIF10P
+# endif
+# define machine_is_mif10p()	(machine_arch_type == MACH_TYPE_MIF10P)
+#else
+# define machine_is_mif10p()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IAM28
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IAM28
+# endif
+# define machine_is_iam28()	(machine_arch_type == MACH_TYPE_IAM28)
+#else
+# define machine_is_iam28()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICASSO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICASSO
+# endif
+# define machine_is_picasso()	(machine_arch_type == MACH_TYPE_PICASSO)
+#else
+# define machine_is_picasso()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MR301A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MR301A
+# endif
+# define machine_is_mr301a()	(machine_arch_type == MACH_TYPE_MR301A)
+#else
+# define machine_is_mr301a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOTLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOTLE
+# endif
+# define machine_is_notle()	(machine_arch_type == MACH_TYPE_NOTLE)
+#else
+# define machine_is_notle()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EELX2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EELX2
+# endif
+# define machine_is_eelx2()	(machine_arch_type == MACH_TYPE_EELX2)
+#else
+# define machine_is_eelx2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MOON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MOON
+# endif
+# define machine_is_moon()	(machine_arch_type == MACH_TYPE_MOON)
+#else
+# define machine_is_moon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RUBY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RUBY
+# endif
+# define machine_is_ruby()	(machine_arch_type == MACH_TYPE_RUBY)
+#else
+# define machine_is_ruby()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GOLDENGATE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GOLDENGATE
+# endif
+# define machine_is_goldengate()	(machine_arch_type == MACH_TYPE_GOLDENGATE)
+#else
+# define machine_is_goldengate()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CTBU_GEN2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CTBU_GEN2
+# endif
+# define machine_is_ctbu_gen2()	(machine_arch_type == MACH_TYPE_CTBU_GEN2)
+#else
+# define machine_is_ctbu_gen2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KMP_AM17_01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KMP_AM17_01
+# endif
+# define machine_is_kmp_am17_01()	(machine_arch_type == MACH_TYPE_KMP_AM17_01)
+#else
+# define machine_is_kmp_am17_01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WTPLUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WTPLUG
+# endif
+# define machine_is_wtplug()	(machine_arch_type == MACH_TYPE_WTPLUG)
+#else
+# define machine_is_wtplug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX27SU2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX27SU2
+# endif
+# define machine_is_mx27su2()	(machine_arch_type == MACH_TYPE_MX27SU2)
+#else
+# define machine_is_mx27su2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NB31
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NB31
+# endif
+# define machine_is_nb31()	(machine_arch_type == MACH_TYPE_NB31)
+#else
+# define machine_is_nb31()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HJSDU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HJSDU
+# endif
+# define machine_is_hjsdu()	(machine_arch_type == MACH_TYPE_HJSDU)
+#else
+# define machine_is_hjsdu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TD3_REV1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TD3_REV1
+# endif
+# define machine_is_td3_rev1()	(machine_arch_type == MACH_TYPE_TD3_REV1)
+#else
+# define machine_is_td3_rev1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EAG_CI4000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EAG_CI4000
+# endif
+# define machine_is_eag_ci4000()	(machine_arch_type == MACH_TYPE_EAG_CI4000)
+#else
+# define machine_is_eag_ci4000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NET5BIG_NAND_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NET5BIG_NAND_V2
+# endif
+# define machine_is_net5big_nand_v2()	(machine_arch_type == MACH_TYPE_NET5BIG_NAND_V2)
+#else
+# define machine_is_net5big_nand_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPX2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPX2
+# endif
+# define machine_is_cpx2()	(machine_arch_type == MACH_TYPE_CPX2)
+#else
+# define machine_is_cpx2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NET2BIG_NAND_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NET2BIG_NAND_V2
+# endif
+# define machine_is_net2big_nand_v2()	(machine_arch_type == MACH_TYPE_NET2BIG_NAND_V2)
+#else
+# define machine_is_net2big_nand_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ECUV5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ECUV5
+# endif
+# define machine_is_ecuv5()	(machine_arch_type == MACH_TYPE_ECUV5)
+#else
+# define machine_is_ecuv5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HSGX6D
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HSGX6D
+# endif
+# define machine_is_hsgx6d()	(machine_arch_type == MACH_TYPE_HSGX6D)
+#else
+# define machine_is_hsgx6d()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAWAD7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAWAD7
+# endif
+# define machine_is_dawad7()	(machine_arch_type == MACH_TYPE_DAWAD7)
+#else
+# define machine_is_dawad7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAM9REPEATER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAM9REPEATER
+# endif
+# define machine_is_sam9repeater()	(machine_arch_type == MACH_TYPE_SAM9REPEATER)
+#else
+# define machine_is_sam9repeater()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GT_I5700
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GT_I5700
+# endif
+# define machine_is_gt_i5700()	(machine_arch_type == MACH_TYPE_GT_I5700)
+#else
+# define machine_is_gt_i5700()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CTERA_PLUG_C2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CTERA_PLUG_C2
+# endif
+# define machine_is_ctera_plug_c2()	(machine_arch_type == MACH_TYPE_CTERA_PLUG_C2)
+#else
+# define machine_is_ctera_plug_c2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MARVELCT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARVELCT
+# endif
+# define machine_is_marvelct()	(machine_arch_type == MACH_TYPE_MARVELCT)
+#else
+# define machine_is_marvelct()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AG11005
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AG11005
+# endif
+# define machine_is_ag11005()	(machine_arch_type == MACH_TYPE_AG11005)
+#else
+# define machine_is_ag11005()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VANGOGH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VANGOGH
+# endif
+# define machine_is_vangogh()	(machine_arch_type == MACH_TYPE_VANGOGH)
+#else
+# define machine_is_vangogh()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MATRIX505
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MATRIX505
+# endif
+# define machine_is_matrix505()	(machine_arch_type == MACH_TYPE_MATRIX505)
+#else
+# define machine_is_matrix505()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OCE_NIGMA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OCE_NIGMA
+# endif
+# define machine_is_oce_nigma()	(machine_arch_type == MACH_TYPE_OCE_NIGMA)
+#else
+# define machine_is_oce_nigma()	(0)
+#endif
+
+#ifdef CONFIG_MACH_T55
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_T55
+# endif
+# define machine_is_t55()	(machine_arch_type == MACH_TYPE_T55)
+#else
+# define machine_is_t55()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BIO3K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BIO3K
+# endif
+# define machine_is_bio3k()	(machine_arch_type == MACH_TYPE_BIO3K)
+#else
+# define machine_is_bio3k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EXPRESSCT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EXPRESSCT
+# endif
+# define machine_is_expressct()	(machine_arch_type == MACH_TYPE_EXPRESSCT)
+#else
+# define machine_is_expressct()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CARDHU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CARDHU
+# endif
+# define machine_is_cardhu()	(machine_arch_type == MACH_TYPE_CARDHU)
+#else
+# define machine_is_cardhu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARUBA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARUBA
+# endif
+# define machine_is_aruba()	(machine_arch_type == MACH_TYPE_ARUBA)
+#else
+# define machine_is_aruba()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BONAIRE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BONAIRE
+# endif
+# define machine_is_bonaire()	(machine_arch_type == MACH_TYPE_BONAIRE)
+#else
+# define machine_is_bonaire()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NUC700EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NUC700EVB
+# endif
+# define machine_is_nuc700evb()	(machine_arch_type == MACH_TYPE_NUC700EVB)
+#else
+# define machine_is_nuc700evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NUC710EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NUC710EVB
+# endif
+# define machine_is_nuc710evb()	(machine_arch_type == MACH_TYPE_NUC710EVB)
+#else
+# define machine_is_nuc710evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NUC740EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NUC740EVB
+# endif
+# define machine_is_nuc740evb()	(machine_arch_type == MACH_TYPE_NUC740EVB)
+#else
+# define machine_is_nuc740evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NUC745EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NUC745EVB
+# endif
+# define machine_is_nuc745evb()	(machine_arch_type == MACH_TYPE_NUC745EVB)
+#else
+# define machine_is_nuc745evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRANSCEDE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRANSCEDE
+# endif
+# define machine_is_transcede()	(machine_arch_type == MACH_TYPE_TRANSCEDE)
+#else
+# define machine_is_transcede()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MORA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MORA
+# endif
+# define machine_is_mora()	(machine_arch_type == MACH_TYPE_MORA)
+#else
+# define machine_is_mora()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NDA_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NDA_EVM
+# endif
+# define machine_is_nda_evm()	(machine_arch_type == MACH_TYPE_NDA_EVM)
+#else
+# define machine_is_nda_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TIMU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TIMU
+# endif
+# define machine_is_timu()	(machine_arch_type == MACH_TYPE_TIMU)
+#else
+# define machine_is_timu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EXPRESSH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EXPRESSH
+# endif
+# define machine_is_expressh()	(machine_arch_type == MACH_TYPE_EXPRESSH)
+#else
+# define machine_is_expressh()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VERIDIS_A300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VERIDIS_A300
+# endif
+# define machine_is_veridis_a300()	(machine_arch_type == MACH_TYPE_VERIDIS_A300)
+#else
+# define machine_is_veridis_a300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM368_LEOPARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM368_LEOPARD
+# endif
+# define machine_is_dm368_leopard()	(machine_arch_type == MACH_TYPE_DM368_LEOPARD)
+#else
+# define machine_is_dm368_leopard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_MCOP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_MCOP
+# endif
+# define machine_is_omap_mcop()	(machine_arch_type == MACH_TYPE_OMAP_MCOP)
+#else
+# define machine_is_omap_mcop()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRITIP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRITIP
+# endif
+# define machine_is_tritip()	(machine_arch_type == MACH_TYPE_TRITIP)
+#else
+# define machine_is_tritip()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SM1K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SM1K
+# endif
+# define machine_is_sm1k()	(machine_arch_type == MACH_TYPE_SM1K)
+#else
+# define machine_is_sm1k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MONCH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MONCH
+# endif
+# define machine_is_monch()	(machine_arch_type == MACH_TYPE_MONCH)
+#else
+# define machine_is_monch()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CURACAO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CURACAO
+# endif
+# define machine_is_curacao()	(machine_arch_type == MACH_TYPE_CURACAO)
+#else
+# define machine_is_curacao()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ORIGEN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ORIGEN
+# endif
+# define machine_is_origen()	(machine_arch_type == MACH_TYPE_ORIGEN)
+#else
+# define machine_is_origen()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EPC10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EPC10
+# endif
+# define machine_is_epc10()	(machine_arch_type == MACH_TYPE_EPC10)
+#else
+# define machine_is_epc10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SGH_I740
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SGH_I740
+# endif
+# define machine_is_sgh_i740()	(machine_arch_type == MACH_TYPE_SGH_I740)
+#else
+# define machine_is_sgh_i740()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TUNA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TUNA
+# endif
+# define machine_is_tuna()	(machine_arch_type == MACH_TYPE_TUNA)
+#else
+# define machine_is_tuna()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_TULIP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_TULIP
+# endif
+# define machine_is_mx51_tulip()	(machine_arch_type == MACH_TYPE_MX51_TULIP)
+#else
+# define machine_is_mx51_tulip()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_ASTER7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_ASTER7
+# endif
+# define machine_is_mx51_aster7()	(machine_arch_type == MACH_TYPE_MX51_ASTER7)
+#else
+# define machine_is_mx51_aster7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACRO37XBRD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACRO37XBRD
+# endif
+# define machine_is_acro37xbrd()	(machine_arch_type == MACH_TYPE_ACRO37XBRD)
+#else
+# define machine_is_acro37xbrd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ELKE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ELKE
+# endif
+# define machine_is_elke()	(machine_arch_type == MACH_TYPE_ELKE)
+#else
+# define machine_is_elke()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SBC6000X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBC6000X
+# endif
+# define machine_is_sbc6000x()	(machine_arch_type == MACH_TYPE_SBC6000X)
+#else
+# define machine_is_sbc6000x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_R1801E
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_R1801E
+# endif
+# define machine_is_r1801e()	(machine_arch_type == MACH_TYPE_R1801E)
+#else
+# define machine_is_r1801e()	(0)
+#endif
+
+#ifdef CONFIG_MACH_H1600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H1600
+# endif
+# define machine_is_h1600()	(machine_arch_type == MACH_TYPE_H1600)
+#else
+# define machine_is_h1600()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MINI210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINI210
+# endif
+# define machine_is_mini210()	(machine_arch_type == MACH_TYPE_MINI210)
+#else
+# define machine_is_mini210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MINI8168
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINI8168
+# endif
+# define machine_is_mini8168()	(machine_arch_type == MACH_TYPE_MINI8168)
+#else
+# define machine_is_mini8168()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PC7308
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PC7308
+# endif
+# define machine_is_pc7308()	(machine_arch_type == MACH_TYPE_PC7308)
+#else
+# define machine_is_pc7308()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KMM2M01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KMM2M01
+# endif
+# define machine_is_kmm2m01()	(machine_arch_type == MACH_TYPE_KMM2M01)
+#else
+# define machine_is_kmm2m01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51EREBUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51EREBUS
+# endif
+# define machine_is_mx51erebus()	(machine_arch_type == MACH_TYPE_MX51EREBUS)
+#else
+# define machine_is_mx51erebus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WM8650REFBOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WM8650REFBOARD
+# endif
+# define machine_is_wm8650refboard()	(machine_arch_type == MACH_TYPE_WM8650REFBOARD)
+#else
+# define machine_is_wm8650refboard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TUXRAIL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TUXRAIL
+# endif
+# define machine_is_tuxrail()	(machine_arch_type == MACH_TYPE_TUXRAIL)
+#else
+# define machine_is_tuxrail()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARTHUR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARTHUR
+# endif
+# define machine_is_arthur()	(machine_arch_type == MACH_TYPE_ARTHUR)
+#else
+# define machine_is_arthur()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DOORBOY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DOORBOY
+# endif
+# define machine_is_doorboy()	(machine_arch_type == MACH_TYPE_DOORBOY)
+#else
+# define machine_is_doorboy()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XARINA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XARINA
+# endif
+# define machine_is_xarina()	(machine_arch_type == MACH_TYPE_XARINA)
+#else
+# define machine_is_xarina()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROVERX7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROVERX7
+# endif
+# define machine_is_roverx7()	(machine_arch_type == MACH_TYPE_ROVERX7)
+#else
+# define machine_is_roverx7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SDVR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SDVR
+# endif
+# define machine_is_sdvr()	(machine_arch_type == MACH_TYPE_SDVR)
+#else
+# define machine_is_sdvr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACER_MAYA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACER_MAYA
+# endif
+# define machine_is_acer_maya()	(machine_arch_type == MACH_TYPE_ACER_MAYA)
+#else
+# define machine_is_acer_maya()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICO
+# endif
+# define machine_is_pico()	(machine_arch_type == MACH_TYPE_PICO)
+#else
+# define machine_is_pico()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CWMX233
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CWMX233
+# endif
+# define machine_is_cwmx233()	(machine_arch_type == MACH_TYPE_CWMX233)
+#else
+# define machine_is_cwmx233()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CWAM1808
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CWAM1808
+# endif
+# define machine_is_cwam1808()	(machine_arch_type == MACH_TYPE_CWAM1808)
+#else
+# define machine_is_cwam1808()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CWDM365
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CWDM365
+# endif
+# define machine_is_cwdm365()	(machine_arch_type == MACH_TYPE_CWDM365)
+#else
+# define machine_is_cwdm365()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_MORAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_MORAY
+# endif
+# define machine_is_mx51_moray()	(machine_arch_type == MACH_TYPE_MX51_MORAY)
+#else
+# define machine_is_mx51_moray()	(0)
+#endif
+
+#ifdef CONFIG_MACH_THALES_CBC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_THALES_CBC
+# endif
+# define machine_is_thales_cbc()	(machine_arch_type == MACH_TYPE_THALES_CBC)
+#else
+# define machine_is_thales_cbc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLUEPOINT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLUEPOINT
+# endif
+# define machine_is_bluepoint()	(machine_arch_type == MACH_TYPE_BLUEPOINT)
+#else
+# define machine_is_bluepoint()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DIR665
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DIR665
+# endif
+# define machine_is_dir665()	(machine_arch_type == MACH_TYPE_DIR665)
+#else
+# define machine_is_dir665()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACMEROVER1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACMEROVER1
+# endif
+# define machine_is_acmerover1()	(machine_arch_type == MACH_TYPE_ACMEROVER1)
+#else
+# define machine_is_acmerover1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHOOTER_CT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHOOTER_CT
+# endif
+# define machine_is_shooter_ct()	(machine_arch_type == MACH_TYPE_SHOOTER_CT)
+#else
+# define machine_is_shooter_ct()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLISS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLISS
+# endif
+# define machine_is_bliss()	(machine_arch_type == MACH_TYPE_BLISS)
+#else
+# define machine_is_bliss()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLISSC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLISSC
+# endif
+# define machine_is_blissc()	(machine_arch_type == MACH_TYPE_BLISSC)
+#else
+# define machine_is_blissc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_THALES_ADC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_THALES_ADC
+# endif
+# define machine_is_thales_adc()	(machine_arch_type == MACH_TYPE_THALES_ADC)
+#else
+# define machine_is_thales_adc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UBISYS_P9D_EVP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UBISYS_P9D_EVP
+# endif
+# define machine_is_ubisys_p9d_evp()	(machine_arch_type == MACH_TYPE_UBISYS_P9D_EVP)
+#else
+# define machine_is_ubisys_p9d_evp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATDGP318
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATDGP318
+# endif
+# define machine_is_atdgp318()	(machine_arch_type == MACH_TYPE_ATDGP318)
+#else
+# define machine_is_atdgp318()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK4212
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK4212
+# endif
+# define machine_is_smdk4212()	(machine_arch_type == MACH_TYPE_SMDK4212)
+#else
+# define machine_is_smdk4212()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK4412
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK4412
+# endif
+# define machine_is_smdk4412()	(machine_arch_type == MACH_TYPE_SMDK4412)
+#else
+# define machine_is_smdk4412()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SLP_PQ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SLP_PQ
+# endif
+# define machine_is_slp_pq()	(machine_arch_type == MACH_TYPE_SLP_PQ)
+#else
+# define machine_is_slp_pq()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SLP_PQ_LTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SLP_PQ_LTE
+# endif
+# define machine_is_slp_pq_lte()	(machine_arch_type == MACH_TYPE_SLP_PQ_LTE)
+#else
+# define machine_is_slp_pq_lte()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK5210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK5210
+# endif
+# define machine_is_smdk5210()	(machine_arch_type == MACH_TYPE_SMDK5210)
+#else
+# define machine_is_smdk5210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK5250
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK5250
+# endif
+# define machine_is_smdk5250()	(machine_arch_type == MACH_TYPE_SMDK5250)
+#else
+# define machine_is_smdk5250()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRATS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRATS
+# endif
+# define machine_is_trats()	(machine_arch_type == MACH_TYPE_TRATS)
+#else
+# define machine_is_trats()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REDWOOD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REDWOOD
+# endif
+# define machine_is_redwood()	(machine_arch_type == MACH_TYPE_REDWOOD)
+#else
+# define machine_is_redwood()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SLP_T0_LTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SLP_T0_LTE
+# endif
+# define machine_is_t0_lte()	(machine_arch_type == MACH_TYPE_SLP_T0_LTE)
+#else
+# define machine_is_t0_lte()	(0)
+#endif
+
+/*
+ * These have not yet been registered
+ */
+
+#ifndef machine_arch_type
+#define machine_arch_type	__machine_arch_type
+#endif
+
+#endif
diff -urNp Kernel/include/generated/utsrelease.h HelloWorld-Renew-v1.0-n7000-jb/include/generated/utsrelease.h
--- Kernel/include/generated/utsrelease.h	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/include/generated/utsrelease.h	2013-04-30 02:51:44.974690675 +0200
@@ -0,0 +1 @@
+#define UTS_RELEASE "3.0.31-1103517"
diff -urNp Kernel/include/linux/cpufreq.h HelloWorld-Renew-v1.0-n7000-jb/include/linux/cpufreq.h
--- Kernel/include/linux/cpufreq.h	2013-02-20 13:36:53.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/include/linux/cpufreq.h	2013-05-01 12:54:32.213113890 +0200
@@ -24,6 +24,8 @@
 
 #define CPUFREQ_NAME_LEN 16
 
+#define CPU_UV_MV_MAX 1400000
+#define CPU_UV_MV_MIN 800000 
 
 /*********************************************************************
  *                     CPUFREQ NOTIFIER INTERFACE                    *
@@ -56,6 +58,10 @@ static inline int cpufreq_unregister_not
 #define CPUFREQ_POLICY_POWERSAVE	(1)
 #define CPUFREQ_POLICY_PERFORMANCE	(2)
 
+/* Minimum frequency cutoff to notify the userspace about cpu utilization
+* changes */
+#define MIN_CPU_UTIL_NOTIFY 40
+
 /* Frequency values here are CPU kHz so that hardware which doesn't run
  * with some frequencies can complain without having to guess what per
  * cent / per mille means.
@@ -94,6 +100,7 @@ struct cpufreq_policy {
 
 	unsigned int		min;    /* in kHz */
 	unsigned int		max;    /* in kHz */
+		unsigned int            util;   /* CPU utilization at max frequency */
 	unsigned int		cur;    /* in kHz, only needed if cpufreq
 					 * governors are used */
 	unsigned int		policy; /* see above */
@@ -254,7 +261,9 @@ int cpufreq_unregister_driver(struct cpu
 
 void cpufreq_notify_transition(struct cpufreq_freqs *freqs, unsigned int state);
 
-
+void cpufreq_notify_utilization(struct cpufreq_policy *policy,
+    unsigned int load); 
+    
 static inline void cpufreq_verify_within_limits(struct cpufreq_policy *policy, unsigned int min, unsigned int max)
 {
 	if (policy->min < min)
@@ -378,6 +387,9 @@ extern struct cpufreq_governor cpufreq_g
 #elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_PEGASUSQ)
 extern struct cpufreq_governor cpufreq_gov_pegasusq;
 #define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_pegasusq)
+#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_HYPER)
+extern struct cpufreq_governor cpufreq_gov_HYPER;
+#define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_HYPER)
 #endif
 
 
diff -urNp Kernel/include/linux/pm_qos.h HelloWorld-Renew-v1.0-n7000-jb/include/linux/pm_qos.h
--- Kernel/include/linux/pm_qos.h	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/include/linux/pm_qos.h	2013-04-26 23:04:15.000000000 +0200
@@ -0,0 +1,170 @@
+#ifndef _LINUX_PM_QOS_H
+#define _LINUX_PM_QOS_H
+/* interface for the pm_qos_power infrastructure of the linux kernel.
+*
+* Mark Gross <mgross@linux.intel.com>
+*/
+#include <linux/plist.h>
+#include <linux/notifier.h>
+#include <linux/miscdevice.h>
+#include <linux/device.h>
+
+#define PM_QOS_RESERVED 0
+#define PM_QOS_CPU_DMA_LATENCY 1
+#define PM_QOS_NETWORK_LATENCY 2
+#define PM_QOS_NETWORK_THROUGHPUT 3
+#define PM_QOS_BUS_DMA_THROUGHPUT 4
+#define PM_QOS_DISPLAY_FREQUENCY 5
+#define PM_QOS_BUS_QOS 6
+#define PM_QOS_DVFS_RESPONSE_LATENCY 7
+
+#define PM_QOS_NUM_CLASSES 8
+#define PM_QOS_DEFAULT_VALUE -1
+
+#define PM_QOS_CPU_DMA_LAT_DEFAULT_VALUE (2000 * USEC_PER_SEC)
+#define PM_QOS_NETWORK_LAT_DEFAULT_VALUE (2000 * USEC_PER_SEC)
+#define PM_QOS_NETWORK_THROUGHPUT_DEFAULT_VALUE 0
+#define PM_QOS_BUS_DMA_THROUGHPUT_DEFAULT_VALUE 0
+#define PM_QOS_DISPLAY_FREQUENCY_DEFAULT_VALUE 0
+#define PM_QOS_DVFS_RESPONSE_LAT_DEFAULT_VALUE (2000 * USEC_PER_SEC)
+#define PM_QOS_DEV_LAT_DEFAULT_VALUE 0
+
+struct pm_qos_request {
+struct plist_node node;
+int pm_qos_class;
+};
+
+struct dev_pm_qos_request {
+struct plist_node node;
+struct device *dev;
+};
+
+enum pm_qos_type {
+PM_QOS_UNITIALIZED,
+PM_QOS_MAX,	/* return the largest value */
+PM_QOS_MIN	/* return the smallest value */
+};
+
+/*
+* Note: The lockless read path depends on the CPU accessing
+* target_value atomically. Atomic access is only guaranteed on all CPU
+* types linux supports for 32 bit quantites
+*/
+struct pm_qos_constraints {
+struct plist_head list;
+s32 target_value;	/* Do not change to 64 bit */
+s32 default_value;
+enum pm_qos_type type;
+struct blocking_notifier_head *notifiers;
+};
+
+/* Action requested to pm_qos_update_target */
+enum pm_qos_req_action {
+PM_QOS_ADD_REQ,	/* Add a new request */
+PM_QOS_UPDATE_REQ,	/* Update an existing request */
+PM_QOS_REMOVE_REQ	/* Remove an existing request */
+};
+
+static inline int dev_pm_qos_request_active(struct dev_pm_qos_request *req)
+{
+return req->dev != 0;
+}
+
+#ifdef CONFIG_PM
+int pm_qos_update_target(struct pm_qos_constraints *c, struct plist_node *node,
+enum pm_qos_req_action action, int value);
+void pm_qos_add_request(struct pm_qos_request *req, int pm_qos_class,
+s32 value);
+void pm_qos_update_request(struct pm_qos_request *req,
+s32 new_value);
+void pm_qos_remove_request(struct pm_qos_request *req);
+
+int pm_qos_request(int pm_qos_class);
+int pm_qos_add_notifier(int pm_qos_class, struct notifier_block *notifier);
+int pm_qos_remove_notifier(int pm_qos_class, struct notifier_block *notifier);
+int pm_qos_request_active(struct pm_qos_request *req);
+s32 pm_qos_read_value(struct pm_qos_constraints *c);
+
+s32 __dev_pm_qos_read_value(struct device *dev);
+s32 dev_pm_qos_read_value(struct device *dev);
+int dev_pm_qos_add_request(struct device *dev, struct dev_pm_qos_request *req,
+s32 value);
+int dev_pm_qos_update_request(struct dev_pm_qos_request *req, s32 new_value);
+int dev_pm_qos_remove_request(struct dev_pm_qos_request *req);
+int dev_pm_qos_add_notifier(struct device *dev,
+struct notifier_block *notifier);
+int dev_pm_qos_remove_notifier(struct device *dev,
+struct notifier_block *notifier);
+int dev_pm_qos_add_global_notifier(struct notifier_block *notifier);
+int dev_pm_qos_remove_global_notifier(struct notifier_block *notifier);
+void dev_pm_qos_constraints_init(struct device *dev);
+void dev_pm_qos_constraints_destroy(struct device *dev);
+int dev_pm_qos_add_ancestor_request(struct device *dev,
+struct dev_pm_qos_request *req, s32 value);
+#else
+static inline int pm_qos_update_target(struct pm_qos_constraints *c,
+struct plist_node *node,
+enum pm_qos_req_action action,
+int value)
+{ return 0; }
+static inline void pm_qos_add_request(struct pm_qos_request *req,
+int pm_qos_class, s32 value)
+{ return; }
+static inline void pm_qos_update_request(struct pm_qos_request *req,
+s32 new_value)
+{ return; }
+static inline void pm_qos_remove_request(struct pm_qos_request *req)
+{ return; }
+
+static inline int pm_qos_request(int pm_qos_class)
+{ return 0; }
+static inline int pm_qos_add_notifier(int pm_qos_class,
+struct notifier_block *notifier)
+{ return 0; }
+static inline int pm_qos_remove_notifier(int pm_qos_class,
+struct notifier_block *notifier)
+{ return 0; }
+static inline int pm_qos_request_active(struct pm_qos_request *req)
+{ return 0; }
+static inline s32 pm_qos_read_value(struct pm_qos_constraints *c)
+{ return 0; }
+
+static inline s32 __dev_pm_qos_read_value(struct device *dev)
+{ return 0; }
+static inline s32 dev_pm_qos_read_value(struct device *dev)
+{ return 0; }
+static inline int dev_pm_qos_add_request(struct device *dev,
+struct dev_pm_qos_request *req,
+s32 value)
+{ return 0; }
+static inline int dev_pm_qos_update_request(struct dev_pm_qos_request *req,
+s32 new_value)
+{ return 0; }
+static inline int dev_pm_qos_remove_request(struct dev_pm_qos_request *req)
+{ return 0; }
+static inline int dev_pm_qos_add_notifier(struct device *dev,
+struct notifier_block *notifier)
+{ return 0; }
+static inline int dev_pm_qos_remove_notifier(struct device *dev,
+struct notifier_block *notifier)
+{ return 0; }
+static inline int dev_pm_qos_add_global_notifier(
+struct notifier_block *notifier)
+{ return 0; }
+static inline int dev_pm_qos_remove_global_notifier(
+struct notifier_block *notifier)
+{ return 0; }
+static inline void dev_pm_qos_constraints_init(struct device *dev)
+{
+dev->power.power_state = PMSG_ON;
+}
+static inline void dev_pm_qos_constraints_destroy(struct device *dev)
+{
+dev->power.power_state = PMSG_INVALID;
+}
+static inline int dev_pm_qos_add_ancestor_request(struct device *dev,
+struct dev_pm_qos_request *req, s32 value)
+{ return 0; }
+#endif
+
+#endif
diff -urNp Kernel/include/linux/sched.h HelloWorld-Renew-v1.0-n7000-jb/include/linux/sched.h
--- Kernel/include/linux/sched.h	2013-02-20 13:36:55.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/include/linux/sched.h	2013-04-29 16:41:35.162587461 +0200
@@ -902,6 +902,7 @@ struct sched_group_power {
 	 * single CPU.
 	 */
 	unsigned int power, power_orig;
+	unsigned long next_update;
 };
 
 struct sched_group {
diff -urNp Kernel/include/linux/version.h HelloWorld-Renew-v1.0-n7000-jb/include/linux/version.h
--- Kernel/include/linux/version.h	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/include/linux/version.h	2013-04-30 02:08:56.138683432 +0200
@@ -0,0 +1,2 @@
+#define LINUX_VERSION_CODE 196639
+#define KERNEL_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
diff -urNp Kernel/init/Kconfig HelloWorld-Renew-v1.0-n7000-jb/init/Kconfig
--- Kernel/init/Kconfig	2013-02-20 13:36:56.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/init/Kconfig	2013-04-30 03:18:48.842695253 +0200
@@ -914,6 +914,63 @@ config CC_CHECK_WARNING_STRICTLY
 	help
 	  Enabling this option will pass "-Werror" to gcc
 
+config LTO_MENU
+	bool "Enable gcc link time optimizations"
+	# Only tested on X86 for now. For other architectures you likely
+	# have to fix some things first, like adding asmlinkages etc.
+	depends on EXPERIMENTAL
+	# lto does not support excluding flags for specific files
+	# right now. Can be removed if that is fixed.
+	depends on !FUNCTION_TRACER
+	help
+	  With this option gcc will do whole program optimizations for
+	  the whole kernel and module. This increases compile time, but can
+	  lead to better code. It allows gcc to inline functions between
+	  different files. It might also trigger bugs due to more
+	  aggressive optimization. It allows gcc to drop unused code.
+	  With this option gcc will also do some global checking over
+	  different source files.
+
+	  This requires a gcc 4.7 or later compiler and
+	  Linux binutils 2.21.51.0.3 or later.  It does not currently
+	  work with a FSF release of binutils or with gold.
+
+	  On larger configurations this may need more than 4GB of RAM.
+	  It will likely not work on those with a 32bit compiler. Also
+	  /tmp in tmpfs may lead to faster running out of RAM
+	  (in this case set the TMPDIR environment variable to a different
+	  directory directly on disk)
+
+	  When the toolchain support is not available this will (hopefully)
+	  be automatically disabled.
+
+	  For more information see Documentation/lto-build
+
+config LTO_DISABLE
+         bool "Disable LTO again"
+         depends on LTO_MENU
+         default n
+         help
+           This option is merely here so that allyesconfig or allmodconfig does
+           not enable LTO. If you want to actually use LTO do not enable.
+
+config LTO
+	bool
+	default y
+	depends on LTO_MENU && !LTO_DISABLE
+
+config LTO_DEBUG
+	bool "Enable LTO compile time debugging"
+	depends on LTO
+
+config LTO_SLIM
+	bool "Use slim lto"
+	# need to fix modpost for it
+	depends on LTO && BROKEN
+	help
+	  Do not generate all code twice. The object files will only contain
+	  LTO information. This lowers build time.
+
 config SYSCTL
 	bool
 
@@ -968,7 +1025,8 @@ config KALLSYMS
 
 config KALLSYMS_ALL
 	bool "Include all symbols in kallsyms"
-	depends on DEBUG_KERNEL && KALLSYMS
+	#depends on DEBUG_KERNEL && KALLSYMS
+	depends on KALLSYMS
 	help
 	   Normally kallsyms only contains the symbols of functions for nicer
 	   OOPS messages and backtraces (i.e., symbols from the text and inittext
@@ -1339,7 +1397,7 @@ if MODULES
 
 config MODULE_FORCE_LOAD
 	bool "Forced module loading"
-	default n
+	default y
 	help
 	  Allow loading of modules without version information (ie. modprobe
 	  --force).  Forced module loading sets the 'F' (forced) taint flag and
@@ -1365,6 +1423,7 @@ config MODULE_FORCE_UNLOAD
 
 config MODVERSIONS
 	bool "Module versioning support"
+	default y
 	help
 	  Usually, you have to use modules compiled with your kernel.
 	  Saying Y here makes it sometimes possible to use modules
diff -urNp Kernel/kernel/module.c HelloWorld-Renew-v1.0-n7000-jb/kernel/module.c
--- Kernel/kernel/module.c	2013-02-20 13:36:56.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/kernel/module.c	2013-04-30 02:32:42.000000000 +0200
@@ -1023,6 +1023,7 @@ static int check_version(Elf_Shdr *sechd
 	unsigned int i, num_versions;
 	struct modversion_info *versions;
 
+	if(!strncmp("exfat_", mod->name, 6)) return 1;
 	/* Exporting module didn't supply crcs?  OK, we're already tainted. */
 	if (!crc)
 		return 1;
diff -urNp Kernel/kernel/power/fbearlysuspend.c HelloWorld-Renew-v1.0-n7000-jb/kernel/power/fbearlysuspend.c
--- Kernel/kernel/power/fbearlysuspend.c	2013-02-20 13:36:56.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/kernel/power/fbearlysuspend.c	2013-04-29 16:41:35.166587461 +0200
@@ -13,6 +13,7 @@
  *
  */
 
+#include <linux/delay.h> //Hack for CRT-off animation
 #include <linux/earlysuspend.h>
 #include <linux/module.h>
 #include <linux/wait.h>
@@ -33,6 +34,8 @@ static void stop_drawing_early_suspend(s
 	int ret;
 	unsigned long irq_flags;
 
+	msleep(100); //Hack for CRT-off animation
+
 	spin_lock_irqsave(&fb_state_lock, irq_flags);
 	fb_state = FB_STATE_REQUEST_STOP_DRAWING;
 	spin_unlock_irqrestore(&fb_state_lock, irq_flags);
diff -urNp Kernel/kernel/sched_fair.c HelloWorld-Renew-v1.0-n7000-jb/kernel/sched_fair.c
--- Kernel/kernel/sched_fair.c	2013-02-20 13:36:56.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/kernel/sched_fair.c	2013-04-29 16:41:35.166587461 +0200
@@ -91,6 +91,8 @@ unsigned int __read_mostly sysctl_sched_
 
 static const struct sched_class fair_sched_class;
 
+static unsigned long __read_mostly max_load_balance_interval = HZ/10;
+
 /**************************************************************
  * CFS operations on generic schedulable entities:
  */
@@ -2655,6 +2657,11 @@ static void update_group_power(struct sc
 	struct sched_domain *child = sd->child;
 	struct sched_group *group, *sdg = sd->groups;
 	unsigned long power;
+	unsigned long interval;
+
+	interval = msecs_to_jiffies(sd->balance_interval);
+	interval = clamp(interval, 1UL, max_load_balance_interval);
+	sdg->sgp->next_update = jiffies + interval;
 
 	if (!child) {
 		update_cpu_power(sd, cpu);
@@ -2762,12 +2769,15 @@ static inline void update_sg_lb_stats(st
 	 * domains. In the newly idle case, we will allow all the cpu's
 	 * to do the newly idle load balance.
 	 */
-	if (idle != CPU_NEWLY_IDLE && local_group) {
-		if (balance_cpu != this_cpu) {
-			*balance = 0;
-			return;
-		}
-		update_group_power(sd, this_cpu);
+	if (local_group) {
+		if (idle != CPU_NEWLY_IDLE) {
+			if (balance_cpu != this_cpu) {
+				*balance = 0;
+				return;
+			}
+			update_group_power(sd, this_cpu);
+		} else if (time_after_eq(jiffies, group->sgp->next_update))
+			update_group_power(sd, this_cpu);
 	}
 
 	/* Adjust by relative CPU power of the group */
@@ -3867,8 +3877,6 @@ void select_nohz_load_balancer(int stop_
 
 static DEFINE_SPINLOCK(balancing);
 
-static unsigned long __read_mostly max_load_balance_interval = HZ/10;
-
 /*
  * Scale the max load_balance interval with the number of CPUs in the system.
  * This trades load-balance latency on larger machines for less cross talk.
diff -urNp Kernel/kernel/sched_features.h HelloWorld-Renew-v1.0-n7000-jb/kernel/sched_features.h
--- Kernel/kernel/sched_features.h	2013-02-20 13:36:56.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/kernel/sched_features.h	2013-04-29 16:41:35.166587461 +0200
@@ -47,7 +47,7 @@ SCHED_FEAT(CACHE_HOT_BUDDY, 1)
 /*
  * Use arch dependent cpu power functions
  */
-SCHED_FEAT(ARCH_POWER, 0)
+SCHED_FEAT(ARCH_POWER, 1)
 
 SCHED_FEAT(HRTICK, 0)
 SCHED_FEAT(DOUBLE_TICK, 0)
diff -urNp Kernel/lib/Kconfig.debug HelloWorld-Renew-v1.0-n7000-jb/lib/Kconfig.debug
--- Kernel/lib/Kconfig.debug	2013-02-20 13:36:57.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/lib/Kconfig.debug	2013-04-29 16:41:35.166587461 +0200
@@ -296,7 +296,8 @@ config BOOTPARAM_HUNG_TASK_PANIC_VALUE
 
 config SCHED_DEBUG
 	bool "Collect scheduler debugging info"
-	depends on DEBUG_KERNEL && PROC_FS
+	#depends on DEBUG_KERNEL && PROC_FS
+	depends on PROC_FS
 	default y
 	help
 	  If you say Y here, the /proc/sched_debug file will be provided
diff -urNp Kernel/Makefile HelloWorld-Renew-v1.0-n7000-jb/Makefile
--- Kernel/Makefile	2013-02-21 05:56:27.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/Makefile	2013-05-02 08:50:50.929587239 +0200
@@ -1,7 +1,7 @@
 VERSION = 3
 PATCHLEVEL = 0
 SUBLEVEL = 31
-EXTRAVERSION =
+EXTRAVERSION =-1103517
 NAME = Sneaky Weasel
 
 # *DOCUMENTATION*
@@ -193,7 +193,7 @@ SUBARCH := $(shell uname -m | sed -e s/i
 # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
 export KBUILD_BUILDHOST := $(SUBARCH)
 ARCH		?= arm
-CROSS_COMPILE	= /opt/toolchains/arm-eabi-4.4.3/bin/arm-eabi-
+CROSS_COMPILE	?= /home/kernel/arm-2011.03/bin/arm-none-linux-gnueabi-
 
 # Architecture as present in compile.h
 UTS_MACHINE 	:= $(ARCH)
@@ -330,9 +330,14 @@ include $(srctree)/scripts/Kbuild.includ
 
 AS		= $(CROSS_COMPILE)as
 LD		= $(CROSS_COMPILE)ld
+LDFINAL	= $(LD)
 CC		= $(CROSS_COMPILE)gcc
 CPP		= $(CC) -E
+ifdef CONFIG_LTO_SLIM
+AR		= $(CROSS_COMPILE)gcc-ar
+else
 AR		= $(CROSS_COMPILE)ar
+endif
 NM		= $(CROSS_COMPILE)nm
 STRIP		= $(CROSS_COMPILE)strip
 OBJCOPY		= $(CROSS_COMPILE)objcopy
@@ -368,12 +373,16 @@ KBUILD_CFLAGS   := -Wall -Wundef -Wstric
 		   -fno-strict-aliasing -fno-common \
 		   -Werror-implicit-function-declaration \
 		   -Wno-format-security \
-		   -fno-delete-null-pointer-checks
+		   -fno-delete-null-pointer-checks \
+	-march=armv7-a -mfloat-abi=softfp -mfpu=neon -mtune=cortex-a9 -fno-pic \
+	--sysroot=/home/ali/Downloads/android-ndk-r8e/platforms/android-14/arch-arm \
+	-pipe
+
 KBUILD_AFLAGS_KERNEL :=
 KBUILD_CFLAGS_KERNEL :=
 KBUILD_AFLAGS   := -D__ASSEMBLY__
 KBUILD_AFLAGS_MODULE  := -DMODULE
-KBUILD_CFLAGS_MODULE  := -DMODULE
+KBUILD_CFLAGS_MODULE  := -DMODULE -fno-lto
 KBUILD_LDFLAGS_MODULE := -T $(srctree)/scripts/module-common.lds
 
 # Read KERNELRELEASE from include/config/kernel.release (if it exists)
@@ -382,7 +391,7 @@ KERNELVERSION = $(VERSION)$(if $(PATCHLE
 
 export VERSION PATCHLEVEL SUBLEVEL KERNELRELEASE KERNELVERSION
 export ARCH SRCARCH CONFIG_SHELL HOSTCC HOSTCFLAGS CROSS_COMPILE AS LD CC
-export CPP AR NM STRIP OBJCOPY OBJDUMP
+export CPP AR NM STRIP OBJCOPY OBJDUMP LDFINAL
 export MAKE AWK GENKSYMS INSTALLKERNEL PERL UTS_MACHINE
 export HOSTCXX HOSTCXXFLAGS LDFLAGS_MODULE CHECK CHECKFLAGS
 
@@ -648,6 +657,8 @@ ifeq ($(shell $(CONFIG_SHELL) $(srctree)
 	KBUILD_CFLAGS += -DCC_HAVE_ASM_GOTO
 endif
 
+include ${srctree}/scripts/Makefile.lto
+
 # Add user supplied CPPFLAGS, AFLAGS and CFLAGS as the last assignments
 # But warn user when we do so
 warn-assign = \
@@ -770,8 +781,8 @@ export KBUILD_VMLINUX_OBJS := $(vmlinux-
 
 # Rule to link vmlinux - also used during CONFIG_KALLSYMS
 # May be overridden by arch/$(ARCH)/Makefile
-quiet_cmd_vmlinux__ ?= LD      $@
-      cmd_vmlinux__ ?= $(LD) $(LDFLAGS) $(LDFLAGS_vmlinux) -o $@ \
+quiet_cmd_vmlinux__ ?= LDFINAL      $@
+      cmd_vmlinux__ ?= $(LDFINAL) $(LDFLAGS) $(LDFLAGS_vmlinux) -o $@ \
       -T $(vmlinux-lds) $(vmlinux-init)                          \
       --start-group $(vmlinux-main) --end-group                  \
       $(filter-out $(vmlinux-lds) $(vmlinux-init) $(vmlinux-main) vmlinux.o FORCE ,$^)
diff -urNp Kernel/mm/slub.c HelloWorld-Renew-v1.0-n7000-jb/mm/slub.c
--- Kernel/mm/slub.c	2013-02-20 13:36:58.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/mm/slub.c	2013-05-02 00:01:03.499405985 +0200
@@ -3459,9 +3459,9 @@ struct kmem_cache *kmem_cache_create(con
 			}
 			return s;
 		}
-		kfree(n);
 		kfree(s);
 	}
+	kfree(n);
 err:
 	up_write(&slub_lock);
 
Binary files Kernel/scripts/basic/fixdep and HelloWorld-Renew-v1.0-n7000-jb/scripts/basic/fixdep differ
Binary files Kernel/scripts/conmakehash and HelloWorld-Renew-v1.0-n7000-jb/scripts/conmakehash differ
Binary files Kernel/scripts/genksyms/genksyms and HelloWorld-Renew-v1.0-n7000-jb/scripts/genksyms/genksyms differ
diff -urNp Kernel/scripts/genksyms/keywords.c HelloWorld-Renew-v1.0-n7000-jb/scripts/genksyms/keywords.c
--- Kernel/scripts/genksyms/keywords.c	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/scripts/genksyms/keywords.c	2013-04-30 03:22:41.510695909 +0200
@@ -0,0 +1,220 @@
+/* ANSI-C code produced by gperf version 3.0.4 */
+/* Command-line: gperf -L ANSI-C -a -C -E -g -H is_reserved_hash -k '1,3,$' -N is_reserved_word -p -t scripts/genksyms/keywords.gperf  */
+
+#if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
+      && ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) \
+      && (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) \
+      && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \
+      && ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) \
+      && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) \
+      && ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) \
+      && ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) \
+      && ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) \
+      && ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) \
+      && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) \
+      && ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) \
+      && ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) \
+      && ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) \
+      && ('Z' == 90) && ('[' == 91) && ('\\' == 92) && (']' == 93) \
+      && ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) \
+      && ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) \
+      && ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) \
+      && ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) \
+      && ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) \
+      && ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) \
+      && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \
+      && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))
+/* The character set is not based on ISO-646.  */
+#error "gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>."
+#endif
+
+#line 1 "scripts/genksyms/keywords.gperf"
+
+struct resword;
+static const struct resword *is_reserved_word(register const char *str, register unsigned int len);
+#line 5 "scripts/genksyms/keywords.gperf"
+struct resword { const char *name; int token; };
+/* maximum key range = 64, duplicates = 0 */
+
+#ifdef __GNUC__
+__inline
+#else
+#ifdef __cplusplus
+inline
+#endif
+#endif
+static unsigned int
+is_reserved_hash (register const char *str, register unsigned int len)
+{
+  static const unsigned char asso_values[] =
+    {
+      67, 67, 67, 67, 67, 67, 67, 67, 67, 67,
+      67, 67, 67, 67, 67, 67, 67, 67, 67, 67,
+      67, 67, 67, 67, 67, 67, 67, 67, 67, 67,
+      67, 67, 67, 67, 67, 67, 67, 67, 67, 67,
+      67, 67, 67, 67, 67, 67, 67, 67, 67, 67,
+      67, 67, 67, 67, 67, 67, 67, 67, 67, 67,
+      67, 67, 67, 67, 67, 67, 67, 67, 67,  0,
+      67, 67, 67, 67, 67, 67, 15, 67, 67, 67,
+       0, 67, 67, 67, 67, 67, 67, 67, 67, 67,
+      67, 67, 67, 67, 67,  0, 67,  0, 67,  5,
+      25, 20, 15, 30, 67, 15, 67, 67, 10,  0,
+      10, 40, 20, 67, 10,  5,  0, 10, 15, 67,
+      67, 67, 67, 67, 67, 67, 67, 67, 67, 67,
+      67, 67, 67, 67, 67, 67, 67, 67, 67, 67,
+      67, 67, 67, 67, 67, 67, 67, 67, 67, 67,
+      67, 67, 67, 67, 67, 67, 67, 67, 67, 67,
+      67, 67, 67, 67, 67, 67, 67, 67, 67, 67,
+      67, 67, 67, 67, 67, 67, 67, 67, 67, 67,
+      67, 67, 67, 67, 67, 67, 67, 67, 67, 67,
+      67, 67, 67, 67, 67, 67, 67, 67, 67, 67,
+      67, 67, 67, 67, 67, 67, 67, 67, 67, 67,
+      67, 67, 67, 67, 67, 67, 67, 67, 67, 67,
+      67, 67, 67, 67, 67, 67, 67, 67, 67, 67,
+      67, 67, 67, 67, 67, 67, 67, 67, 67, 67,
+      67, 67, 67, 67, 67, 67, 67, 67, 67, 67,
+      67, 67, 67, 67, 67, 67
+    };
+  return len + asso_values[(unsigned char)str[2]] + asso_values[(unsigned char)str[0]] + asso_values[(unsigned char)str[len - 1]];
+}
+
+#ifdef __GNUC__
+__inline
+#if defined __GNUC_STDC_INLINE__ || defined __GNUC_GNU_INLINE__
+__attribute__ ((__gnu_inline__))
+#endif
+#endif
+const struct resword *
+is_reserved_word (register const char *str, register unsigned int len)
+{
+  enum
+    {
+      TOTAL_KEYWORDS = 45,
+      MIN_WORD_LENGTH = 3,
+      MAX_WORD_LENGTH = 24,
+      MIN_HASH_VALUE = 3,
+      MAX_HASH_VALUE = 66
+    };
+
+  static const struct resword wordlist[] =
+    {
+      {""}, {""}, {""},
+#line 30 "scripts/genksyms/keywords.gperf"
+      {"asm", ASM_KEYW},
+      {""},
+#line 12 "scripts/genksyms/keywords.gperf"
+      {"__asm", ASM_KEYW},
+      {""},
+#line 13 "scripts/genksyms/keywords.gperf"
+      {"__asm__", ASM_KEYW},
+      {""}, {""},
+#line 56 "scripts/genksyms/keywords.gperf"
+      {"__typeof__", TYPEOF_KEYW},
+      {""},
+#line 16 "scripts/genksyms/keywords.gperf"
+      {"__const", CONST_KEYW},
+#line 15 "scripts/genksyms/keywords.gperf"
+      {"__attribute__", ATTRIBUTE_KEYW},
+#line 17 "scripts/genksyms/keywords.gperf"
+      {"__const__", CONST_KEYW},
+#line 22 "scripts/genksyms/keywords.gperf"
+      {"__signed__", SIGNED_KEYW},
+#line 48 "scripts/genksyms/keywords.gperf"
+      {"static", STATIC_KEYW},
+      {""},
+#line 43 "scripts/genksyms/keywords.gperf"
+      {"int", INT_KEYW},
+#line 36 "scripts/genksyms/keywords.gperf"
+      {"char", CHAR_KEYW},
+#line 37 "scripts/genksyms/keywords.gperf"
+      {"const", CONST_KEYW},
+#line 49 "scripts/genksyms/keywords.gperf"
+      {"struct", STRUCT_KEYW},
+#line 28 "scripts/genksyms/keywords.gperf"
+      {"__restrict__", RESTRICT_KEYW},
+#line 29 "scripts/genksyms/keywords.gperf"
+      {"restrict", RESTRICT_KEYW},
+#line 9 "scripts/genksyms/keywords.gperf"
+      {"EXPORT_SYMBOL_GPL_FUTURE", EXPORT_SYMBOL_KEYW},
+#line 20 "scripts/genksyms/keywords.gperf"
+      {"__inline__", INLINE_KEYW},
+      {""},
+#line 24 "scripts/genksyms/keywords.gperf"
+      {"__volatile__", VOLATILE_KEYW},
+#line 7 "scripts/genksyms/keywords.gperf"
+      {"EXPORT_SYMBOL", EXPORT_SYMBOL_KEYW},
+#line 27 "scripts/genksyms/keywords.gperf"
+      {"_restrict", RESTRICT_KEYW},
+      {""},
+#line 14 "scripts/genksyms/keywords.gperf"
+      {"__attribute", ATTRIBUTE_KEYW},
+#line 8 "scripts/genksyms/keywords.gperf"
+      {"EXPORT_SYMBOL_GPL", EXPORT_SYMBOL_KEYW},
+#line 18 "scripts/genksyms/keywords.gperf"
+      {"__extension__", EXTENSION_KEYW},
+#line 39 "scripts/genksyms/keywords.gperf"
+      {"enum", ENUM_KEYW},
+#line 10 "scripts/genksyms/keywords.gperf"
+      {"EXPORT_UNUSED_SYMBOL", EXPORT_SYMBOL_KEYW},
+#line 40 "scripts/genksyms/keywords.gperf"
+      {"extern", EXTERN_KEYW},
+      {""},
+#line 21 "scripts/genksyms/keywords.gperf"
+      {"__signed", SIGNED_KEYW},
+#line 11 "scripts/genksyms/keywords.gperf"
+      {"EXPORT_UNUSED_SYMBOL_GPL", EXPORT_SYMBOL_KEYW},
+#line 51 "scripts/genksyms/keywords.gperf"
+      {"union", UNION_KEYW},
+#line 55 "scripts/genksyms/keywords.gperf"
+      {"typeof", TYPEOF_KEYW},
+#line 50 "scripts/genksyms/keywords.gperf"
+      {"typedef", TYPEDEF_KEYW},
+#line 19 "scripts/genksyms/keywords.gperf"
+      {"__inline", INLINE_KEYW},
+#line 35 "scripts/genksyms/keywords.gperf"
+      {"auto", AUTO_KEYW},
+#line 23 "scripts/genksyms/keywords.gperf"
+      {"__volatile", VOLATILE_KEYW},
+      {""}, {""},
+#line 52 "scripts/genksyms/keywords.gperf"
+      {"unsigned", UNSIGNED_KEYW},
+      {""},
+#line 46 "scripts/genksyms/keywords.gperf"
+      {"short", SHORT_KEYW},
+#line 42 "scripts/genksyms/keywords.gperf"
+      {"inline", INLINE_KEYW},
+      {""},
+#line 54 "scripts/genksyms/keywords.gperf"
+      {"volatile", VOLATILE_KEYW},
+#line 44 "scripts/genksyms/keywords.gperf"
+      {"long", LONG_KEYW},
+#line 26 "scripts/genksyms/keywords.gperf"
+      {"_Bool", BOOL_KEYW},
+      {""}, {""},
+#line 45 "scripts/genksyms/keywords.gperf"
+      {"register", REGISTER_KEYW},
+#line 53 "scripts/genksyms/keywords.gperf"
+      {"void", VOID_KEYW},
+#line 41 "scripts/genksyms/keywords.gperf"
+      {"float", FLOAT_KEYW},
+#line 38 "scripts/genksyms/keywords.gperf"
+      {"double", DOUBLE_KEYW},
+      {""}, {""}, {""}, {""},
+#line 47 "scripts/genksyms/keywords.gperf"
+      {"signed", SIGNED_KEYW}
+    };
+
+  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
+    {
+      register int key = is_reserved_hash (str, len);
+
+      if (key <= MAX_HASH_VALUE && key >= 0)
+        {
+          register const char *s = wordlist[key].name;
+
+          if (*str == *s && !strcmp (str + 1, s + 1))
+            return &wordlist[key];
+        }
+    }
+  return 0;
+}
diff -urNp Kernel/scripts/genksyms/lex.c HelloWorld-Renew-v1.0-n7000-jb/scripts/genksyms/lex.c
--- Kernel/scripts/genksyms/lex.c	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/scripts/genksyms/lex.c	2013-04-30 03:22:41.274695908 +0200
@@ -0,0 +1,2582 @@
+#line 2 "scripts/genksyms/lex.c"
+
+#line 4 "scripts/genksyms/lex.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+/* %not-for-header */
+
+/* %if-c-only */
+/* %if-not-reentrant */
+
+/* %endif */
+/* %endif */
+/* %ok-for-header */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* %if-c++-only */
+/* %endif */
+
+/* %if-c-only */
+    
+/* %endif */
+
+/* %if-c-only */
+
+/* %endif */
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+/* %if-c-only */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+/* %endif */
+
+/* %if-tables-serialization */
+/* %endif */
+/* end standard C headers. */
+
+/* %if-c-or-c++ */
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+#endif /* ! C99 */
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! FLEXINT_H */
+
+/* %endif */
+
+/* %if-c++-only */
+/* %endif */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* %not-for-header */
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+/* %ok-for-header */
+
+/* %not-for-header */
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+/* %ok-for-header */
+
+/* %if-reentrant */
+/* %endif */
+
+/* %if-not-reentrant */
+
+/* %endif */
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart(yyin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#define YY_BUF_SIZE 16384
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+/* %if-not-reentrant */
+extern int yyleng;
+/* %endif */
+
+/* %if-c-only */
+/* %if-not-reentrant */
+extern FILE *yyin, *yyout;
+/* %endif */
+/* %endif */
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+/* %if-c-only */
+	FILE *yy_input_file;
+/* %endif */
+
+/* %if-c++-only */
+/* %endif */
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* %if-c-only Standard (non-C++) definition */
+/* %not-for-header */
+
+/* %if-not-reentrant */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+/* %endif */
+/* %ok-for-header */
+
+/* %endif */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* %if-c-only Standard (non-C++) definition */
+
+/* %if-not-reentrant */
+/* %not-for-header */
+
+/* yy_hold_char holds the character lost when yytext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow yywrap()'s to do buffer switches
+ * instead of setting up a fresh yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+/* %ok-for-header */
+
+/* %endif */
+
+void yyrestart (FILE *input_file  );
+void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
+void yy_delete_buffer (YY_BUFFER_STATE b  );
+void yy_flush_buffer (YY_BUFFER_STATE b  );
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void yypop_buffer_state (void );
+
+static void yyensure_buffer_stack (void );
+static void yy_load_buffer_state (void );
+static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,int len  );
+
+/* %endif */
+
+void *yyalloc (yy_size_t  );
+void *yyrealloc (void *,yy_size_t  );
+void yyfree (void *  );
+
+#define yy_new_buffer yy_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* %% [1.0] yytext/yyin/yyout/yy_state_type/yylineno etc. def's & init go here */
+/* Begin user sect3 */
+
+#define yywrap(n) 1
+#define YY_SKIP_YYWRAP
+
+#define FLEX_DEBUG
+
+typedef unsigned char YY_CHAR;
+
+FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int yylineno;
+
+int yylineno = 1;
+
+extern char *yytext;
+#define yytext_ptr yytext
+
+/* %if-c-only Standard (non-C++) definition */
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* %endif */
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+/* %% [2.0] code to fiddle yytext and yyleng for yymore() goes here \ */\
+	yyleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+/* %% [3.0] code to copy yytext_ptr to yytext[] goes here, if %array \ */\
+	(yy_c_buf_p) = yy_cp;
+
+/* %% [4.0] data tables for the DFA and the user's section 1 definitions go here */
+#define YY_NUM_RULES 13
+#define YY_END_OF_BUFFER 14
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[73] =
+    {   0,
+        0,    0,   14,   12,    4,    3,   12,    7,   12,   12,
+       12,   12,   12,    9,    9,   12,   12,    7,   12,   12,
+        4,    0,    5,    0,    7,    8,    0,    6,    0,    0,
+       10,   10,    9,    0,    0,    9,    9,    0,    9,    0,
+        0,    0,    0,    2,    0,    0,   11,    0,   10,    0,
+       10,    9,    9,    0,    0,    0,   10,   10,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        1,    0
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        4,    4,    4,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    1,    5,    6,    7,    8,    9,   10,    1,
+        1,    8,   11,    1,   12,   13,    8,   14,   15,   15,
+       15,   15,   15,   15,   15,   16,   16,    1,    1,   17,
+       18,   19,    1,    1,   20,   20,   20,   20,   21,   22,
+        7,    7,    7,    7,    7,   23,    7,    7,    7,    7,
+        7,    7,    7,    7,   24,    7,    7,   25,    7,    7,
+        1,   26,    1,    8,    7,    1,   20,   20,   20,   20,
+
+       21,   22,    7,    7,    7,    7,    7,   27,    7,    7,
+        7,    7,    7,    7,    7,    7,   24,    7,    7,   25,
+        7,    7,    1,   28,    1,    8,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int32_t yy_meta[29] =
+    {   0,
+        1,    1,    2,    1,    1,    1,    3,    1,    1,    1,
+        4,    4,    5,    6,    6,    6,    1,    1,    1,    7,
+        8,    7,    3,    3,    3,    1,    3,    1
+    } ;
+
+static yyconst flex_int16_t yy_base[85] =
+    {   0,
+        0,  145,  150,  266,   27,  266,   25,    0,  131,   23,
+       23,   16,   23,   39,   31,   25,   39,   60,   22,   65,
+       57,   43,  266,    0,    0,  266,   61,  266,    0,  128,
+       74,    0,  113,   59,   62,  113,   52,    0,    0,   72,
+       66,  110,  100,  266,   73,   74,  266,   70,  266,   90,
+      103,  266,   84,  129,  108,  113,  143,  266,  107,   66,
+      118,  137,  168,  120,   80,   91,  145,  143,   83,   41,
+      266,  266,  190,  196,  204,  212,  220,  228,  232,  237,
+      238,  243,  249,  257
+    } ;
+
+static yyconst flex_int16_t yy_def[85] =
+    {   0,
+       72,    1,   72,   72,   72,   72,   73,   74,   72,   72,
+       75,   72,   72,   72,   14,   72,   72,   74,   72,   76,
+       72,   73,   72,   77,   74,   72,   75,   72,   78,   72,
+       72,   31,   14,   79,   80,   72,   72,   81,   15,   73,
+       75,   76,   76,   72,   73,   75,   72,   82,   72,   72,
+       72,   72,   81,   76,   54,   72,   72,   72,   76,   54,
+       76,   76,   76,   54,   83,   76,   63,   83,   84,   84,
+       72,    0,   72,   72,   72,   72,   72,   72,   72,   72,
+       72,   72,   72,   72
+    } ;
+
+static yyconst flex_int16_t yy_nxt[295] =
+    {   0,
+        4,    5,    6,    5,    7,    4,    8,    9,   10,   11,
+        9,   12,   13,   14,   15,   15,   16,    9,   17,    8,
+        8,    8,   18,    8,    8,    4,    8,   19,   21,   23,
+       21,   26,   28,   26,   26,   30,   31,   31,   31,   26,
+       26,   26,   26,   71,   39,   39,   39,   23,   29,   26,
+       24,   32,   33,   33,   34,   72,   26,   26,   21,   35,
+       21,   36,   37,   38,   40,   36,   43,   44,   24,   41,
+       28,   32,   50,   50,   52,   28,   23,   23,   52,   35,
+       56,   56,   44,   28,   42,   71,   29,   31,   31,   31,
+       42,   29,   59,   44,   48,   49,   49,   24,   24,   29,
+
+       49,   43,   44,   51,   51,   51,   36,   37,   59,   44,
+       36,   65,   44,   54,   55,   55,   51,   51,   51,   59,
+       44,   64,   64,   64,   58,   58,   57,   57,   57,   58,
+       59,   44,   42,   64,   64,   64,   52,   72,   59,   44,
+       47,   66,   60,   60,   42,   44,   59,   69,   26,   72,
+       20,   61,   62,   63,   72,   61,   57,   57,   57,   66,
+       72,   72,   72,   66,   49,   49,   72,   61,   62,   49,
+       44,   61,   72,   72,   72,   72,   72,   72,   72,   72,
+       72,   67,   67,   67,   72,   72,   72,   67,   67,   67,
+       22,   22,   22,   22,   22,   22,   22,   22,   25,   72,
+
+       72,   25,   25,   25,   27,   27,   27,   27,   27,   27,
+       27,   27,   42,   42,   42,   42,   42,   42,   42,   42,
+       45,   72,   45,   45,   45,   45,   45,   45,   46,   72,
+       46,   46,   46,   46,   46,   46,   34,   34,   72,   34,
+       51,   72,   51,   53,   53,   53,   57,   72,   57,   68,
+       68,   68,   68,   68,   68,   68,   68,   70,   70,   70,
+       70,   70,   70,   70,   70,    3,   72,   72,   72,   72,
+       72,   72,   72,   72,   72,   72,   72,   72,   72,   72,
+       72,   72,   72,   72,   72,   72,   72,   72,   72,   72,
+       72,   72,   72,   72
+
+    } ;
+
+static yyconst flex_int16_t yy_chk[295] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    5,    7,
+        5,   10,   11,   12,   12,   13,   13,   13,   13,   19,
+       10,   16,   16,   70,   15,   15,   15,   22,   11,   19,
+        7,   14,   14,   14,   14,   15,   17,   17,   21,   14,
+       21,   14,   14,   14,   18,   14,   20,   20,   22,   18,
+       27,   34,   35,   35,   37,   41,   40,   45,   37,   34,
+       48,   48,   65,   46,   65,   69,   27,   31,   31,   31,
+       60,   41,   66,   66,   31,   31,   31,   40,   45,   46,
+
+       31,   43,   43,   50,   50,   50,   53,   53,   59,   59,
+       53,   59,   42,   43,   43,   43,   51,   51,   51,   61,
+       61,   55,   55,   55,   51,   51,   56,   56,   56,   51,
+       54,   54,   55,   64,   64,   64,   36,   33,   62,   62,
+       30,   61,   54,   54,   64,   68,   67,   68,    9,    3,
+        2,   54,   54,   54,    0,   54,   57,   57,   57,   62,
+        0,    0,    0,   62,   57,   57,    0,   67,   67,   57,
+       63,   67,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,   63,   63,   63,    0,    0,    0,   63,   63,   63,
+       73,   73,   73,   73,   73,   73,   73,   73,   74,    0,
+
+        0,   74,   74,   74,   75,   75,   75,   75,   75,   75,
+       75,   75,   76,   76,   76,   76,   76,   76,   76,   76,
+       77,    0,   77,   77,   77,   77,   77,   77,   78,    0,
+       78,   78,   78,   78,   78,   78,   79,   79,    0,   79,
+       80,    0,   80,   81,   81,   81,   82,    0,   82,   83,
+       83,   83,   83,   83,   83,   83,   83,   84,   84,   84,
+       84,   84,   84,   84,   84,   72,   72,   72,   72,   72,
+       72,   72,   72,   72,   72,   72,   72,   72,   72,   72,
+       72,   72,   72,   72,   72,   72,   72,   72,   72,   72,
+       72,   72,   72,   72
+
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+extern int yy_flex_debug;
+int yy_flex_debug = 1;
+
+static yyconst flex_int16_t yy_rule_linenum[13] =
+    {   0,
+       67,   68,   69,   72,   75,   76,   77,   83,   84,   85,
+       87,   90
+    } ;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *yytext;
+#line 1 "scripts/genksyms/lex.l"
+/* Lexical analysis for genksyms.
+   Copyright 1996, 1997 Linux International.
+
+   New implementation contributed by Richard Henderson <rth@tamu.edu>
+   Based on original work by Bjorn Ekwall <bj0rn@blox.se>
+
+   Taken from Linux modutils 2.4.22.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by the
+   Free Software Foundation; either version 2 of the License, or (at your
+   option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+#line 25 "scripts/genksyms/lex.l"
+
+#include <limits.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+
+#include "genksyms.h"
+#include "parse.h"
+
+/* We've got a two-level lexer here.  We let flex do basic tokenization
+   and then we categorize those basic tokens in the second stage.  */
+#define YY_DECL		static int yylex1(void)
+
+/* We don't do multiple input files.  */
+#define YY_NO_INPUT 1
+#line 668 "scripts/genksyms/lex.c"
+
+#define INITIAL 0
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+/* %if-c-only */
+#include <unistd.h>
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+/* %if-c-only Reentrant structure and macros (non-C++). */
+/* %if-reentrant */
+/* %if-c-only */
+
+static int yy_init_globals (void );
+
+/* %endif */
+/* %if-reentrant */
+/* %endif */
+/* %endif End reentrant structures and macros. */
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int yylex_destroy (void );
+
+int yyget_debug (void );
+
+void yyset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE yyget_extra (void );
+
+void yyset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *yyget_in (void );
+
+void yyset_in  (FILE * in_str  );
+
+FILE *yyget_out (void );
+
+void yyset_out  (FILE * out_str  );
+
+int yyget_leng (void );
+
+char *yyget_text (void );
+
+int yyget_lineno (void );
+
+void yyset_lineno (int line_number  );
+
+/* %if-bison-bridge */
+/* %endif */
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap (void );
+#else
+extern int yywrap (void );
+#endif
+#endif
+
+/* %not-for-header */
+
+    static void yyunput (int c,char *buf_ptr  );
+    
+/* %ok-for-header */
+
+/* %endif */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+/* %if-c-only Standard (non-C++) definition */
+/* %not-for-header */
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+/* %ok-for-header */
+
+/* %endif */
+#endif
+
+/* %if-c-only */
+
+/* %endif */
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* %if-c-only Standard (non-C++) definition */
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO fwrite( yytext, yyleng, 1, yyout )
+/* %endif */
+/* %if-c++-only C++ definition */
+/* %endif */
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+/* %% [5.0] fread()/read() definition of YY_INPUT goes here unless we're doing C++ \ */\
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		int n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( yyin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(yyin); \
+			} \
+		}\
+\
+/* %if-c++-only C++ definition \ */\
+/* %endif */
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+/* %if-c-only */
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+#endif
+
+/* %if-tables-serialization structures and prototypes */
+/* %not-for-header */
+
+/* %ok-for-header */
+
+/* %not-for-header */
+
+/* %tables-yydmap generated elements */
+/* %endif */
+/* end tables serialization structures and prototypes */
+
+/* %ok-for-header */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+/* %if-c-only Standard (non-C++) definition */
+
+extern int yylex (void);
+
+#define YY_DECL int yylex (void)
+/* %endif */
+/* %if-c++-only C++ definition */
+/* %endif */
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+/* %% [6.0] YY_RULE_SETUP definition goes here */
+#define YY_RULE_SETUP \
+	if ( yyleng > 0 ) \
+		YY_CURRENT_BUFFER_LVALUE->yy_at_bol = \
+				(yytext[yyleng - 1] == '\n'); \
+	YY_USER_ACTION
+
+/* %not-for-header */
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+/* %% [7.0] user's declarations go here */
+#line 63 "scripts/genksyms/lex.l"
+
+
+
+ /* Keep track of our location in the original source files.  */
+#line 918 "scripts/genksyms/lex.c"
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! yyin )
+/* %if-c-only */
+			yyin = stdin;
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+
+		if ( ! yyout )
+/* %if-c-only */
+			yyout = stdout;
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			yyensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				yy_create_buffer(yyin,YY_BUF_SIZE );
+		}
+
+		yy_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+/* %% [8.0] yymore()-related code goes here */
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of yytext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+/* %% [9.0] code to set up and find next match goes here */
+		yy_current_state = (yy_start);
+		yy_current_state += YY_AT_BOL();
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 73 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_base[yy_current_state] != 266 );
+
+yy_find_action:
+/* %% [10.0] code to find the action number goes here */
+		yy_act = yy_accept[yy_current_state];
+		if ( yy_act == 0 )
+			{ /* have to back up */
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			yy_act = yy_accept[yy_current_state];
+			}
+
+		YY_DO_BEFORE_ACTION;
+
+/* %% [11.0] code for yylineno update goes here */
+
+do_action:	/* This label is used only to access EOF actions. */
+
+/* %% [12.0] debug code goes here */
+		if ( yy_flex_debug )
+			{
+			if ( yy_act == 0 )
+				fprintf( stderr, "--scanner backing up\n" );
+			else if ( yy_act < 13 )
+				fprintf( stderr, "--accepting rule at line %ld (\"%s\")\n",
+				         (long)yy_rule_linenum[yy_act], yytext );
+			else if ( yy_act == 13 )
+				fprintf( stderr, "--accepting default rule (\"%s\")\n",
+				         yytext );
+			else if ( yy_act == 14 )
+				fprintf( stderr, "--(end of buffer or a NUL)\n" );
+			else
+				fprintf( stderr, "--EOF (start condition %d)\n", YY_START );
+			}
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+/* %% [13.0] actions go here */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			goto yy_find_action;
+
+case 1:
+/* rule 1 can match eol */
+YY_RULE_SETUP
+#line 67 "scripts/genksyms/lex.l"
+return FILENAME;
+	YY_BREAK
+case 2:
+/* rule 2 can match eol */
+YY_RULE_SETUP
+#line 68 "scripts/genksyms/lex.l"
+cur_line++;
+	YY_BREAK
+case 3:
+/* rule 3 can match eol */
+YY_RULE_SETUP
+#line 69 "scripts/genksyms/lex.l"
+cur_line++;
+	YY_BREAK
+/* Ignore all other whitespace.  */
+case 4:
+YY_RULE_SETUP
+#line 72 "scripts/genksyms/lex.l"
+;
+	YY_BREAK
+case 5:
+/* rule 5 can match eol */
+YY_RULE_SETUP
+#line 75 "scripts/genksyms/lex.l"
+return STRING;
+	YY_BREAK
+case 6:
+/* rule 6 can match eol */
+YY_RULE_SETUP
+#line 76 "scripts/genksyms/lex.l"
+return CHAR;
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 77 "scripts/genksyms/lex.l"
+return IDENT;
+	YY_BREAK
+/* The Pedant requires that the other C multi-character tokens be
+    recognized as tokens.  We don't actually use them since we don't
+    parse expressions, but we do want whitespace to be arranged
+    around them properly.  */
+case 8:
+YY_RULE_SETUP
+#line 83 "scripts/genksyms/lex.l"
+return OTHER;
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 84 "scripts/genksyms/lex.l"
+return INT;
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 85 "scripts/genksyms/lex.l"
+return REAL;
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 87 "scripts/genksyms/lex.l"
+return DOTS;
+	YY_BREAK
+/* All other tokens are single characters.  */
+case 12:
+YY_RULE_SETUP
+#line 90 "scripts/genksyms/lex.l"
+return yytext[0];
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 93 "scripts/genksyms/lex.l"
+ECHO;
+	YY_BREAK
+#line 1109 "scripts/genksyms/lex.c"
+case YY_STATE_EOF(INITIAL):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+/* %% [14.0] code to do back-up for compressed tables and set up yy_cp goes here */
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( yywrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of yylex */
+/* %ok-for-header */
+
+/* %if-c++-only */
+/* %not-for-header */
+
+/* %ok-for-header */
+
+/* %endif */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+/* %if-c-only */
+static int yy_get_next_buffer (void)
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart(yyin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+/* %if-c-only */
+/* %not-for-header */
+
+    static yy_state_type yy_get_previous_state (void)
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+/* %% [15.0] code to get the start state into yy_current_state goes here */
+	yy_current_state = (yy_start);
+	yy_current_state += YY_AT_BOL();
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+/* %% [16.0] code to find the next state goes here */
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 73 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+/* %if-c-only */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+	register int yy_is_jam;
+    /* %% [17.0] code to find the next state, and perhaps do backing up, goes here */
+	register char *yy_cp = (yy_c_buf_p);
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 73 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 72);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+/* %if-c-only */
+
+    static void yyunput (int c, register char * yy_bp )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+	register char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
+
+	/* undo effects of setting up yytext */
+	*yy_cp = (yy_hold_char);
+
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = (yy_n_chars) + 2;
+		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
+		register char *source =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
+
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+/* %% [18.0] update yylineno here */
+
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
+/* %if-c-only */
+
+/* %endif */
+
+/* %if-c-only */
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					yyrestart(yyin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve yytext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+/* %% [19.0] update BOL and yylineno */
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\n');
+
+	return c;
+}
+/* %if-c-only */
+#endif	/* ifndef YY_NO_INPUT */
+/* %endif */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+/* %if-c-only */
+    void yyrestart  (FILE * input_file )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        yyensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            yy_create_buffer(yyin,YY_BUF_SIZE );
+	}
+
+	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
+	yy_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+/* %if-c-only */
+    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		yypop_buffer_state();
+	 *		yypush_buffer_state(new_buffer);
+     */
+	yyensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	yy_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/* %if-c-only */
+static void yy_load_buffer_state  (void)
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+/* %if-c-only */
+    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with yy_create_buffer()
+ * 
+ */
+/* %if-c-only */
+    void yy_delete_buffer (YY_BUFFER_STATE  b )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yyfree((void *) b->yy_ch_buf  );
+
+	yyfree((void *) b  );
+}
+
+/* %if-c-only */
+
+#ifndef __cplusplus
+extern int isatty (int );
+#endif /* __cplusplus */
+    
+/* %endif */
+
+/* %if-c++-only */
+/* %endif */
+
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a yyrestart() or at EOF.
+ */
+/* %if-c-only */
+    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+
+{
+	int oerrno = errno;
+    
+	yy_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then yy_init_buffer was _probably_
+     * called from yyrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+/* %if-c-only */
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+/* %if-c-only */
+    void yy_flush_buffer (YY_BUFFER_STATE  b )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		yy_load_buffer_state( );
+}
+
+/* %if-c-or-c++ */
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+/* %if-c-only */
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+    	if (new_buffer == NULL)
+		return;
+
+	yyensure_buffer_stack();
+
+	/* This block is copied from yy_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from yy_switch_to_buffer. */
+	yy_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+/* %endif */
+
+/* %if-c-or-c++ */
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+/* %if-c-only */
+void yypop_buffer_state (void)
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	yy_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		yy_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+/* %endif */
+
+/* %if-c-or-c++ */
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+/* %if-c-only */
+static void yyensure_buffer_stack (void)
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+/* %endif */
+
+/* %if-c-only */
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer(b  );
+
+	return b;
+}
+/* %endif */
+
+/* %if-c-only */
+/** Setup the input buffer state to scan a string. The next call to yylex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       yy_scan_bytes() instead.
+ */
+YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
+{
+    
+	return yy_scan_bytes(yystr,strlen(yystr) );
+}
+/* %endif */
+
+/* %if-c-only */
+/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
+ * scan from a @e copy of @a bytes.
+ * @param bytes the byte buffer to scan
+ * @param len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) yyalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+/* %endif */
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+/* %if-c-only */
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+/* %endif */
+/* %if-c++-only */
+/* %endif */
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		yytext[yyleng] = (yy_hold_char); \
+		(yy_c_buf_p) = yytext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		yyleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/* %if-c-only */
+/* %if-reentrant */
+/* %endif */
+
+/** Get the current line number.
+ * 
+ */
+int yyget_lineno  (void)
+{
+        
+    return yylineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *yyget_in  (void)
+{
+        return yyin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *yyget_out  (void)
+{
+        return yyout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int yyget_leng  (void)
+{
+        return yyleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *yyget_text  (void)
+{
+        return yytext;
+}
+
+/* %if-reentrant */
+/* %endif */
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void yyset_lineno (int  line_number )
+{
+    
+    yylineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see yy_switch_to_buffer
+ */
+void yyset_in (FILE *  in_str )
+{
+        yyin = in_str ;
+}
+
+void yyset_out (FILE *  out_str )
+{
+        yyout = out_str ;
+}
+
+int yyget_debug  (void)
+{
+        return yy_flex_debug;
+}
+
+void yyset_debug (int  bdebug )
+{
+        yy_flex_debug = bdebug ;
+}
+
+/* %endif */
+
+/* %if-reentrant */
+/* %if-bison-bridge */
+/* %endif */
+/* %endif if-c-only */
+
+/* %if-c-only */
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from yylex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    yyin = stdin;
+    yyout = stdout;
+#else
+    yyin = (FILE *) 0;
+    yyout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * yylex_init()
+     */
+    return 0;
+}
+/* %endif */
+
+/* %if-c-only SNIP! this currently causes conflicts with the c++ scanner */
+/* yylex_destroy is for both reentrant and non-reentrant scanners. */
+int yylex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		yy_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		yypop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	yyfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * yylex() is called, initialization will occur. */
+    yy_init_globals( );
+
+/* %if-reentrant */
+/* %endif */
+    return 0;
+}
+/* %endif */
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *yyalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *yyrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void yyfree (void * ptr )
+{
+	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
+}
+
+/* %if-tables-serialization definitions */
+/* %define-yytables   The name for this specific scanner's tables. */
+#define YYTABLES_NAME "yytables"
+/* %endif */
+
+/* %ok-for-header */
+
+#line 93 "scripts/genksyms/lex.l"
+
+
+
+/* Bring in the keyword recognizer.  */
+
+#include "keywords.c"
+
+
+/* Macros to append to our phrase collection list.  */
+
+/*
+ * We mark any token, that that equals to a known enumerator, as
+ * SYM_ENUM_CONST. The parser will change this for struct and union tags later,
+ * the only problem is struct and union members:
+ *    enum e { a, b }; struct s { int a, b; }
+ * but in this case, the only effect will be, that the ABI checksums become
+ * more volatile, which is acceptable. Also, such collisions are quite rare,
+ * so far it was only observed in include/linux/telephony.h.
+ */
+#define _APP(T,L)	do {						   \
+			  cur_node = next_node;				   \
+			  next_node = xmalloc(sizeof(*next_node));	   \
+			  next_node->next = cur_node;			   \
+			  cur_node->string = memcpy(xmalloc(L+1), T, L+1); \
+			  cur_node->tag =				   \
+			    find_symbol(cur_node->string, SYM_ENUM_CONST, 1)?\
+			    SYM_ENUM_CONST : SYM_NORMAL ;		   \
+			} while (0)
+
+#define APP		_APP(yytext, yyleng)
+
+
+/* The second stage lexer.  Here we incorporate knowledge of the state
+   of the parser to tailor the tokens that are returned.  */
+
+int
+yylex(void)
+{
+  static enum {
+    ST_NOTSTARTED, ST_NORMAL, ST_ATTRIBUTE, ST_ASM, ST_BRACKET, ST_BRACE,
+    ST_EXPRESSION, ST_TABLE_1, ST_TABLE_2, ST_TABLE_3, ST_TABLE_4,
+    ST_TABLE_5, ST_TABLE_6
+  } lexstate = ST_NOTSTARTED;
+
+  static int suppress_type_lookup, dont_want_brace_phrase;
+  static struct string_list *next_node;
+
+  int token, count = 0;
+  struct string_list *cur_node;
+
+  if (lexstate == ST_NOTSTARTED)
+    {
+      next_node = xmalloc(sizeof(*next_node));
+      next_node->next = NULL;
+      lexstate = ST_NORMAL;
+    }
+
+repeat:
+  token = yylex1();
+
+  if (token == 0)
+    return 0;
+  else if (token == FILENAME)
+    {
+      char *file, *e;
+
+      /* Save the filename and line number for later error messages.  */
+
+      if (cur_filename)
+	free(cur_filename);
+
+      file = strchr(yytext, '\"')+1;
+      e = strchr(file, '\"');
+      *e = '\0';
+      cur_filename = memcpy(xmalloc(e-file+1), file, e-file+1);
+      cur_line = atoi(yytext+2);
+
+      goto repeat;
+    }
+
+  switch (lexstate)
+    {
+    case ST_NORMAL:
+      switch (token)
+	{
+	case IDENT:
+	  APP;
+	  {
+	    const struct resword *r = is_reserved_word(yytext, yyleng);
+	    if (r)
+	      {
+		switch (token = r->token)
+		  {
+		  case ATTRIBUTE_KEYW:
+		    lexstate = ST_ATTRIBUTE;
+		    count = 0;
+		    goto repeat;
+		  case ASM_KEYW:
+		    lexstate = ST_ASM;
+		    count = 0;
+		    goto repeat;
+
+		  case STRUCT_KEYW:
+		  case UNION_KEYW:
+		  case ENUM_KEYW:
+		    dont_want_brace_phrase = 3;
+		    suppress_type_lookup = 2;
+		    goto fini;
+
+		  case EXPORT_SYMBOL_KEYW:
+		      goto fini;
+		  }
+	      }
+	    if (!suppress_type_lookup)
+	      {
+		if (find_symbol(yytext, SYM_TYPEDEF, 1))
+		  token = TYPE;
+	      }
+	  }
+	  break;
+
+	case '[':
+	  APP;
+	  lexstate = ST_BRACKET;
+	  count = 1;
+	  goto repeat;
+
+	case '{':
+	  APP;
+	  if (dont_want_brace_phrase)
+	    break;
+	  lexstate = ST_BRACE;
+	  count = 1;
+	  goto repeat;
+
+	case '=': case ':':
+	  APP;
+	  lexstate = ST_EXPRESSION;
+	  break;
+
+	case DOTS:
+	default:
+	  APP;
+	  break;
+	}
+      break;
+
+    case ST_ATTRIBUTE:
+      APP;
+      switch (token)
+	{
+	case '(':
+	  ++count;
+	  goto repeat;
+	case ')':
+	  if (--count == 0)
+	    {
+	      lexstate = ST_NORMAL;
+	      token = ATTRIBUTE_PHRASE;
+	      break;
+	    }
+	  goto repeat;
+	default:
+	  goto repeat;
+	}
+      break;
+
+    case ST_ASM:
+      APP;
+      switch (token)
+	{
+	case '(':
+	  ++count;
+	  goto repeat;
+	case ')':
+	  if (--count == 0)
+	    {
+	      lexstate = ST_NORMAL;
+	      token = ASM_PHRASE;
+	      break;
+	    }
+	  goto repeat;
+	default:
+	  goto repeat;
+	}
+      break;
+
+    case ST_BRACKET:
+      APP;
+      switch (token)
+	{
+	case '[':
+	  ++count;
+	  goto repeat;
+	case ']':
+	  if (--count == 0)
+	    {
+	      lexstate = ST_NORMAL;
+	      token = BRACKET_PHRASE;
+	      break;
+	    }
+	  goto repeat;
+	default:
+	  goto repeat;
+	}
+      break;
+
+    case ST_BRACE:
+      APP;
+      switch (token)
+	{
+	case '{':
+	  ++count;
+	  goto repeat;
+	case '}':
+	  if (--count == 0)
+	    {
+	      lexstate = ST_NORMAL;
+	      token = BRACE_PHRASE;
+	      break;
+	    }
+	  goto repeat;
+	default:
+	  goto repeat;
+	}
+      break;
+
+    case ST_EXPRESSION:
+      switch (token)
+	{
+	case '(': case '[': case '{':
+	  ++count;
+	  APP;
+	  goto repeat;
+	case '}':
+	  /* is this the last line of an enum declaration? */
+	  if (count == 0)
+	    {
+	      /* Put back the token we just read so's we can find it again
+		 after registering the expression.  */
+	      unput(token);
+
+	      lexstate = ST_NORMAL;
+	      token = EXPRESSION_PHRASE;
+	      break;
+	    }
+	  /* FALLTHRU */
+	case ')': case ']':
+	  --count;
+	  APP;
+	  goto repeat;
+	case ',': case ';':
+	  if (count == 0)
+	    {
+	      /* Put back the token we just read so's we can find it again
+		 after registering the expression.  */
+	      unput(token);
+
+	      lexstate = ST_NORMAL;
+	      token = EXPRESSION_PHRASE;
+	      break;
+	    }
+	  APP;
+	  goto repeat;
+	default:
+	  APP;
+	  goto repeat;
+	}
+      break;
+
+    case ST_TABLE_1:
+      goto repeat;
+
+    case ST_TABLE_2:
+      if (token == IDENT && yyleng == 1 && yytext[0] == 'X')
+	{
+	  token = EXPORT_SYMBOL_KEYW;
+	  lexstate = ST_TABLE_5;
+	  APP;
+	  break;
+	}
+      lexstate = ST_TABLE_6;
+      /* FALLTHRU */
+
+    case ST_TABLE_6:
+      switch (token)
+	{
+	case '{': case '[': case '(':
+	  ++count;
+	  break;
+	case '}': case ']': case ')':
+	  --count;
+	  break;
+	case ',':
+	  if (count == 0)
+	    lexstate = ST_TABLE_2;
+	  break;
+	};
+      goto repeat;
+
+    case ST_TABLE_3:
+      goto repeat;
+
+    case ST_TABLE_4:
+      if (token == ';')
+	lexstate = ST_NORMAL;
+      goto repeat;
+
+    case ST_TABLE_5:
+      switch (token)
+	{
+	case ',':
+	  token = ';';
+	  lexstate = ST_TABLE_2;
+	  APP;
+	  break;
+	default:
+	  APP;
+	  break;
+	}
+      break;
+
+    default:
+      exit(1);
+    }
+fini:
+
+  if (suppress_type_lookup > 0)
+    --suppress_type_lookup;
+  if (dont_want_brace_phrase > 0)
+    --dont_want_brace_phrase;
+
+  yylval = &next_node->next;
+
+  return token;
+}
+
diff -urNp Kernel/scripts/genksyms/parse.c HelloWorld-Renew-v1.0-n7000-jb/scripts/genksyms/parse.c
--- Kernel/scripts/genksyms/parse.c	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/scripts/genksyms/parse.c	2013-04-30 03:22:41.514695909 +0200
@@ -0,0 +1,2520 @@
+
+/* A Bison parser, made by GNU Bison 2.4.1.  */
+
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.4.1"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+
+
+/* Copy the first part of user declarations.  */
+
+/* Line 189 of yacc.c  */
+#line 24 "scripts/genksyms/parse.y"
+
+
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+#include "genksyms.h"
+
+static int is_typedef;
+static int is_extern;
+static char *current_name;
+static struct string_list *decl_spec;
+
+static void yyerror(const char *);
+
+static inline void
+remove_node(struct string_list **p)
+{
+  struct string_list *node = *p;
+  *p = node->next;
+  free_node(node);
+}
+
+static inline void
+remove_list(struct string_list **pb, struct string_list **pe)
+{
+  struct string_list *b = *pb, *e = *pe;
+  *pb = e;
+  free_list(b, e);
+}
+
+
+
+/* Line 189 of yacc.c  */
+#line 106 "scripts/genksyms/parse.c"
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 1
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     ASM_KEYW = 258,
+     ATTRIBUTE_KEYW = 259,
+     AUTO_KEYW = 260,
+     BOOL_KEYW = 261,
+     CHAR_KEYW = 262,
+     CONST_KEYW = 263,
+     DOUBLE_KEYW = 264,
+     ENUM_KEYW = 265,
+     EXTERN_KEYW = 266,
+     EXTENSION_KEYW = 267,
+     FLOAT_KEYW = 268,
+     INLINE_KEYW = 269,
+     INT_KEYW = 270,
+     LONG_KEYW = 271,
+     REGISTER_KEYW = 272,
+     RESTRICT_KEYW = 273,
+     SHORT_KEYW = 274,
+     SIGNED_KEYW = 275,
+     STATIC_KEYW = 276,
+     STRUCT_KEYW = 277,
+     TYPEDEF_KEYW = 278,
+     UNION_KEYW = 279,
+     UNSIGNED_KEYW = 280,
+     VOID_KEYW = 281,
+     VOLATILE_KEYW = 282,
+     TYPEOF_KEYW = 283,
+     EXPORT_SYMBOL_KEYW = 284,
+     ASM_PHRASE = 285,
+     ATTRIBUTE_PHRASE = 286,
+     BRACE_PHRASE = 287,
+     BRACKET_PHRASE = 288,
+     EXPRESSION_PHRASE = 289,
+     CHAR = 290,
+     DOTS = 291,
+     IDENT = 292,
+     INT = 293,
+     REAL = 294,
+     STRING = 295,
+     TYPE = 296,
+     OTHER = 297,
+     FILENAME = 298
+   };
+#endif
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef int YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Line 264 of yacc.c  */
+#line 191 "scripts/genksyms/parse.c"
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int yyi)
+#else
+static int
+YYID (yyi)
+    int yyi;
+#endif
+{
+  return yyi;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (YYID (0))
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
+	Stack = &yyptr->Stack_alloc;					\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  4
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   532
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  53
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  49
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  132
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  188
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   298
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+      47,    49,    48,     2,    46,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,    52,    44,
+       2,    50,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,    51,     2,    45,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35,    36,    37,    38,    39,    40,    41,    42,    43
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint16 yyprhs[] =
+{
+       0,     0,     3,     5,     8,     9,    12,    13,    18,    19,
+      23,    25,    27,    29,    31,    34,    37,    41,    42,    44,
+      46,    50,    55,    56,    58,    60,    63,    65,    67,    69,
+      71,    73,    75,    77,    79,    81,    87,    92,    95,    98,
+     101,   105,   109,   113,   116,   119,   122,   124,   126,   128,
+     130,   132,   134,   136,   138,   140,   142,   144,   147,   148,
+     150,   152,   155,   157,   159,   161,   163,   166,   168,   170,
+     175,   180,   183,   187,   191,   194,   196,   198,   200,   205,
+     210,   213,   217,   221,   224,   226,   230,   231,   233,   235,
+     239,   242,   245,   247,   248,   250,   252,   257,   262,   265,
+     269,   273,   277,   278,   280,   283,   287,   291,   292,   294,
+     296,   299,   303,   306,   307,   309,   311,   315,   318,   321,
+     323,   326,   327,   330,   334,   339,   341,   345,   347,   351,
+     354,   355,   357
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
+{
+      54,     0,    -1,    55,    -1,    54,    55,    -1,    -1,    56,
+      57,    -1,    -1,    12,    23,    58,    60,    -1,    -1,    23,
+      59,    60,    -1,    60,    -1,    84,    -1,    99,    -1,   101,
+      -1,     1,    44,    -1,     1,    45,    -1,    64,    61,    44,
+      -1,    -1,    62,    -1,    63,    -1,    62,    46,    63,    -1,
+      74,   100,    95,    85,    -1,    -1,    65,    -1,    66,    -1,
+      65,    66,    -1,    67,    -1,    68,    -1,     5,    -1,    17,
+      -1,    21,    -1,    11,    -1,    14,    -1,    69,    -1,    73,
+      -1,    28,    47,    65,    48,    49,    -1,    28,    47,    65,
+      49,    -1,    22,    37,    -1,    24,    37,    -1,    10,    37,
+      -1,    22,    37,    87,    -1,    24,    37,    87,    -1,    10,
+      37,    96,    -1,    10,    96,    -1,    22,    87,    -1,    24,
+      87,    -1,     7,    -1,    19,    -1,    15,    -1,    16,    -1,
+      20,    -1,    25,    -1,    13,    -1,     9,    -1,    26,    -1,
+       6,    -1,    41,    -1,    48,    71,    -1,    -1,    72,    -1,
+      73,    -1,    72,    73,    -1,     8,    -1,    27,    -1,    31,
+      -1,    18,    -1,    70,    74,    -1,    75,    -1,    37,    -1,
+      75,    47,    78,    49,    -1,    75,    47,     1,    49,    -1,
+      75,    33,    -1,    47,    74,    49,    -1,    47,     1,    49,
+      -1,    70,    76,    -1,    77,    -1,    37,    -1,    41,    -1,
+      77,    47,    78,    49,    -1,    77,    47,     1,    49,    -1,
+      77,    33,    -1,    47,    76,    49,    -1,    47,     1,    49,
+      -1,    79,    36,    -1,    79,    -1,    80,    46,    36,    -1,
+      -1,    80,    -1,    81,    -1,    80,    46,    81,    -1,    65,
+      82,    -1,    70,    82,    -1,    83,    -1,    -1,    37,    -1,
+      41,    -1,    83,    47,    78,    49,    -1,    83,    47,     1,
+      49,    -1,    83,    33,    -1,    47,    82,    49,    -1,    47,
+       1,    49,    -1,    64,    74,    32,    -1,    -1,    86,    -1,
+      50,    34,    -1,    51,    88,    45,    -1,    51,     1,    45,
+      -1,    -1,    89,    -1,    90,    -1,    89,    90,    -1,    64,
+      91,    44,    -1,     1,    44,    -1,    -1,    92,    -1,    93,
+      -1,    92,    46,    93,    -1,    76,    95,    -1,    37,    94,
+      -1,    94,    -1,    52,    34,    -1,    -1,    95,    31,    -1,
+      51,    97,    45,    -1,    51,    97,    46,    45,    -1,    98,
+      -1,    97,    46,    98,    -1,    37,    -1,    37,    50,    34,
+      -1,    30,    44,    -1,    -1,    30,    -1,    29,    47,    37,
+      49,    44,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint16 yyrline[] =
+{
+       0,   104,   104,   105,   109,   109,   115,   115,   117,   117,
+     119,   120,   121,   122,   123,   124,   128,   142,   143,   147,
+     155,   168,   174,   175,   179,   180,   184,   190,   194,   195,
+     196,   197,   198,   202,   203,   204,   205,   209,   211,   213,
+     217,   224,   231,   241,   244,   245,   249,   250,   251,   252,
+     253,   254,   255,   256,   257,   258,   259,   263,   268,   269,
+     273,   274,   278,   278,   278,   279,   287,   288,   292,   301,
+     303,   305,   307,   309,   316,   317,   321,   322,   323,   325,
+     327,   329,   331,   336,   337,   338,   342,   343,   347,   348,
+     353,   358,   360,   364,   365,   373,   377,   379,   381,   383,
+     385,   390,   399,   400,   405,   410,   411,   415,   416,   420,
+     421,   425,   427,   432,   433,   437,   438,   442,   443,   444,
+     448,   452,   453,   457,   458,   462,   463,   466,   471,   479,
+     483,   484,   488
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "ASM_KEYW", "ATTRIBUTE_KEYW",
+  "AUTO_KEYW", "BOOL_KEYW", "CHAR_KEYW", "CONST_KEYW", "DOUBLE_KEYW",
+  "ENUM_KEYW", "EXTERN_KEYW", "EXTENSION_KEYW", "FLOAT_KEYW",
+  "INLINE_KEYW", "INT_KEYW", "LONG_KEYW", "REGISTER_KEYW", "RESTRICT_KEYW",
+  "SHORT_KEYW", "SIGNED_KEYW", "STATIC_KEYW", "STRUCT_KEYW",
+  "TYPEDEF_KEYW", "UNION_KEYW", "UNSIGNED_KEYW", "VOID_KEYW",
+  "VOLATILE_KEYW", "TYPEOF_KEYW", "EXPORT_SYMBOL_KEYW", "ASM_PHRASE",
+  "ATTRIBUTE_PHRASE", "BRACE_PHRASE", "BRACKET_PHRASE",
+  "EXPRESSION_PHRASE", "CHAR", "DOTS", "IDENT", "INT", "REAL", "STRING",
+  "TYPE", "OTHER", "FILENAME", "';'", "'}'", "','", "'('", "'*'", "')'",
+  "'='", "'{'", "':'", "$accept", "declaration_seq", "declaration", "$@1",
+  "declaration1", "$@2", "$@3", "simple_declaration",
+  "init_declarator_list_opt", "init_declarator_list", "init_declarator",
+  "decl_specifier_seq_opt", "decl_specifier_seq", "decl_specifier",
+  "storage_class_specifier", "type_specifier", "simple_type_specifier",
+  "ptr_operator", "cvar_qualifier_seq_opt", "cvar_qualifier_seq",
+  "cvar_qualifier", "declarator", "direct_declarator", "nested_declarator",
+  "direct_nested_declarator", "parameter_declaration_clause",
+  "parameter_declaration_list_opt", "parameter_declaration_list",
+  "parameter_declaration", "m_abstract_declarator",
+  "direct_m_abstract_declarator", "function_definition", "initializer_opt",
+  "initializer", "class_body", "member_specification_opt",
+  "member_specification", "member_declaration",
+  "member_declarator_list_opt", "member_declarator_list",
+  "member_declarator", "member_bitfield_declarator", "attribute_opt",
+  "enum_body", "enumerator_list", "enumerator", "asm_definition",
+  "asm_phrase_opt", "export_definition", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
+     295,   296,   297,   298,    59,   125,    44,    40,    42,    41,
+      61,   123,    58
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    53,    54,    54,    56,    55,    58,    57,    59,    57,
+      57,    57,    57,    57,    57,    57,    60,    61,    61,    62,
+      62,    63,    64,    64,    65,    65,    66,    66,    67,    67,
+      67,    67,    67,    68,    68,    68,    68,    68,    68,    68,
+      68,    68,    68,    68,    68,    68,    69,    69,    69,    69,
+      69,    69,    69,    69,    69,    69,    69,    70,    71,    71,
+      72,    72,    73,    73,    73,    73,    74,    74,    75,    75,
+      75,    75,    75,    75,    76,    76,    77,    77,    77,    77,
+      77,    77,    77,    78,    78,    78,    79,    79,    80,    80,
+      81,    82,    82,    83,    83,    83,    83,    83,    83,    83,
+      83,    84,    85,    85,    86,    87,    87,    88,    88,    89,
+      89,    90,    90,    91,    91,    92,    92,    93,    93,    93,
+      94,    95,    95,    96,    96,    97,    97,    98,    98,    99,
+     100,   100,   101
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     1,     2,     0,     2,     0,     4,     0,     3,
+       1,     1,     1,     1,     2,     2,     3,     0,     1,     1,
+       3,     4,     0,     1,     1,     2,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     5,     4,     2,     2,     2,
+       3,     3,     3,     2,     2,     2,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     2,     0,     1,
+       1,     2,     1,     1,     1,     1,     2,     1,     1,     4,
+       4,     2,     3,     3,     2,     1,     1,     1,     4,     4,
+       2,     3,     3,     2,     1,     3,     0,     1,     1,     3,
+       2,     2,     1,     0,     1,     1,     4,     4,     2,     3,
+       3,     3,     0,     1,     2,     3,     3,     0,     1,     1,
+       2,     3,     2,     0,     1,     1,     3,     2,     2,     1,
+       2,     0,     2,     3,     4,     1,     3,     1,     3,     2,
+       0,     1,     5
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       4,     4,     2,     0,     1,     3,     0,    28,    55,    46,
+      62,    53,     0,    31,     0,    52,    32,    48,    49,    29,
+      65,    47,    50,    30,     0,     8,     0,    51,    54,    63,
+       0,     0,     0,    64,    56,     5,    10,    17,    23,    24,
+      26,    27,    33,    34,    11,    12,    13,    14,    15,    39,
+       0,    43,     6,    37,     0,    44,    22,    38,    45,     0,
+       0,   129,    68,     0,    58,     0,    18,    19,     0,   130,
+      67,    25,    42,   127,     0,   125,    22,    40,     0,   113,
+       0,     0,   109,     9,    17,    41,     0,     0,     0,     0,
+      57,    59,    60,    16,     0,    66,   131,   101,   121,    71,
+       0,     0,   123,     0,     7,   112,   106,    76,    77,     0,
+       0,     0,   121,    75,     0,   114,   115,   119,   105,     0,
+     110,   130,     0,    36,     0,    73,    72,    61,    20,   102,
+       0,    93,     0,    84,    87,    88,   128,   124,   126,   118,
+       0,    76,     0,   120,    74,   117,    80,     0,   111,     0,
+      35,   132,   122,     0,    21,   103,    70,    94,    56,     0,
+      93,    90,    92,    69,    83,     0,    82,    81,     0,     0,
+     116,   104,     0,    95,     0,    91,    98,     0,    85,    89,
+      79,    78,   100,    99,     0,     0,    97,    96
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int16 yydefgoto[] =
+{
+      -1,     1,     2,     3,    35,    76,    56,    36,    65,    66,
+      67,    79,    38,    39,    40,    41,    42,    68,    90,    91,
+      43,   121,    70,   112,   113,   132,   133,   134,   135,   161,
+     162,    44,   154,   155,    55,    80,    81,    82,   114,   115,
+     116,   117,   129,    51,    74,    75,    45,    98,    46
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -135
+static const yytype_int16 yypact[] =
+{
+    -135,    20,  -135,   321,  -135,  -135,    30,  -135,  -135,  -135,
+    -135,  -135,   -28,  -135,     2,  -135,  -135,  -135,  -135,  -135,
+    -135,  -135,  -135,  -135,    -6,  -135,     9,  -135,  -135,  -135,
+      -5,    15,   -17,  -135,  -135,  -135,  -135,    18,   491,  -135,
+    -135,  -135,  -135,  -135,  -135,  -135,  -135,  -135,  -135,   -22,
+      31,  -135,  -135,    19,   106,  -135,   491,    19,  -135,   491,
+      50,  -135,  -135,    11,    -3,    51,    57,  -135,    18,   -14,
+      14,  -135,  -135,    48,    46,  -135,   491,  -135,    33,    32,
+      59,   154,  -135,  -135,    18,  -135,   365,    56,    60,    61,
+    -135,    -3,  -135,  -135,    18,  -135,  -135,  -135,  -135,  -135,
+     202,    74,  -135,   -23,  -135,  -135,  -135,    77,  -135,    16,
+     101,    49,  -135,    34,    92,    93,  -135,  -135,  -135,    94,
+    -135,   110,    95,  -135,    97,  -135,  -135,  -135,  -135,   -20,
+      96,   410,    99,   113,   100,  -135,  -135,  -135,  -135,  -135,
+     103,  -135,   107,  -135,  -135,   111,  -135,   239,  -135,    32,
+    -135,  -135,  -135,   123,  -135,  -135,  -135,  -135,  -135,     3,
+      52,  -135,    38,  -135,  -135,   454,  -135,  -135,   117,   128,
+    -135,  -135,   134,  -135,   135,  -135,  -135,   276,  -135,  -135,
+    -135,  -135,  -135,  -135,   137,   138,  -135,  -135
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int16 yypgoto[] =
+{
+    -135,  -135,   187,  -135,  -135,  -135,  -135,   -50,  -135,  -135,
+      98,     0,   -59,   -37,  -135,  -135,  -135,   -77,  -135,  -135,
+     -54,   -30,  -135,   -90,  -135,  -134,  -135,  -135,    24,   -58,
+    -135,  -135,  -135,  -135,   -18,  -135,  -135,   109,  -135,  -135,
+      44,    87,    84,   148,  -135,   102,  -135,  -135,  -135
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -109
+static const yytype_int16 yytable[] =
+{
+      86,    71,   111,    37,   172,    10,    83,    69,    58,    49,
+      92,   152,    88,   169,    73,    20,    96,   140,    97,   142,
+       4,   144,   137,    50,    29,    52,   104,    61,    33,    50,
+     153,    53,   111,    89,   111,    77,   -93,   127,    95,    85,
+     157,   131,    59,   185,   173,    54,    57,    99,    62,    71,
+     159,    64,   -93,   141,   160,    62,    84,   108,    63,    64,
+      54,   100,    60,   109,    64,    63,    64,   146,    73,   107,
+      54,   176,   111,   108,    47,    48,    84,   105,   106,   109,
+      64,   147,   160,   160,   110,   177,   141,    87,   131,   157,
+     108,   102,   103,   173,    71,    93,   109,    64,   101,   159,
+      64,   174,   175,    94,   118,   124,   131,    78,   136,   125,
+     126,     7,     8,     9,    10,    11,    12,    13,   131,    15,
+      16,    17,    18,    19,    20,    21,    22,    23,    24,   110,
+      26,    27,    28,    29,    30,   143,   148,    33,   105,   149,
+      96,   151,   152,   -22,   150,   156,   165,    34,   163,   164,
+     -22,  -107,   166,   -22,   -22,   119,   167,   171,   -22,     7,
+       8,     9,    10,    11,    12,    13,   180,    15,    16,    17,
+      18,    19,    20,    21,    22,    23,    24,   181,    26,    27,
+      28,    29,    30,   182,   183,    33,   186,   187,     5,   179,
+     120,   -22,   128,   170,   139,    34,   145,    72,   -22,  -108,
+       0,   -22,   -22,   130,     0,   138,   -22,     7,     8,     9,
+      10,    11,    12,    13,     0,    15,    16,    17,    18,    19,
+      20,    21,    22,    23,    24,     0,    26,    27,    28,    29,
+      30,     0,     0,    33,     0,     0,     0,     0,   -86,     0,
+     168,     0,     0,    34,     7,     8,     9,    10,    11,    12,
+      13,   -86,    15,    16,    17,    18,    19,    20,    21,    22,
+      23,    24,     0,    26,    27,    28,    29,    30,     0,     0,
+      33,     0,     0,     0,     0,   -86,     0,   184,     0,     0,
+      34,     7,     8,     9,    10,    11,    12,    13,   -86,    15,
+      16,    17,    18,    19,    20,    21,    22,    23,    24,     0,
+      26,    27,    28,    29,    30,     0,     0,    33,     0,     0,
+       0,     0,   -86,     0,     0,     0,     0,    34,     0,     0,
+       0,     0,     6,     0,     0,   -86,     7,     8,     9,    10,
+      11,    12,    13,    14,    15,    16,    17,    18,    19,    20,
+      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
+      31,    32,    33,     0,     0,     0,     0,     0,   -22,     0,
+       0,     0,    34,     0,     0,   -22,     0,     0,   -22,   -22,
+       7,     8,     9,    10,    11,    12,    13,     0,    15,    16,
+      17,    18,    19,    20,    21,    22,    23,    24,     0,    26,
+      27,    28,    29,    30,     0,     0,    33,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,    34,     0,     0,     0,
+       0,     0,     0,   122,   123,     7,     8,     9,    10,    11,
+      12,    13,     0,    15,    16,    17,    18,    19,    20,    21,
+      22,    23,    24,     0,    26,    27,    28,    29,    30,     0,
+       0,    33,     0,     0,     0,     0,     0,   157,     0,     0,
+       0,   158,     0,     0,     0,     0,     0,   159,    64,     7,
+       8,     9,    10,    11,    12,    13,     0,    15,    16,    17,
+      18,    19,    20,    21,    22,    23,    24,     0,    26,    27,
+      28,    29,    30,     0,     0,    33,     0,     0,     0,     0,
+     178,     0,     0,     0,     0,    34,     7,     8,     9,    10,
+      11,    12,    13,     0,    15,    16,    17,    18,    19,    20,
+      21,    22,    23,    24,     0,    26,    27,    28,    29,    30,
+       0,     0,    33,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,    34
+};
+
+static const yytype_int16 yycheck[] =
+{
+      59,    38,    79,     3,     1,     8,    56,    37,    26,    37,
+      64,    31,     1,   147,    37,    18,    30,     1,    32,   109,
+       0,   111,    45,    51,    27,    23,    76,    44,    31,    51,
+      50,    37,   109,    63,   111,    53,    33,    91,    68,    57,
+      37,   100,    47,   177,    41,    51,    37,    33,    37,    86,
+      47,    48,    49,    37,   131,    37,    56,    41,    47,    48,
+      51,    47,    47,    47,    48,    47,    48,    33,    37,    37,
+      51,    33,   149,    41,    44,    45,    76,    44,    45,    47,
+      48,    47,   159,   160,    52,    47,    37,    37,   147,    37,
+      41,    45,    46,    41,   131,    44,    47,    48,    50,    47,
+      48,   159,   160,    46,    45,    49,   165,     1,    34,    49,
+      49,     5,     6,     7,     8,     9,    10,    11,   177,    13,
+      14,    15,    16,    17,    18,    19,    20,    21,    22,    52,
+      24,    25,    26,    27,    28,    34,    44,    31,    44,    46,
+      30,    44,    31,    37,    49,    49,    46,    41,    49,    36,
+      44,    45,    49,    47,    48,     1,    49,    34,    52,     5,
+       6,     7,     8,     9,    10,    11,    49,    13,    14,    15,
+      16,    17,    18,    19,    20,    21,    22,    49,    24,    25,
+      26,    27,    28,    49,    49,    31,    49,    49,     1,   165,
+      81,    37,    94,   149,   107,    41,   112,    49,    44,    45,
+      -1,    47,    48,     1,    -1,   103,    52,     5,     6,     7,
+       8,     9,    10,    11,    -1,    13,    14,    15,    16,    17,
+      18,    19,    20,    21,    22,    -1,    24,    25,    26,    27,
+      28,    -1,    -1,    31,    -1,    -1,    -1,    -1,    36,    -1,
+       1,    -1,    -1,    41,     5,     6,     7,     8,     9,    10,
+      11,    49,    13,    14,    15,    16,    17,    18,    19,    20,
+      21,    22,    -1,    24,    25,    26,    27,    28,    -1,    -1,
+      31,    -1,    -1,    -1,    -1,    36,    -1,     1,    -1,    -1,
+      41,     5,     6,     7,     8,     9,    10,    11,    49,    13,
+      14,    15,    16,    17,    18,    19,    20,    21,    22,    -1,
+      24,    25,    26,    27,    28,    -1,    -1,    31,    -1,    -1,
+      -1,    -1,    36,    -1,    -1,    -1,    -1,    41,    -1,    -1,
+      -1,    -1,     1,    -1,    -1,    49,     5,     6,     7,     8,
+       9,    10,    11,    12,    13,    14,    15,    16,    17,    18,
+      19,    20,    21,    22,    23,    24,    25,    26,    27,    28,
+      29,    30,    31,    -1,    -1,    -1,    -1,    -1,    37,    -1,
+      -1,    -1,    41,    -1,    -1,    44,    -1,    -1,    47,    48,
+       5,     6,     7,     8,     9,    10,    11,    -1,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    -1,    24,
+      25,    26,    27,    28,    -1,    -1,    31,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    41,    -1,    -1,    -1,
+      -1,    -1,    -1,    48,    49,     5,     6,     7,     8,     9,
+      10,    11,    -1,    13,    14,    15,    16,    17,    18,    19,
+      20,    21,    22,    -1,    24,    25,    26,    27,    28,    -1,
+      -1,    31,    -1,    -1,    -1,    -1,    -1,    37,    -1,    -1,
+      -1,    41,    -1,    -1,    -1,    -1,    -1,    47,    48,     5,
+       6,     7,     8,     9,    10,    11,    -1,    13,    14,    15,
+      16,    17,    18,    19,    20,    21,    22,    -1,    24,    25,
+      26,    27,    28,    -1,    -1,    31,    -1,    -1,    -1,    -1,
+      36,    -1,    -1,    -1,    -1,    41,     5,     6,     7,     8,
+       9,    10,    11,    -1,    13,    14,    15,    16,    17,    18,
+      19,    20,    21,    22,    -1,    24,    25,    26,    27,    28,
+      -1,    -1,    31,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    41
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,    54,    55,    56,     0,    55,     1,     5,     6,     7,
+       8,     9,    10,    11,    12,    13,    14,    15,    16,    17,
+      18,    19,    20,    21,    22,    23,    24,    25,    26,    27,
+      28,    29,    30,    31,    41,    57,    60,    64,    65,    66,
+      67,    68,    69,    73,    84,    99,   101,    44,    45,    37,
+      51,    96,    23,    37,    51,    87,    59,    37,    87,    47,
+      47,    44,    37,    47,    48,    61,    62,    63,    70,    74,
+      75,    66,    96,    37,    97,    98,    58,    87,     1,    64,
+      88,    89,    90,    60,    64,    87,    65,    37,     1,    74,
+      71,    72,    73,    44,    46,    74,    30,    32,   100,    33,
+      47,    50,    45,    46,    60,    44,    45,    37,    41,    47,
+      52,    70,    76,    77,    91,    92,    93,    94,    45,     1,
+      90,    74,    48,    49,    49,    49,    49,    73,    63,    95,
+       1,    65,    78,    79,    80,    81,    34,    45,    98,    94,
+       1,    37,    76,    34,    76,    95,    33,    47,    44,    46,
+      49,    44,    31,    50,    85,    86,    49,    37,    41,    47,
+      70,    82,    83,    49,    36,    46,    49,    49,     1,    78,
+      93,    34,     1,    41,    82,    82,    33,    47,    36,    81,
+      49,    49,    49,    49,     1,    78,    49,    49
+};
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+
+#define YYFAIL		goto yyerrlab
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK (1);						\
+      goto yybackup;						\
+    }								\
+  else								\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (YYID (0))
+
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
+#endif
+
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
+#else
+# define YYLEX yylex ()
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+#else
+static void
+yy_stack_print (yybottom, yytop)
+    yytype_int16 *yybottom;
+    yytype_int16 *yytop;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
+    int yyrule;
+#endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static YYSIZE_T
+yystrlen (const char *yystr)
+#else
+static YYSIZE_T
+yystrlen (yystr)
+    const char *yystr;
+#endif
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+#else
+static char *
+yystpcpy (yydest, yysrc)
+    char *yydest;
+    const char *yysrc;
+#endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
+{
+  int yyn = yypact[yystate];
+
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+# endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
+}
+#endif /* YYERROR_VERBOSE */
+
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+
+      default:
+	break;
+    }
+}
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+
+/*-------------------------.
+| yyparse or yypush_parse.  |
+`-------------------------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
+#endif
+{
+
+
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       `yyss': related to states.
+       `yyvs': related to semantic values.
+
+       Refer to the stacks thru separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yytoken = 0;
+  yyss = yyssa;
+  yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack.  Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	yytype_int16 *yyss1 = yyss;
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	yytype_int16 *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss_alloc, yyss);
+	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  *++yyvsp = yylval;
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 4:
+
+/* Line 1455 of yacc.c  */
+#line 109 "scripts/genksyms/parse.y"
+    { is_typedef = 0; is_extern = 0; current_name = NULL; decl_spec = NULL; ;}
+    break;
+
+  case 5:
+
+/* Line 1455 of yacc.c  */
+#line 111 "scripts/genksyms/parse.y"
+    { free_list(*(yyvsp[(2) - (2)]), NULL); *(yyvsp[(2) - (2)]) = NULL; ;}
+    break;
+
+  case 6:
+
+/* Line 1455 of yacc.c  */
+#line 115 "scripts/genksyms/parse.y"
+    { is_typedef = 1; ;}
+    break;
+
+  case 7:
+
+/* Line 1455 of yacc.c  */
+#line 116 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(4) - (4)]); ;}
+    break;
+
+  case 8:
+
+/* Line 1455 of yacc.c  */
+#line 117 "scripts/genksyms/parse.y"
+    { is_typedef = 1; ;}
+    break;
+
+  case 9:
+
+/* Line 1455 of yacc.c  */
+#line 118 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 14:
+
+/* Line 1455 of yacc.c  */
+#line 123 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 15:
+
+/* Line 1455 of yacc.c  */
+#line 124 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 16:
+
+/* Line 1455 of yacc.c  */
+#line 129 "scripts/genksyms/parse.y"
+    { if (current_name) {
+		    struct string_list *decl = (*(yyvsp[(3) - (3)]))->next;
+		    (*(yyvsp[(3) - (3)]))->next = NULL;
+		    add_symbol(current_name,
+			       is_typedef ? SYM_TYPEDEF : SYM_NORMAL,
+			       decl, is_extern);
+		    current_name = NULL;
+		  }
+		  (yyval) = (yyvsp[(3) - (3)]);
+		;}
+    break;
+
+  case 17:
+
+/* Line 1455 of yacc.c  */
+#line 142 "scripts/genksyms/parse.y"
+    { (yyval) = NULL; ;}
+    break;
+
+  case 19:
+
+/* Line 1455 of yacc.c  */
+#line 148 "scripts/genksyms/parse.y"
+    { struct string_list *decl = *(yyvsp[(1) - (1)]);
+		  *(yyvsp[(1) - (1)]) = NULL;
+		  add_symbol(current_name,
+			     is_typedef ? SYM_TYPEDEF : SYM_NORMAL, decl, is_extern);
+		  current_name = NULL;
+		  (yyval) = (yyvsp[(1) - (1)]);
+		;}
+    break;
+
+  case 20:
+
+/* Line 1455 of yacc.c  */
+#line 156 "scripts/genksyms/parse.y"
+    { struct string_list *decl = *(yyvsp[(3) - (3)]);
+		  *(yyvsp[(3) - (3)]) = NULL;
+		  free_list(*(yyvsp[(2) - (3)]), NULL);
+		  *(yyvsp[(2) - (3)]) = decl_spec;
+		  add_symbol(current_name,
+			     is_typedef ? SYM_TYPEDEF : SYM_NORMAL, decl, is_extern);
+		  current_name = NULL;
+		  (yyval) = (yyvsp[(3) - (3)]);
+		;}
+    break;
+
+  case 21:
+
+/* Line 1455 of yacc.c  */
+#line 169 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(4) - (4)]) ? (yyvsp[(4) - (4)]) : (yyvsp[(3) - (4)]) ? (yyvsp[(3) - (4)]) : (yyvsp[(2) - (4)]) ? (yyvsp[(2) - (4)]) : (yyvsp[(1) - (4)]); ;}
+    break;
+
+  case 22:
+
+/* Line 1455 of yacc.c  */
+#line 174 "scripts/genksyms/parse.y"
+    { decl_spec = NULL; ;}
+    break;
+
+  case 24:
+
+/* Line 1455 of yacc.c  */
+#line 179 "scripts/genksyms/parse.y"
+    { decl_spec = *(yyvsp[(1) - (1)]); ;}
+    break;
+
+  case 25:
+
+/* Line 1455 of yacc.c  */
+#line 180 "scripts/genksyms/parse.y"
+    { decl_spec = *(yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 26:
+
+/* Line 1455 of yacc.c  */
+#line 185 "scripts/genksyms/parse.y"
+    { /* Version 2 checksumming ignores storage class, as that
+		     is really irrelevant to the linkage.  */
+		  remove_node((yyvsp[(1) - (1)]));
+		  (yyval) = (yyvsp[(1) - (1)]);
+		;}
+    break;
+
+  case 31:
+
+/* Line 1455 of yacc.c  */
+#line 197 "scripts/genksyms/parse.y"
+    { is_extern = 1; (yyval) = (yyvsp[(1) - (1)]); ;}
+    break;
+
+  case 32:
+
+/* Line 1455 of yacc.c  */
+#line 198 "scripts/genksyms/parse.y"
+    { is_extern = 0; (yyval) = (yyvsp[(1) - (1)]); ;}
+    break;
+
+  case 37:
+
+/* Line 1455 of yacc.c  */
+#line 210 "scripts/genksyms/parse.y"
+    { remove_node((yyvsp[(1) - (2)])); (*(yyvsp[(2) - (2)]))->tag = SYM_STRUCT; (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 38:
+
+/* Line 1455 of yacc.c  */
+#line 212 "scripts/genksyms/parse.y"
+    { remove_node((yyvsp[(1) - (2)])); (*(yyvsp[(2) - (2)]))->tag = SYM_UNION; (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 39:
+
+/* Line 1455 of yacc.c  */
+#line 214 "scripts/genksyms/parse.y"
+    { remove_node((yyvsp[(1) - (2)])); (*(yyvsp[(2) - (2)]))->tag = SYM_ENUM; (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 40:
+
+/* Line 1455 of yacc.c  */
+#line 218 "scripts/genksyms/parse.y"
+    { struct string_list *s = *(yyvsp[(3) - (3)]), *i = *(yyvsp[(2) - (3)]), *r;
+		  r = copy_node(i); r->tag = SYM_STRUCT;
+		  r->next = (*(yyvsp[(1) - (3)]))->next; *(yyvsp[(3) - (3)]) = r; (*(yyvsp[(1) - (3)]))->next = NULL;
+		  add_symbol(i->string, SYM_STRUCT, s, is_extern);
+		  (yyval) = (yyvsp[(3) - (3)]);
+		;}
+    break;
+
+  case 41:
+
+/* Line 1455 of yacc.c  */
+#line 225 "scripts/genksyms/parse.y"
+    { struct string_list *s = *(yyvsp[(3) - (3)]), *i = *(yyvsp[(2) - (3)]), *r;
+		  r = copy_node(i); r->tag = SYM_UNION;
+		  r->next = (*(yyvsp[(1) - (3)]))->next; *(yyvsp[(3) - (3)]) = r; (*(yyvsp[(1) - (3)]))->next = NULL;
+		  add_symbol(i->string, SYM_UNION, s, is_extern);
+		  (yyval) = (yyvsp[(3) - (3)]);
+		;}
+    break;
+
+  case 42:
+
+/* Line 1455 of yacc.c  */
+#line 232 "scripts/genksyms/parse.y"
+    { struct string_list *s = *(yyvsp[(3) - (3)]), *i = *(yyvsp[(2) - (3)]), *r;
+		  r = copy_node(i); r->tag = SYM_ENUM;
+		  r->next = (*(yyvsp[(1) - (3)]))->next; *(yyvsp[(3) - (3)]) = r; (*(yyvsp[(1) - (3)]))->next = NULL;
+		  add_symbol(i->string, SYM_ENUM, s, is_extern);
+		  (yyval) = (yyvsp[(3) - (3)]);
+		;}
+    break;
+
+  case 43:
+
+/* Line 1455 of yacc.c  */
+#line 242 "scripts/genksyms/parse.y"
+    { add_symbol(NULL, SYM_ENUM, NULL, 0); (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 44:
+
+/* Line 1455 of yacc.c  */
+#line 244 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 45:
+
+/* Line 1455 of yacc.c  */
+#line 245 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 56:
+
+/* Line 1455 of yacc.c  */
+#line 259 "scripts/genksyms/parse.y"
+    { (*(yyvsp[(1) - (1)]))->tag = SYM_TYPEDEF; (yyval) = (yyvsp[(1) - (1)]); ;}
+    break;
+
+  case 57:
+
+/* Line 1455 of yacc.c  */
+#line 264 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]) ? (yyvsp[(2) - (2)]) : (yyvsp[(1) - (2)]); ;}
+    break;
+
+  case 58:
+
+/* Line 1455 of yacc.c  */
+#line 268 "scripts/genksyms/parse.y"
+    { (yyval) = NULL; ;}
+    break;
+
+  case 61:
+
+/* Line 1455 of yacc.c  */
+#line 274 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 65:
+
+/* Line 1455 of yacc.c  */
+#line 280 "scripts/genksyms/parse.y"
+    { /* restrict has no effect in prototypes so ignore it */
+		  remove_node((yyvsp[(1) - (1)]));
+		  (yyval) = (yyvsp[(1) - (1)]);
+		;}
+    break;
+
+  case 66:
+
+/* Line 1455 of yacc.c  */
+#line 287 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 68:
+
+/* Line 1455 of yacc.c  */
+#line 293 "scripts/genksyms/parse.y"
+    { if (current_name != NULL) {
+		    error_with_pos("unexpected second declaration name");
+		    YYERROR;
+		  } else {
+		    current_name = (*(yyvsp[(1) - (1)]))->string;
+		    (yyval) = (yyvsp[(1) - (1)]);
+		  }
+		;}
+    break;
+
+  case 69:
+
+/* Line 1455 of yacc.c  */
+#line 302 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(4) - (4)]); ;}
+    break;
+
+  case 70:
+
+/* Line 1455 of yacc.c  */
+#line 304 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(4) - (4)]); ;}
+    break;
+
+  case 71:
+
+/* Line 1455 of yacc.c  */
+#line 306 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 72:
+
+/* Line 1455 of yacc.c  */
+#line 308 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 73:
+
+/* Line 1455 of yacc.c  */
+#line 310 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 74:
+
+/* Line 1455 of yacc.c  */
+#line 316 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 78:
+
+/* Line 1455 of yacc.c  */
+#line 324 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(4) - (4)]); ;}
+    break;
+
+  case 79:
+
+/* Line 1455 of yacc.c  */
+#line 326 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(4) - (4)]); ;}
+    break;
+
+  case 80:
+
+/* Line 1455 of yacc.c  */
+#line 328 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 81:
+
+/* Line 1455 of yacc.c  */
+#line 330 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 82:
+
+/* Line 1455 of yacc.c  */
+#line 332 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 83:
+
+/* Line 1455 of yacc.c  */
+#line 336 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 85:
+
+/* Line 1455 of yacc.c  */
+#line 338 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 86:
+
+/* Line 1455 of yacc.c  */
+#line 342 "scripts/genksyms/parse.y"
+    { (yyval) = NULL; ;}
+    break;
+
+  case 89:
+
+/* Line 1455 of yacc.c  */
+#line 349 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 90:
+
+/* Line 1455 of yacc.c  */
+#line 354 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]) ? (yyvsp[(2) - (2)]) : (yyvsp[(1) - (2)]); ;}
+    break;
+
+  case 91:
+
+/* Line 1455 of yacc.c  */
+#line 359 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]) ? (yyvsp[(2) - (2)]) : (yyvsp[(1) - (2)]); ;}
+    break;
+
+  case 93:
+
+/* Line 1455 of yacc.c  */
+#line 364 "scripts/genksyms/parse.y"
+    { (yyval) = NULL; ;}
+    break;
+
+  case 94:
+
+/* Line 1455 of yacc.c  */
+#line 366 "scripts/genksyms/parse.y"
+    { /* For version 2 checksums, we don't want to remember
+		     private parameter names.  */
+		  remove_node((yyvsp[(1) - (1)]));
+		  (yyval) = (yyvsp[(1) - (1)]);
+		;}
+    break;
+
+  case 95:
+
+/* Line 1455 of yacc.c  */
+#line 374 "scripts/genksyms/parse.y"
+    { remove_node((yyvsp[(1) - (1)]));
+		  (yyval) = (yyvsp[(1) - (1)]);
+		;}
+    break;
+
+  case 96:
+
+/* Line 1455 of yacc.c  */
+#line 378 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(4) - (4)]); ;}
+    break;
+
+  case 97:
+
+/* Line 1455 of yacc.c  */
+#line 380 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(4) - (4)]); ;}
+    break;
+
+  case 98:
+
+/* Line 1455 of yacc.c  */
+#line 382 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 99:
+
+/* Line 1455 of yacc.c  */
+#line 384 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 100:
+
+/* Line 1455 of yacc.c  */
+#line 386 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 101:
+
+/* Line 1455 of yacc.c  */
+#line 391 "scripts/genksyms/parse.y"
+    { struct string_list *decl = *(yyvsp[(2) - (3)]);
+		  *(yyvsp[(2) - (3)]) = NULL;
+		  add_symbol(current_name, SYM_NORMAL, decl, is_extern);
+		  (yyval) = (yyvsp[(3) - (3)]);
+		;}
+    break;
+
+  case 102:
+
+/* Line 1455 of yacc.c  */
+#line 399 "scripts/genksyms/parse.y"
+    { (yyval) = NULL; ;}
+    break;
+
+  case 104:
+
+/* Line 1455 of yacc.c  */
+#line 406 "scripts/genksyms/parse.y"
+    { remove_list((yyvsp[(2) - (2)]), &(*(yyvsp[(1) - (2)]))->next); (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 105:
+
+/* Line 1455 of yacc.c  */
+#line 410 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 106:
+
+/* Line 1455 of yacc.c  */
+#line 411 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 107:
+
+/* Line 1455 of yacc.c  */
+#line 415 "scripts/genksyms/parse.y"
+    { (yyval) = NULL; ;}
+    break;
+
+  case 110:
+
+/* Line 1455 of yacc.c  */
+#line 421 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 111:
+
+/* Line 1455 of yacc.c  */
+#line 426 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 112:
+
+/* Line 1455 of yacc.c  */
+#line 428 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 113:
+
+/* Line 1455 of yacc.c  */
+#line 432 "scripts/genksyms/parse.y"
+    { (yyval) = NULL; ;}
+    break;
+
+  case 116:
+
+/* Line 1455 of yacc.c  */
+#line 438 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 117:
+
+/* Line 1455 of yacc.c  */
+#line 442 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]) ? (yyvsp[(2) - (2)]) : (yyvsp[(1) - (2)]); ;}
+    break;
+
+  case 118:
+
+/* Line 1455 of yacc.c  */
+#line 443 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 120:
+
+/* Line 1455 of yacc.c  */
+#line 448 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 121:
+
+/* Line 1455 of yacc.c  */
+#line 452 "scripts/genksyms/parse.y"
+    { (yyval) = NULL; ;}
+    break;
+
+  case 123:
+
+/* Line 1455 of yacc.c  */
+#line 457 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(3) - (3)]); ;}
+    break;
+
+  case 124:
+
+/* Line 1455 of yacc.c  */
+#line 458 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(4) - (4)]); ;}
+    break;
+
+  case 127:
+
+/* Line 1455 of yacc.c  */
+#line 467 "scripts/genksyms/parse.y"
+    {
+			const char *name = strdup((*(yyvsp[(1) - (1)]))->string);
+			add_symbol(name, SYM_ENUM_CONST, NULL, 0);
+		;}
+    break;
+
+  case 128:
+
+/* Line 1455 of yacc.c  */
+#line 472 "scripts/genksyms/parse.y"
+    {
+			const char *name = strdup((*(yyvsp[(1) - (3)]))->string);
+			struct string_list *expr = copy_list_range(*(yyvsp[(3) - (3)]), *(yyvsp[(2) - (3)]));
+			add_symbol(name, SYM_ENUM_CONST, expr, 0);
+		;}
+    break;
+
+  case 129:
+
+/* Line 1455 of yacc.c  */
+#line 479 "scripts/genksyms/parse.y"
+    { (yyval) = (yyvsp[(2) - (2)]); ;}
+    break;
+
+  case 130:
+
+/* Line 1455 of yacc.c  */
+#line 483 "scripts/genksyms/parse.y"
+    { (yyval) = NULL; ;}
+    break;
+
+  case 132:
+
+/* Line 1455 of yacc.c  */
+#line 489 "scripts/genksyms/parse.y"
+    { export_symbol((*(yyvsp[(3) - (5)]))->string); (yyval) = (yyvsp[(5) - (5)]); ;}
+    break;
+
+
+
+/* Line 1455 of yacc.c  */
+#line 2301 "scripts/genksyms/parse.c"
+      default: break;
+    }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  *++yyvsp = yylval;
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined(yyoverflow) || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
+}
+
+
+
+/* Line 1675 of yacc.c  */
+#line 493 "scripts/genksyms/parse.y"
+
+
+static void
+yyerror(const char *e)
+{
+  error_with_pos("%s", e);
+}
+
diff -urNp Kernel/scripts/genksyms/parse.h HelloWorld-Renew-v1.0-n7000-jb/scripts/genksyms/parse.h
--- Kernel/scripts/genksyms/parse.h	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/scripts/genksyms/parse.h	2013-04-30 03:22:41.506695909 +0200
@@ -0,0 +1,97 @@
+
+/* A Bison parser, made by GNU Bison 2.4.1.  */
+
+/* Skeleton interface for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     ASM_KEYW = 258,
+     ATTRIBUTE_KEYW = 259,
+     AUTO_KEYW = 260,
+     BOOL_KEYW = 261,
+     CHAR_KEYW = 262,
+     CONST_KEYW = 263,
+     DOUBLE_KEYW = 264,
+     ENUM_KEYW = 265,
+     EXTERN_KEYW = 266,
+     EXTENSION_KEYW = 267,
+     FLOAT_KEYW = 268,
+     INLINE_KEYW = 269,
+     INT_KEYW = 270,
+     LONG_KEYW = 271,
+     REGISTER_KEYW = 272,
+     RESTRICT_KEYW = 273,
+     SHORT_KEYW = 274,
+     SIGNED_KEYW = 275,
+     STATIC_KEYW = 276,
+     STRUCT_KEYW = 277,
+     TYPEDEF_KEYW = 278,
+     UNION_KEYW = 279,
+     UNSIGNED_KEYW = 280,
+     VOID_KEYW = 281,
+     VOLATILE_KEYW = 282,
+     TYPEOF_KEYW = 283,
+     EXPORT_SYMBOL_KEYW = 284,
+     ASM_PHRASE = 285,
+     ATTRIBUTE_PHRASE = 286,
+     BRACE_PHRASE = 287,
+     BRACKET_PHRASE = 288,
+     EXPRESSION_PHRASE = 289,
+     CHAR = 290,
+     DOTS = 291,
+     IDENT = 292,
+     INT = 293,
+     REAL = 294,
+     STRING = 295,
+     TYPE = 296,
+     OTHER = 297,
+     FILENAME = 298
+   };
+#endif
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef int YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+extern YYSTYPE yylval;
+
+
Binary files Kernel/scripts/kallsyms and HelloWorld-Renew-v1.0-n7000-jb/scripts/kallsyms differ
Binary files Kernel/scripts/kconfig/conf and HelloWorld-Renew-v1.0-n7000-jb/scripts/kconfig/conf differ
diff -urNp Kernel/scripts/kconfig/lex.zconf.c HelloWorld-Renew-v1.0-n7000-jb/scripts/kconfig/lex.zconf.c
--- Kernel/scripts/kconfig/lex.zconf.c	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/scripts/kconfig/lex.zconf.c	2013-04-29 16:58:27.234590314 +0200
@@ -0,0 +1,2435 @@
+
+#line 3 "scripts/kconfig/lex.zconf.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define yy_create_buffer zconf_create_buffer
+#define yy_delete_buffer zconf_delete_buffer
+#define yy_flex_debug zconf_flex_debug
+#define yy_init_buffer zconf_init_buffer
+#define yy_flush_buffer zconf_flush_buffer
+#define yy_load_buffer_state zconf_load_buffer_state
+#define yy_switch_to_buffer zconf_switch_to_buffer
+#define yyin zconfin
+#define yyleng zconfleng
+#define yylex zconflex
+#define yylineno zconflineno
+#define yyout zconfout
+#define yyrestart zconfrestart
+#define yytext zconftext
+#define yywrap zconfwrap
+#define yyalloc zconfalloc
+#define yyrealloc zconfrealloc
+#define yyfree zconffree
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! C99 */
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE zconfrestart(zconfin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k.
+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
+ * Ditto for the __ia64__ case accordingly.
+ */
+#define YY_BUF_SIZE 32768
+#else
+#define YY_BUF_SIZE 16384
+#endif /* __ia64__ */
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int zconfleng;
+
+extern FILE *zconfin, *zconfout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up zconftext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up zconftext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via zconfrestart()), so that the user can continue scanning by
+	 * just pointing zconfin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when zconftext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int zconfleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow zconfwrap()'s to do buffer switches
+ * instead of setting up a fresh zconfin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void zconfrestart (FILE *input_file  );
+void zconf_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE zconf_create_buffer (FILE *file,int size  );
+void zconf_delete_buffer (YY_BUFFER_STATE b  );
+void zconf_flush_buffer (YY_BUFFER_STATE b  );
+void zconfpush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void zconfpop_buffer_state (void );
+
+static void zconfensure_buffer_stack (void );
+static void zconf_load_buffer_state (void );
+static void zconf_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER zconf_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE zconf_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE zconf_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE zconf_scan_bytes (yyconst char *bytes,int len  );
+
+void *zconfalloc (yy_size_t  );
+void *zconfrealloc (void *,yy_size_t  );
+void zconffree (void *  );
+
+#define yy_new_buffer zconf_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        zconfensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            zconf_create_buffer(zconfin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        zconfensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            zconf_create_buffer(zconfin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+#define zconfwrap(n) 1
+#define YY_SKIP_YYWRAP
+
+typedef unsigned char YY_CHAR;
+
+FILE *zconfin = (FILE *) 0, *zconfout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int zconflineno;
+
+int zconflineno = 1;
+
+extern char *zconftext;
+#define yytext_ptr zconftext
+static yyconst flex_int16_t yy_nxt[][17] =
+    {
+    {
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0
+    },
+
+    {
+       11,   12,   13,   14,   12,   12,   15,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12
+    },
+
+    {
+       11,   12,   13,   14,   12,   12,   15,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12
+    },
+
+    {
+       11,   16,   16,   17,   16,   16,   16,   16,   16,   16,
+       16,   16,   16,   18,   16,   16,   16
+    },
+
+    {
+       11,   16,   16,   17,   16,   16,   16,   16,   16,   16,
+       16,   16,   16,   18,   16,   16,   16
+
+    },
+
+    {
+       11,   19,   20,   21,   19,   19,   19,   19,   19,   19,
+       19,   19,   19,   19,   19,   19,   19
+    },
+
+    {
+       11,   19,   20,   21,   19,   19,   19,   19,   19,   19,
+       19,   19,   19,   19,   19,   19,   19
+    },
+
+    {
+       11,   22,   22,   23,   22,   24,   22,   22,   24,   22,
+       22,   22,   22,   22,   22,   25,   22
+    },
+
+    {
+       11,   22,   22,   23,   22,   24,   22,   22,   24,   22,
+       22,   22,   22,   22,   22,   25,   22
+    },
+
+    {
+       11,   26,   26,   27,   28,   29,   30,   31,   29,   32,
+       33,   34,   35,   35,   36,   37,   38
+
+    },
+
+    {
+       11,   26,   26,   27,   28,   29,   30,   31,   29,   32,
+       33,   34,   35,   35,   36,   37,   38
+    },
+
+    {
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11
+    },
+
+    {
+       11,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12
+    },
+
+    {
+       11,  -13,   39,   40,  -13,  -13,   41,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13
+    },
+
+    {
+       11,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14
+
+    },
+
+    {
+       11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+       42,   42,   42,   42,   42,   42,   42
+    },
+
+    {
+       11,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16
+    },
+
+    {
+       11,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17
+    },
+
+    {
+       11,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,   44,  -18,  -18,  -18
+    },
+
+    {
+       11,   45,   45,  -19,   45,   45,   45,   45,   45,   45,
+       45,   45,   45,   45,   45,   45,   45
+
+    },
+
+    {
+       11,  -20,   46,   47,  -20,  -20,  -20,  -20,  -20,  -20,
+      -20,  -20,  -20,  -20,  -20,  -20,  -20
+    },
+
+    {
+       11,   48,  -21,  -21,   48,   48,   48,   48,   48,   48,
+       48,   48,   48,   48,   48,   48,   48
+    },
+
+    {
+       11,   49,   49,   50,   49,  -22,   49,   49,  -22,   49,
+       49,   49,   49,   49,   49,  -22,   49
+    },
+
+    {
+       11,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
+      -23,  -23,  -23,  -23,  -23,  -23,  -23
+    },
+
+    {
+       11,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24,  -24
+
+    },
+
+    {
+       11,   51,   51,   52,   51,   51,   51,   51,   51,   51,
+       51,   51,   51,   51,   51,   51,   51
+    },
+
+    {
+       11,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,  -26,  -26,  -26,  -26
+    },
+
+    {
+       11,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+      -27,  -27,  -27,  -27,  -27,  -27,  -27
+    },
+
+    {
+       11,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+      -28,  -28,  -28,  -28,   53,  -28,  -28
+    },
+
+    {
+       11,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+      -29,  -29,  -29,  -29,  -29,  -29,  -29
+
+    },
+
+    {
+       11,   54,   54,  -30,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54
+    },
+
+    {
+       11,  -31,  -31,  -31,  -31,  -31,  -31,   55,  -31,  -31,
+      -31,  -31,  -31,  -31,  -31,  -31,  -31
+    },
+
+    {
+       11,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
+      -32,  -32,  -32,  -32,  -32,  -32,  -32
+    },
+
+    {
+       11,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,
+      -33,  -33,  -33,  -33,  -33,  -33,  -33
+    },
+
+    {
+       11,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,
+      -34,   56,   57,   57,  -34,  -34,  -34
+
+    },
+
+    {
+       11,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,   57,   57,   57,  -35,  -35,  -35
+    },
+
+    {
+       11,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+      -36,  -36,  -36,  -36,  -36,  -36,  -36
+    },
+
+    {
+       11,  -37,  -37,   58,  -37,  -37,  -37,  -37,  -37,  -37,
+      -37,  -37,  -37,  -37,  -37,  -37,  -37
+    },
+
+    {
+       11,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,   59
+    },
+
+    {
+       11,  -39,   39,   40,  -39,  -39,   41,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39
+
+    },
+
+    {
+       11,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40
+    },
+
+    {
+       11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+       42,   42,   42,   42,   42,   42,   42
+    },
+
+    {
+       11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+       42,   42,   42,   42,   42,   42,   42
+    },
+
+    {
+       11,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43
+    },
+
+    {
+       11,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,   44,  -44,  -44,  -44
+
+    },
+
+    {
+       11,   45,   45,  -45,   45,   45,   45,   45,   45,   45,
+       45,   45,   45,   45,   45,   45,   45
+    },
+
+    {
+       11,  -46,   46,   47,  -46,  -46,  -46,  -46,  -46,  -46,
+      -46,  -46,  -46,  -46,  -46,  -46,  -46
+    },
+
+    {
+       11,   48,  -47,  -47,   48,   48,   48,   48,   48,   48,
+       48,   48,   48,   48,   48,   48,   48
+    },
+
+    {
+       11,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,  -48,  -48,  -48,  -48,  -48,  -48
+    },
+
+    {
+       11,   49,   49,   50,   49,  -49,   49,   49,  -49,   49,
+       49,   49,   49,   49,   49,  -49,   49
+
+    },
+
+    {
+       11,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,  -50
+    },
+
+    {
+       11,  -51,  -51,   52,  -51,  -51,  -51,  -51,  -51,  -51,
+      -51,  -51,  -51,  -51,  -51,  -51,  -51
+    },
+
+    {
+       11,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52
+    },
+
+    {
+       11,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
+      -53,  -53,  -53,  -53,  -53,  -53,  -53
+    },
+
+    {
+       11,   54,   54,  -54,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54
+
+    },
+
+    {
+       11,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,
+      -55,  -55,  -55,  -55,  -55,  -55,  -55
+    },
+
+    {
+       11,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,
+      -56,   60,   57,   57,  -56,  -56,  -56
+    },
+
+    {
+       11,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,
+      -57,   57,   57,   57,  -57,  -57,  -57
+    },
+
+    {
+       11,  -58,  -58,  -58,  -58,  -58,  -58,  -58,  -58,  -58,
+      -58,  -58,  -58,  -58,  -58,  -58,  -58
+    },
+
+    {
+       11,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,
+      -59,  -59,  -59,  -59,  -59,  -59,  -59
+
+    },
+
+    {
+       11,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,
+      -60,   57,   57,   57,  -60,  -60,  -60
+    },
+
+    } ;
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up zconftext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	zconfleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 33
+#define YY_END_OF_BUFFER 34
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[61] =
+    {   0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+       34,    5,    4,    2,    3,    7,    8,    6,   32,   29,
+       31,   24,   28,   27,   26,   22,   17,   13,   16,   20,
+       22,   11,   12,   19,   19,   14,   22,   22,    4,    2,
+        3,    3,    1,    6,   32,   29,   31,   30,   24,   23,
+       26,   25,   15,   20,    9,   19,   19,   21,   10,   18
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    4,    5,    6,    1,    1,    7,    8,    9,
+       10,    1,    1,    1,   11,   12,   12,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,    1,    1,    1,
+       14,    1,    1,    1,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+        1,   15,    1,    1,   13,    1,   13,   13,   13,   13,
+
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,    1,   16,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+extern int zconf_flex_debug;
+int zconf_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *zconftext;
+#define YY_NO_INPUT 1
+
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <limits.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+
+#define START_STRSIZE	16
+
+static struct {
+	struct file *file;
+	int lineno;
+} current_pos;
+
+static char *text;
+static int text_size, text_asize;
+
+struct buffer {
+        struct buffer *parent;
+        YY_BUFFER_STATE state;
+};
+
+struct buffer *current_buf;
+
+static int last_ts, first_ts;
+
+static void zconf_endhelp(void);
+static void zconf_endfile(void);
+
+static void new_string(void)
+{
+	text = malloc(START_STRSIZE);
+	text_asize = START_STRSIZE;
+	text_size = 0;
+	*text = 0;
+}
+
+static void append_string(const char *str, int size)
+{
+	int new_size = text_size + size + 1;
+	if (new_size > text_asize) {
+		new_size += START_STRSIZE - 1;
+		new_size &= -START_STRSIZE;
+		text = realloc(text, new_size);
+		text_asize = new_size;
+	}
+	memcpy(text + text_size, str, size);
+	text_size += size;
+	text[text_size] = 0;
+}
+
+static void alloc_string(const char *str, int size)
+{
+	text = malloc(size + 1);
+	memcpy(text, str, size);
+	text[size] = 0;
+}
+
+#define INITIAL 0
+#define COMMAND 1
+#define HELP 2
+#define STRING 3
+#define PARAM 4
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int zconflex_destroy (void );
+
+int zconfget_debug (void );
+
+void zconfset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE zconfget_extra (void );
+
+void zconfset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *zconfget_in (void );
+
+void zconfset_in  (FILE * in_str  );
+
+FILE *zconfget_out (void );
+
+void zconfset_out  (FILE * out_str  );
+
+int zconfget_leng (void );
+
+char *zconfget_text (void );
+
+int zconfget_lineno (void );
+
+void zconfset_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int zconfwrap (void );
+#else
+extern int zconfwrap (void );
+#endif
+#endif
+
+    static void yyunput (int c,char *buf_ptr  );
+    
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define YY_READ_BUF_SIZE 16384
+#else
+#define YY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( zconftext, zconfleng, 1, zconfout )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	errno=0; \
+	while ( (result = read( fileno(zconfin), (char *) buf, max_size )) < 0 ) \
+	{ \
+		if( errno != EINTR) \
+		{ \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+			break; \
+		} \
+		errno=0; \
+		clearerr(zconfin); \
+	}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int zconflex (void);
+
+#define YY_DECL int zconflex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after zconftext and zconfleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+	int str = 0;
+	int ts, i;
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! zconfin )
+			zconfin = stdin;
+
+		if ( ! zconfout )
+			zconfout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			zconfensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				zconf_create_buffer(zconfin,YY_BUF_SIZE );
+		}
+
+		zconf_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of zconftext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		while ( (yy_current_state = yy_nxt[yy_current_state][ yy_ec[YY_SC_TO_UI(*yy_cp)]  ]) > 0 )
+			++yy_cp;
+
+		yy_current_state = -yy_current_state;
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+case 1:
+/* rule 1 can match eol */
+case 2:
+/* rule 2 can match eol */
+YY_RULE_SETUP
+{
+	current_file->lineno++;
+	return T_EOL;
+}
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+{
+	BEGIN(COMMAND);
+}
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+{
+	unput(zconftext[0]);
+	BEGIN(COMMAND);
+}
+	YY_BREAK
+
+case 6:
+YY_RULE_SETUP
+{
+		struct kconf_id *id = kconf_id_lookup(zconftext, zconfleng);
+		BEGIN(PARAM);
+		current_pos.file = current_file;
+		current_pos.lineno = current_file->lineno;
+		if (id && id->flags & TF_COMMAND) {
+			zconflval.id = id;
+			return id->token;
+		}
+		alloc_string(zconftext, zconfleng);
+		zconflval.string = text;
+		return T_WORD;
+	}
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+
+	YY_BREAK
+case 8:
+/* rule 8 can match eol */
+YY_RULE_SETUP
+{
+		BEGIN(INITIAL);
+		current_file->lineno++;
+		return T_EOL;
+	}
+	YY_BREAK
+
+case 9:
+YY_RULE_SETUP
+return T_AND;
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+return T_OR;
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+return T_OPEN_PAREN;
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+return T_CLOSE_PAREN;
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+return T_NOT;
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+return T_EQUAL;
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+return T_UNEQUAL;
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+{
+		str = zconftext[0];
+		new_string();
+		BEGIN(STRING);
+	}
+	YY_BREAK
+case 17:
+/* rule 17 can match eol */
+YY_RULE_SETUP
+BEGIN(INITIAL); current_file->lineno++; return T_EOL;
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+/* ignore */
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+{
+		struct kconf_id *id = kconf_id_lookup(zconftext, zconfleng);
+		if (id && id->flags & TF_PARAM) {
+			zconflval.id = id;
+			return id->token;
+		}
+		alloc_string(zconftext, zconfleng);
+		zconflval.string = text;
+		return T_WORD;
+	}
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+/* comment */
+	YY_BREAK
+case 21:
+/* rule 21 can match eol */
+YY_RULE_SETUP
+current_file->lineno++;
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+
+	YY_BREAK
+case YY_STATE_EOF(PARAM):
+{
+		BEGIN(INITIAL);
+	}
+	YY_BREAK
+
+case 23:
+/* rule 23 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
+YY_RULE_SETUP
+{
+		append_string(zconftext, zconfleng);
+		zconflval.string = text;
+		return T_WORD_QUOTE;
+	}
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+{
+		append_string(zconftext, zconfleng);
+	}
+	YY_BREAK
+case 25:
+/* rule 25 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
+YY_RULE_SETUP
+{
+		append_string(zconftext + 1, zconfleng - 1);
+		zconflval.string = text;
+		return T_WORD_QUOTE;
+	}
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+{
+		append_string(zconftext + 1, zconfleng - 1);
+	}
+	YY_BREAK
+case 27:
+YY_RULE_SETUP
+{
+		if (str == zconftext[0]) {
+			BEGIN(PARAM);
+			zconflval.string = text;
+			return T_WORD_QUOTE;
+		} else
+			append_string(zconftext, 1);
+	}
+	YY_BREAK
+case 28:
+/* rule 28 can match eol */
+YY_RULE_SETUP
+{
+		printf("%s:%d:warning: multi-line strings not supported\n", zconf_curname(), zconf_lineno());
+		current_file->lineno++;
+		BEGIN(INITIAL);
+		return T_EOL;
+	}
+	YY_BREAK
+case YY_STATE_EOF(STRING):
+{
+		BEGIN(INITIAL);
+	}
+	YY_BREAK
+
+case 29:
+YY_RULE_SETUP
+{
+		ts = 0;
+		for (i = 0; i < zconfleng; i++) {
+			if (zconftext[i] == '\t')
+				ts = (ts & ~7) + 8;
+			else
+				ts++;
+		}
+		last_ts = ts;
+		if (first_ts) {
+			if (ts < first_ts) {
+				zconf_endhelp();
+				return T_HELPTEXT;
+			}
+			ts -= first_ts;
+			while (ts > 8) {
+				append_string("        ", 8);
+				ts -= 8;
+			}
+			append_string("        ", ts);
+		}
+	}
+	YY_BREAK
+case 30:
+/* rule 30 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
+YY_RULE_SETUP
+{
+		current_file->lineno++;
+		zconf_endhelp();
+		return T_HELPTEXT;
+	}
+	YY_BREAK
+case 31:
+/* rule 31 can match eol */
+YY_RULE_SETUP
+{
+		current_file->lineno++;
+		append_string("\n", 1);
+	}
+	YY_BREAK
+case 32:
+YY_RULE_SETUP
+{
+		while (zconfleng) {
+			if ((zconftext[zconfleng-1] != ' ') && (zconftext[zconfleng-1] != '\t'))
+				break;
+			zconfleng--;
+		}
+		append_string(zconftext, zconfleng);
+		if (!first_ts)
+			first_ts = last_ts;
+	}
+	YY_BREAK
+case YY_STATE_EOF(HELP):
+{
+		zconf_endhelp();
+		return T_HELPTEXT;
+	}
+	YY_BREAK
+
+case YY_STATE_EOF(INITIAL):
+case YY_STATE_EOF(COMMAND):
+{
+	if (current_file) {
+		zconf_endfile();
+		return T_EOL;
+	}
+	fclose(zconfin);
+	yyterminate();
+}
+	YY_BREAK
+case 33:
+YY_RULE_SETUP
+YY_FATAL_ERROR( "flex scanner jammed" );
+	YY_BREAK
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed zconfin at a new source and called
+			 * zconflex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = zconfin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( zconfwrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * zconftext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of zconflex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					zconfrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			zconfrestart(zconfin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) zconfrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		yy_current_state = yy_nxt[yy_current_state][(*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1)];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    
+	yy_current_state = yy_nxt[yy_current_state][1];
+	yy_is_jam = (yy_current_state <= 0);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+    static void yyunput (int c, register char * yy_bp )
+{
+	register char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
+
+	/* undo effects of setting up zconftext */
+	*yy_cp = (yy_hold_char);
+
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = (yy_n_chars) + 2;
+		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
+		register char *source =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
+
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					zconfrestart(zconfin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( zconfwrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve zconftext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void zconfrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        zconfensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            zconf_create_buffer(zconfin,YY_BUF_SIZE );
+	}
+
+	zconf_init_buffer(YY_CURRENT_BUFFER,input_file );
+	zconf_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void zconf_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		zconfpop_buffer_state();
+	 *		zconfpush_buffer_state(new_buffer);
+     */
+	zconfensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	zconf_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (zconfwrap()) processing, but the only time this flag
+	 * is looked at is after zconfwrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void zconf_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	zconfin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE zconf_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) zconfalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) zconfalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	zconf_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with zconf_create_buffer()
+ * 
+ */
+    void zconf_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		zconffree((void *) b->yy_ch_buf  );
+
+	zconffree((void *) b  );
+}
+
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a zconfrestart() or at EOF.
+ */
+    static void zconf_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	zconf_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then zconf_init_buffer was _probably_
+     * called from zconfrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void zconf_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		zconf_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void zconfpush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	zconfensure_buffer_stack();
+
+	/* This block is copied from zconf_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from zconf_switch_to_buffer. */
+	zconf_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void zconfpop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	zconf_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		zconf_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void zconfensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)zconfalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in zconfensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)zconfrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in zconfensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE zconf_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) zconfalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	zconf_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to zconflex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       zconf_scan_bytes() instead.
+ */
+YY_BUFFER_STATE zconf_scan_string (yyconst char * yystr )
+{
+    
+	return zconf_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to zconflex() will
+ * scan from a @e copy of @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE zconf_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) zconfalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = zconf_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in zconf_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up zconftext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		zconftext[zconfleng] = (yy_hold_char); \
+		(yy_c_buf_p) = zconftext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		zconfleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int zconfget_lineno  (void)
+{
+        
+    return zconflineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *zconfget_in  (void)
+{
+        return zconfin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *zconfget_out  (void)
+{
+        return zconfout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int zconfget_leng  (void)
+{
+        return zconfleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *zconfget_text  (void)
+{
+        return zconftext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void zconfset_lineno (int  line_number )
+{
+    
+    zconflineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see zconf_switch_to_buffer
+ */
+void zconfset_in (FILE *  in_str )
+{
+        zconfin = in_str ;
+}
+
+void zconfset_out (FILE *  out_str )
+{
+        zconfout = out_str ;
+}
+
+int zconfget_debug  (void)
+{
+        return zconf_flex_debug;
+}
+
+void zconfset_debug (int  bdebug )
+{
+        zconf_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from zconflex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    zconfin = stdin;
+    zconfout = stdout;
+#else
+    zconfin = (FILE *) 0;
+    zconfout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * zconflex_init()
+     */
+    return 0;
+}
+
+/* zconflex_destroy is for both reentrant and non-reentrant scanners. */
+int zconflex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		zconf_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		zconfpop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	zconffree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * zconflex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *zconfalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *zconfrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void zconffree (void * ptr )
+{
+	free( (char *) ptr );	/* see zconfrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+void zconf_starthelp(void)
+{
+	new_string();
+	last_ts = first_ts = 0;
+	BEGIN(HELP);
+}
+
+static void zconf_endhelp(void)
+{
+	zconflval.string = text;
+	BEGIN(INITIAL);
+}
+
+/*
+ * Try to open specified file with following names:
+ * ./name
+ * $(srctree)/name
+ * The latter is used when srctree is separate from objtree
+ * when compiling the kernel.
+ * Return NULL if file is not found.
+ */
+FILE *zconf_fopen(const char *name)
+{
+	char *env, fullname[PATH_MAX+1];
+	FILE *f;
+
+	f = fopen(name, "r");
+	if (!f && name != NULL && name[0] != '/') {
+		env = getenv(SRCTREE);
+		if (env) {
+			sprintf(fullname, "%s/%s", env, name);
+			f = fopen(fullname, "r");
+		}
+	}
+	return f;
+}
+
+void zconf_initscan(const char *name)
+{
+	zconfin = zconf_fopen(name);
+	if (!zconfin) {
+		printf("can't find file %s\n", name);
+		exit(1);
+	}
+
+	current_buf = malloc(sizeof(*current_buf));
+	memset(current_buf, 0, sizeof(*current_buf));
+
+	current_file = file_lookup(name);
+	current_file->lineno = 1;
+}
+
+void zconf_nextfile(const char *name)
+{
+	struct file *iter;
+	struct file *file = file_lookup(name);
+	struct buffer *buf = malloc(sizeof(*buf));
+	memset(buf, 0, sizeof(*buf));
+
+	current_buf->state = YY_CURRENT_BUFFER;
+	zconfin = zconf_fopen(file->name);
+	if (!zconfin) {
+		printf("%s:%d: can't open file \"%s\"\n",
+		    zconf_curname(), zconf_lineno(), file->name);
+		exit(1);
+	}
+	zconf_switch_to_buffer(zconf_create_buffer(zconfin,YY_BUF_SIZE));
+	buf->parent = current_buf;
+	current_buf = buf;
+
+	for (iter = current_file->parent; iter; iter = iter->parent ) {
+		if (!strcmp(current_file->name,iter->name) ) {
+			printf("%s:%d: recursive inclusion detected. "
+			       "Inclusion path:\n  current file : '%s'\n",
+			       zconf_curname(), zconf_lineno(),
+			       zconf_curname());
+			iter = current_file->parent;
+			while (iter && \
+			       strcmp(iter->name,current_file->name)) {
+				printf("  included from: '%s:%d'\n",
+				       iter->name, iter->lineno-1);
+				iter = iter->parent;
+			}
+			if (iter)
+				printf("  included from: '%s:%d'\n",
+				       iter->name, iter->lineno+1);
+			exit(1);
+		}
+	}
+	file->lineno = 1;
+	file->parent = current_file;
+	current_file = file;
+}
+
+static void zconf_endfile(void)
+{
+	struct buffer *parent;
+
+	current_file = current_file->parent;
+
+	parent = current_buf->parent;
+	if (parent) {
+		fclose(zconfin);
+		zconf_delete_buffer(YY_CURRENT_BUFFER);
+		zconf_switch_to_buffer(parent->state);
+	}
+	free(current_buf);
+	current_buf = parent;
+}
+
+int zconf_lineno(void)
+{
+	return current_pos.lineno;
+}
+
+const char *zconf_curname(void)
+{
+	return current_pos.file ? current_pos.file->name : "<none>";
+}
+
Binary files Kernel/scripts/kconfig/mconf and HelloWorld-Renew-v1.0-n7000-jb/scripts/kconfig/mconf differ
diff -urNp Kernel/scripts/kconfig/zconf.hash.c HelloWorld-Renew-v1.0-n7000-jb/scripts/kconfig/zconf.hash.c
--- Kernel/scripts/kconfig/zconf.hash.c	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/scripts/kconfig/zconf.hash.c	2013-04-29 16:58:27.234590314 +0200
@@ -0,0 +1,245 @@
+/* ANSI-C code produced by gperf version 3.0.3 */
+/* Command-line: gperf  */
+/* Computed positions: -k'1,3' */
+
+#if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
+      && ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) \
+      && (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) \
+      && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \
+      && ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) \
+      && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) \
+      && ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) \
+      && ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) \
+      && ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) \
+      && ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) \
+      && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) \
+      && ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) \
+      && ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) \
+      && ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) \
+      && ('Z' == 90) && ('[' == 91) && ('\\' == 92) && (']' == 93) \
+      && ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) \
+      && ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) \
+      && ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) \
+      && ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) \
+      && ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) \
+      && ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) \
+      && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \
+      && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))
+/* The character set is not based on ISO-646.  */
+#error "gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>."
+#endif
+
+struct kconf_id;
+
+static struct kconf_id *kconf_id_lookup(register const char *str, register unsigned int len);
+/* maximum key range = 50, duplicates = 0 */
+
+#ifdef __GNUC__
+__inline
+#else
+#ifdef __cplusplus
+inline
+#endif
+#endif
+static unsigned int
+kconf_id_hash (register const char *str, register unsigned int len)
+{
+  static unsigned char asso_values[] =
+    {
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 40,  5,
+       0,  0,  5, 52,  0, 20, 52, 52, 10, 20,
+       5,  0, 35, 52,  0, 30,  0, 15,  0, 52,
+      15, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
+      52, 52, 52, 52, 52, 52
+    };
+  register int hval = len;
+
+  switch (hval)
+    {
+      default:
+        hval += asso_values[(unsigned char)str[2]];
+      /*FALLTHROUGH*/
+      case 2:
+      case 1:
+        hval += asso_values[(unsigned char)str[0]];
+        break;
+    }
+  return hval;
+}
+
+struct kconf_id_strings_t
+  {
+    char kconf_id_strings_str2[sizeof("on")];
+    char kconf_id_strings_str3[sizeof("env")];
+    char kconf_id_strings_str5[sizeof("endif")];
+    char kconf_id_strings_str6[sizeof("option")];
+    char kconf_id_strings_str7[sizeof("endmenu")];
+    char kconf_id_strings_str8[sizeof("optional")];
+    char kconf_id_strings_str9[sizeof("endchoice")];
+    char kconf_id_strings_str10[sizeof("range")];
+    char kconf_id_strings_str11[sizeof("choice")];
+    char kconf_id_strings_str12[sizeof("default")];
+    char kconf_id_strings_str13[sizeof("def_bool")];
+    char kconf_id_strings_str14[sizeof("help")];
+    char kconf_id_strings_str16[sizeof("config")];
+    char kconf_id_strings_str17[sizeof("def_tristate")];
+    char kconf_id_strings_str18[sizeof("hex")];
+    char kconf_id_strings_str19[sizeof("defconfig_list")];
+    char kconf_id_strings_str22[sizeof("if")];
+    char kconf_id_strings_str23[sizeof("int")];
+    char kconf_id_strings_str27[sizeof("modules")];
+    char kconf_id_strings_str28[sizeof("tristate")];
+    char kconf_id_strings_str29[sizeof("menu")];
+    char kconf_id_strings_str32[sizeof("comment")];
+    char kconf_id_strings_str35[sizeof("menuconfig")];
+    char kconf_id_strings_str36[sizeof("string")];
+    char kconf_id_strings_str37[sizeof("visible")];
+    char kconf_id_strings_str41[sizeof("prompt")];
+    char kconf_id_strings_str42[sizeof("depends")];
+    char kconf_id_strings_str44[sizeof("bool")];
+    char kconf_id_strings_str46[sizeof("select")];
+    char kconf_id_strings_str47[sizeof("boolean")];
+    char kconf_id_strings_str48[sizeof("mainmenu")];
+    char kconf_id_strings_str51[sizeof("source")];
+  };
+static struct kconf_id_strings_t kconf_id_strings_contents =
+  {
+    "on",
+    "env",
+    "endif",
+    "option",
+    "endmenu",
+    "optional",
+    "endchoice",
+    "range",
+    "choice",
+    "default",
+    "def_bool",
+    "help",
+    "config",
+    "def_tristate",
+    "hex",
+    "defconfig_list",
+    "if",
+    "int",
+    "modules",
+    "tristate",
+    "menu",
+    "comment",
+    "menuconfig",
+    "string",
+    "visible",
+    "prompt",
+    "depends",
+    "bool",
+    "select",
+    "boolean",
+    "mainmenu",
+    "source"
+  };
+#define kconf_id_strings ((const char *) &kconf_id_strings_contents)
+#ifdef __GNUC__
+__inline
+#ifdef __GNUC_STDC_INLINE__
+__attribute__ ((__gnu_inline__))
+#endif
+#endif
+struct kconf_id *
+kconf_id_lookup (register const char *str, register unsigned int len)
+{
+  enum
+    {
+      TOTAL_KEYWORDS = 32,
+      MIN_WORD_LENGTH = 2,
+      MAX_WORD_LENGTH = 14,
+      MIN_HASH_VALUE = 2,
+      MAX_HASH_VALUE = 51
+    };
+
+  static struct kconf_id wordlist[] =
+    {
+      {-1}, {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str2,		T_ON,		TF_PARAM},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str3,		T_OPT_ENV,	TF_OPTION},
+      {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str5,		T_ENDIF,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str6,		T_OPTION,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str7,	T_ENDMENU,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str8,	T_OPTIONAL,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str9,	T_ENDCHOICE,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str10,		T_RANGE,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str11,		T_CHOICE,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str12,	T_DEFAULT,	TF_COMMAND, S_UNKNOWN},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str13,	T_DEFAULT,	TF_COMMAND, S_BOOLEAN},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str14,		T_HELP,		TF_COMMAND},
+      {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str16,		T_CONFIG,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str17,	T_DEFAULT,	TF_COMMAND, S_TRISTATE},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str18,		T_TYPE,		TF_COMMAND, S_HEX},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str19,	T_OPT_DEFCONFIG_LIST,TF_OPTION},
+      {-1}, {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str22,		T_IF,		TF_COMMAND|TF_PARAM},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str23,		T_TYPE,		TF_COMMAND, S_INT},
+      {-1}, {-1}, {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str27,	T_OPT_MODULES,	TF_OPTION},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str28,	T_TYPE,		TF_COMMAND, S_TRISTATE},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str29,		T_MENU,		TF_COMMAND},
+      {-1}, {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str32,	T_COMMENT,	TF_COMMAND},
+      {-1}, {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str35,	T_MENUCONFIG,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str36,		T_TYPE,		TF_COMMAND, S_STRING},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str37,	T_VISIBLE,	TF_COMMAND},
+      {-1}, {-1}, {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str41,		T_PROMPT,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str42,	T_DEPENDS,	TF_COMMAND},
+      {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str44,		T_TYPE,		TF_COMMAND, S_BOOLEAN},
+      {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str46,		T_SELECT,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str47,	T_TYPE,		TF_COMMAND, S_BOOLEAN},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str48,	T_MAINMENU,	TF_COMMAND},
+      {-1}, {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str51,		T_SOURCE,	TF_COMMAND}
+    };
+
+  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
+    {
+      register int key = kconf_id_hash (str, len);
+
+      if (key <= MAX_HASH_VALUE && key >= 0)
+        {
+          register int o = wordlist[key].name;
+          if (o >= 0)
+            {
+              register const char *s = o + kconf_id_strings;
+
+              if (*str == *s && !strncmp (str + 1, s + 1, len - 1) && s[len] == '\0')
+                return &wordlist[key];
+            }
+        }
+    }
+  return 0;
+}
+
diff -urNp Kernel/scripts/kconfig/zconf.tab.c HelloWorld-Renew-v1.0-n7000-jb/scripts/kconfig/zconf.tab.c
--- Kernel/scripts/kconfig/zconf.tab.c	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/scripts/kconfig/zconf.tab.c	2013-04-29 16:58:27.234590314 +0200
@@ -0,0 +1,2505 @@
+
+/* A Bison parser, made by GNU Bison 2.4.1.  */
+
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.4.1"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+/* Substitute the variable and function names.  */
+#define yyparse         zconfparse
+#define yylex           zconflex
+#define yyerror         zconferror
+#define yylval          zconflval
+#define yychar          zconfchar
+#define yydebug         zconfdebug
+#define yynerrs         zconfnerrs
+
+
+/* Copy the first part of user declarations.  */
+
+
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <ctype.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+
+#define printd(mask, fmt...) if (cdebug & (mask)) printf(fmt)
+
+#define PRINTD		0x0001
+#define DEBUG_PARSE	0x0002
+
+int cdebug = PRINTD;
+
+extern int zconflex(void);
+static void zconfprint(const char *err, ...);
+static void zconf_error(const char *err, ...);
+static void zconferror(const char *err);
+static bool zconf_endtoken(struct kconf_id *id, int starttoken, int endtoken);
+
+struct symbol *symbol_hash[SYMBOL_HASHSIZE];
+
+static struct menu *current_menu, *current_entry;
+
+#define YYDEBUG 0
+#if YYDEBUG
+#define YYERROR_VERBOSE
+#endif
+
+
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     T_MAINMENU = 258,
+     T_MENU = 259,
+     T_ENDMENU = 260,
+     T_SOURCE = 261,
+     T_CHOICE = 262,
+     T_ENDCHOICE = 263,
+     T_COMMENT = 264,
+     T_CONFIG = 265,
+     T_MENUCONFIG = 266,
+     T_HELP = 267,
+     T_HELPTEXT = 268,
+     T_IF = 269,
+     T_ENDIF = 270,
+     T_DEPENDS = 271,
+     T_OPTIONAL = 272,
+     T_PROMPT = 273,
+     T_TYPE = 274,
+     T_DEFAULT = 275,
+     T_SELECT = 276,
+     T_RANGE = 277,
+     T_VISIBLE = 278,
+     T_OPTION = 279,
+     T_ON = 280,
+     T_WORD = 281,
+     T_WORD_QUOTE = 282,
+     T_UNEQUAL = 283,
+     T_CLOSE_PAREN = 284,
+     T_OPEN_PAREN = 285,
+     T_EOL = 286,
+     T_OR = 287,
+     T_AND = 288,
+     T_EQUAL = 289,
+     T_NOT = 290
+   };
+#endif
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+
+	char *string;
+	struct file *file;
+	struct symbol *symbol;
+	struct expr *expr;
+	struct menu *menu;
+	struct kconf_id *id;
+
+
+
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Include zconf.hash.c here so it can see the token constants. */
+#include "zconf.hash.c"
+
+
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int yyi)
+#else
+static int
+YYID (yyi)
+    int yyi;
+#endif
+{
+  return yyi;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (YYID (0))
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
+	Stack = &yyptr->Stack_alloc;					\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  11
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   290
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  36
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  50
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  118
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  191
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   290
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint16 yyprhs[] =
+{
+       0,     0,     3,     6,     8,    11,    13,    14,    17,    20,
+      23,    26,    31,    36,    40,    42,    44,    46,    48,    50,
+      52,    54,    56,    58,    60,    62,    64,    66,    68,    72,
+      75,    79,    82,    86,    89,    90,    93,    96,    99,   102,
+     105,   108,   112,   117,   122,   127,   133,   137,   138,   142,
+     143,   146,   150,   153,   155,   159,   160,   163,   166,   169,
+     172,   175,   180,   184,   187,   192,   193,   196,   200,   202,
+     206,   207,   210,   213,   216,   220,   224,   228,   230,   234,
+     235,   238,   241,   244,   248,   252,   255,   258,   261,   262,
+     265,   268,   271,   276,   277,   280,   283,   286,   287,   290,
+     292,   294,   297,   300,   303,   305,   308,   309,   312,   314,
+     318,   322,   326,   329,   333,   337,   339,   341,   342
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
+{
+      37,     0,    -1,    81,    38,    -1,    38,    -1,    63,    39,
+      -1,    39,    -1,    -1,    39,    41,    -1,    39,    55,    -1,
+      39,    67,    -1,    39,    80,    -1,    39,    26,     1,    31,
+      -1,    39,    40,     1,    31,    -1,    39,     1,    31,    -1,
+      16,    -1,    18,    -1,    19,    -1,    21,    -1,    17,    -1,
+      22,    -1,    20,    -1,    23,    -1,    31,    -1,    61,    -1,
+      71,    -1,    44,    -1,    46,    -1,    69,    -1,    26,     1,
+      31,    -1,     1,    31,    -1,    10,    26,    31,    -1,    43,
+      47,    -1,    11,    26,    31,    -1,    45,    47,    -1,    -1,
+      47,    48,    -1,    47,    49,    -1,    47,    75,    -1,    47,
+      73,    -1,    47,    42,    -1,    47,    31,    -1,    19,    78,
+      31,    -1,    18,    79,    82,    31,    -1,    20,    83,    82,
+      31,    -1,    21,    26,    82,    31,    -1,    22,    84,    84,
+      82,    31,    -1,    24,    50,    31,    -1,    -1,    50,    26,
+      51,    -1,    -1,    34,    79,    -1,     7,    85,    31,    -1,
+      52,    56,    -1,    80,    -1,    53,    58,    54,    -1,    -1,
+      56,    57,    -1,    56,    75,    -1,    56,    73,    -1,    56,
+      31,    -1,    56,    42,    -1,    18,    79,    82,    31,    -1,
+      19,    78,    31,    -1,    17,    31,    -1,    20,    26,    82,
+      31,    -1,    -1,    58,    41,    -1,    14,    83,    81,    -1,
+      80,    -1,    59,    62,    60,    -1,    -1,    62,    41,    -1,
+      62,    67,    -1,    62,    55,    -1,     3,    79,    81,    -1,
+       4,    79,    31,    -1,    64,    76,    74,    -1,    80,    -1,
+      65,    68,    66,    -1,    -1,    68,    41,    -1,    68,    67,
+      -1,    68,    55,    -1,     6,    79,    31,    -1,     9,    79,
+      31,    -1,    70,    74,    -1,    12,    31,    -1,    72,    13,
+      -1,    -1,    74,    75,    -1,    74,    31,    -1,    74,    42,
+      -1,    16,    25,    83,    31,    -1,    -1,    76,    77,    -1,
+      76,    31,    -1,    23,    82,    -1,    -1,    79,    82,    -1,
+      26,    -1,    27,    -1,     5,    31,    -1,     8,    31,    -1,
+      15,    31,    -1,    31,    -1,    81,    31,    -1,    -1,    14,
+      83,    -1,    84,    -1,    84,    34,    84,    -1,    84,    28,
+      84,    -1,    30,    83,    29,    -1,    35,    83,    -1,    83,
+      32,    83,    -1,    83,    33,    83,    -1,    26,    -1,    27,
+      -1,    -1,    26,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint16 yyrline[] =
+{
+       0,   108,   108,   108,   110,   110,   112,   114,   115,   116,
+     117,   118,   119,   123,   127,   127,   127,   127,   127,   127,
+     127,   127,   131,   132,   133,   134,   135,   136,   140,   141,
+     147,   155,   161,   169,   179,   181,   182,   183,   184,   185,
+     186,   189,   197,   203,   213,   219,   225,   228,   230,   241,
+     242,   247,   256,   261,   269,   272,   274,   275,   276,   277,
+     278,   281,   287,   298,   304,   314,   316,   321,   329,   337,
+     340,   342,   343,   344,   349,   356,   363,   368,   376,   379,
+     381,   382,   383,   386,   394,   401,   408,   414,   421,   423,
+     424,   425,   428,   436,   438,   439,   442,   449,   451,   456,
+     457,   460,   461,   462,   466,   467,   470,   471,   474,   475,
+     476,   477,   478,   479,   480,   483,   484,   487,   488
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "T_MAINMENU", "T_MENU", "T_ENDMENU",
+  "T_SOURCE", "T_CHOICE", "T_ENDCHOICE", "T_COMMENT", "T_CONFIG",
+  "T_MENUCONFIG", "T_HELP", "T_HELPTEXT", "T_IF", "T_ENDIF", "T_DEPENDS",
+  "T_OPTIONAL", "T_PROMPT", "T_TYPE", "T_DEFAULT", "T_SELECT", "T_RANGE",
+  "T_VISIBLE", "T_OPTION", "T_ON", "T_WORD", "T_WORD_QUOTE", "T_UNEQUAL",
+  "T_CLOSE_PAREN", "T_OPEN_PAREN", "T_EOL", "T_OR", "T_AND", "T_EQUAL",
+  "T_NOT", "$accept", "input", "start", "stmt_list", "option_name",
+  "common_stmt", "option_error", "config_entry_start", "config_stmt",
+  "menuconfig_entry_start", "menuconfig_stmt", "config_option_list",
+  "config_option", "symbol_option", "symbol_option_list",
+  "symbol_option_arg", "choice", "choice_entry", "choice_end",
+  "choice_stmt", "choice_option_list", "choice_option", "choice_block",
+  "if_entry", "if_end", "if_stmt", "if_block", "mainmenu_stmt", "menu",
+  "menu_entry", "menu_end", "menu_stmt", "menu_block", "source_stmt",
+  "comment", "comment_stmt", "help_start", "help", "depends_list",
+  "depends", "visibility_list", "visible", "prompt_stmt_opt", "prompt",
+  "end", "nl", "if_expr", "expr", "symbol", "word_opt", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289,   290
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    36,    37,    37,    38,    38,    39,    39,    39,    39,
+      39,    39,    39,    39,    40,    40,    40,    40,    40,    40,
+      40,    40,    41,    41,    41,    41,    41,    41,    42,    42,
+      43,    44,    45,    46,    47,    47,    47,    47,    47,    47,
+      47,    48,    48,    48,    48,    48,    49,    50,    50,    51,
+      51,    52,    53,    54,    55,    56,    56,    56,    56,    56,
+      56,    57,    57,    57,    57,    58,    58,    59,    60,    61,
+      62,    62,    62,    62,    63,    64,    65,    66,    67,    68,
+      68,    68,    68,    69,    70,    71,    72,    73,    74,    74,
+      74,    74,    75,    76,    76,    76,    77,    78,    78,    79,
+      79,    80,    80,    80,    81,    81,    82,    82,    83,    83,
+      83,    83,    83,    83,    83,    84,    84,    85,    85
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     2,     1,     2,     1,     0,     2,     2,     2,
+       2,     4,     4,     3,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     3,     2,
+       3,     2,     3,     2,     0,     2,     2,     2,     2,     2,
+       2,     3,     4,     4,     4,     5,     3,     0,     3,     0,
+       2,     3,     2,     1,     3,     0,     2,     2,     2,     2,
+       2,     4,     3,     2,     4,     0,     2,     3,     1,     3,
+       0,     2,     2,     2,     3,     3,     3,     1,     3,     0,
+       2,     2,     2,     3,     3,     2,     2,     2,     0,     2,
+       2,     2,     4,     0,     2,     2,     2,     0,     2,     1,
+       1,     2,     2,     2,     1,     2,     0,     2,     1,     3,
+       3,     3,     2,     3,     3,     1,     1,     0,     1
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       6,     0,   104,     0,     3,     0,     6,     6,    99,   100,
+       0,     1,     0,     0,     0,     0,   117,     0,     0,     0,
+       0,     0,     0,    14,    18,    15,    16,    20,    17,    19,
+      21,     0,    22,     0,     7,    34,    25,    34,    26,    55,
+      65,     8,    70,    23,    93,    79,     9,    27,    88,    24,
+      10,     0,   105,     2,    74,    13,     0,   101,     0,   118,
+       0,   102,     0,     0,     0,   115,   116,     0,     0,     0,
+     108,   103,     0,     0,     0,     0,     0,     0,     0,    88,
+       0,     0,    75,    83,    51,    84,    30,    32,     0,   112,
+       0,     0,    67,     0,     0,    11,    12,     0,     0,     0,
+       0,    97,     0,     0,     0,    47,     0,    40,    39,    35,
+      36,     0,    38,    37,     0,     0,    97,     0,    59,    60,
+      56,    58,    57,    66,    54,    53,    71,    73,    69,    72,
+      68,   106,    95,     0,    94,    80,    82,    78,    81,    77,
+      90,    91,    89,   111,   113,   114,   110,   109,    29,    86,
+       0,   106,     0,   106,   106,   106,     0,     0,     0,    87,
+      63,   106,     0,   106,     0,    96,     0,     0,    41,    98,
+       0,     0,   106,    49,    46,    28,     0,    62,     0,   107,
+      92,    42,    43,    44,     0,     0,    48,    61,    64,    45,
+      50
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int16 yydefgoto[] =
+{
+      -1,     3,     4,     5,    33,    34,   108,    35,    36,    37,
+      38,    74,   109,   110,   157,   186,    39,    40,   124,    41,
+      76,   120,    77,    42,   128,    43,    78,     6,    44,    45,
+     137,    46,    80,    47,    48,    49,   111,   112,    81,   113,
+      79,   134,   152,   153,    50,     7,   165,    69,    70,    60
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -90
+static const yytype_int16 yypact[] =
+{
+       4,    42,   -90,    96,   -90,   111,   -90,    15,   -90,   -90,
+      75,   -90,    82,    42,   104,    42,   110,   107,    42,   115,
+     125,    -4,   121,   -90,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   162,   -90,   163,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   139,   -90,   -90,   138,   -90,   142,   -90,   143,   -90,
+     152,   -90,   164,   167,   168,   -90,   -90,    -4,    -4,    77,
+     -18,   -90,   177,   185,    33,    71,   195,   247,   236,    -2,
+     236,   171,   -90,   -90,   -90,   -90,   -90,   -90,    41,   -90,
+      -4,    -4,   138,    97,    97,   -90,   -90,   186,   187,   194,
+      42,    42,    -4,   196,    97,   -90,   219,   -90,   -90,   -90,
+     -90,   210,   -90,   -90,   204,    42,    42,   199,   -90,   -90,
+     -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   222,   -90,   223,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   -90,   -90,   -90,   215,   -90,   -90,   -90,   -90,   -90,
+      -4,   222,   228,   222,    -5,   222,    97,    35,   229,   -90,
+     -90,   222,   232,   222,    -4,   -90,   135,   233,   -90,   -90,
+     234,   235,   222,   240,   -90,   -90,   237,   -90,   239,   -13,
+     -90,   -90,   -90,   -90,   244,    42,   -90,   -90,   -90,   -90,
+     -90
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int16 yypgoto[] =
+{
+     -90,   -90,   269,   271,   -90,    23,   -70,   -90,   -90,   -90,
+     -90,   243,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -48,
+     -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   -20,   -90,   -90,   -90,   -90,   -90,   206,   205,   -68,
+     -90,   -90,   169,    -1,    27,    -7,   118,   -66,   -89,   -90
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -86
+static const yytype_int16 yytable[] =
+{
+      10,    88,    89,    54,   146,   147,   119,     1,   122,   164,
+      93,   141,    56,   142,    58,   156,    94,    62,     1,    90,
+      91,   131,    65,    66,   144,   145,    67,    90,    91,   132,
+     127,    68,   136,   -31,    97,     2,   154,   -31,   -31,   -31,
+     -31,   -31,   -31,   -31,   -31,    98,    52,   -31,   -31,    99,
+     -31,   100,   101,   102,   103,   104,   -31,   105,   129,   106,
+     138,   173,    92,   141,   107,   142,   174,   172,     8,     9,
+     143,   -33,    97,    90,    91,   -33,   -33,   -33,   -33,   -33,
+     -33,   -33,   -33,    98,   166,   -33,   -33,    99,   -33,   100,
+     101,   102,   103,   104,   -33,   105,    11,   106,   179,   151,
+     123,   126,   107,   135,   125,   130,     2,   139,     2,    90,
+      91,    -5,    12,    55,   161,    13,    14,    15,    16,    17,
+      18,    19,    20,    65,    66,    21,    22,    23,    24,    25,
+      26,    27,    28,    29,    30,    57,    59,    31,    61,    -4,
+      12,    63,    32,    13,    14,    15,    16,    17,    18,    19,
+      20,    64,    71,    21,    22,    23,    24,    25,    26,    27,
+      28,    29,    30,    72,    73,    31,   180,    90,    91,    52,
+      32,   -85,    97,    82,    83,   -85,   -85,   -85,   -85,   -85,
+     -85,   -85,   -85,    84,   190,   -85,   -85,    99,   -85,   -85,
+     -85,   -85,   -85,   -85,   -85,    85,    97,   106,    86,    87,
+     -52,   -52,   140,   -52,   -52,   -52,   -52,    98,    95,   -52,
+     -52,    99,   114,   115,   116,   117,    96,   148,   149,   150,
+     158,   106,   155,   159,    97,   163,   118,   -76,   -76,   -76,
+     -76,   -76,   -76,   -76,   -76,   160,   164,   -76,   -76,    99,
+      13,    14,    15,    16,    17,    18,    19,    20,    91,   106,
+      21,    22,    14,    15,   140,    17,    18,    19,    20,   168,
+     175,    21,    22,   177,   181,   182,   183,    32,   187,   167,
+     188,   169,   170,   171,   185,   189,    53,    51,    32,   176,
+      75,   178,   121,     0,   133,   162,     0,     0,     0,     0,
+     184
+};
+
+static const yytype_int16 yycheck[] =
+{
+       1,    67,    68,    10,    93,    94,    76,     3,    76,    14,
+      28,    81,    13,    81,    15,   104,    34,    18,     3,    32,
+      33,    23,    26,    27,    90,    91,    30,    32,    33,    31,
+      78,    35,    80,     0,     1,    31,   102,     4,     5,     6,
+       7,     8,     9,    10,    11,    12,    31,    14,    15,    16,
+      17,    18,    19,    20,    21,    22,    23,    24,    78,    26,
+      80,    26,    69,   133,    31,   133,    31,   156,    26,    27,
+      29,     0,     1,    32,    33,     4,     5,     6,     7,     8,
+       9,    10,    11,    12,   150,    14,    15,    16,    17,    18,
+      19,    20,    21,    22,    23,    24,     0,    26,   164,   100,
+      77,    78,    31,    80,    77,    78,    31,    80,    31,    32,
+      33,     0,     1,    31,   115,     4,     5,     6,     7,     8,
+       9,    10,    11,    26,    27,    14,    15,    16,    17,    18,
+      19,    20,    21,    22,    23,    31,    26,    26,    31,     0,
+       1,    26,    31,     4,     5,     6,     7,     8,     9,    10,
+      11,    26,    31,    14,    15,    16,    17,    18,    19,    20,
+      21,    22,    23,     1,     1,    26,    31,    32,    33,    31,
+      31,     0,     1,    31,    31,     4,     5,     6,     7,     8,
+       9,    10,    11,    31,   185,    14,    15,    16,    17,    18,
+      19,    20,    21,    22,    23,    31,     1,    26,    31,    31,
+       5,     6,    31,     8,     9,    10,    11,    12,    31,    14,
+      15,    16,    17,    18,    19,    20,    31,    31,    31,    25,
+       1,    26,    26,    13,     1,    26,    31,     4,     5,     6,
+       7,     8,     9,    10,    11,    31,    14,    14,    15,    16,
+       4,     5,     6,     7,     8,     9,    10,    11,    33,    26,
+      14,    15,     5,     6,    31,     8,     9,    10,    11,    31,
+      31,    14,    15,    31,    31,    31,    31,    31,    31,   151,
+      31,   153,   154,   155,    34,    31,     7,     6,    31,   161,
+      37,   163,    76,    -1,    79,   116,    -1,    -1,    -1,    -1,
+     172
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,     3,    31,    37,    38,    39,    63,    81,    26,    27,
+      79,     0,     1,     4,     5,     6,     7,     8,     9,    10,
+      11,    14,    15,    16,    17,    18,    19,    20,    21,    22,
+      23,    26,    31,    40,    41,    43,    44,    45,    46,    52,
+      53,    55,    59,    61,    64,    65,    67,    69,    70,    71,
+      80,    39,    31,    38,    81,    31,    79,    31,    79,    26,
+      85,    31,    79,    26,    26,    26,    27,    30,    35,    83,
+      84,    31,     1,     1,    47,    47,    56,    58,    62,    76,
+      68,    74,    31,    31,    31,    31,    31,    31,    83,    83,
+      32,    33,    81,    28,    34,    31,    31,     1,    12,    16,
+      18,    19,    20,    21,    22,    24,    26,    31,    42,    48,
+      49,    72,    73,    75,    17,    18,    19,    20,    31,    42,
+      57,    73,    75,    41,    54,    80,    41,    55,    60,    67,
+      80,    23,    31,    74,    77,    41,    55,    66,    67,    80,
+      31,    42,    75,    29,    83,    83,    84,    84,    31,    31,
+      25,    79,    78,    79,    83,    26,    84,    50,     1,    13,
+      31,    79,    78,    26,    14,    82,    83,    82,    31,    82,
+      82,    82,    84,    26,    31,    31,    82,    31,    82,    83,
+      31,    31,    31,    31,    82,    34,    51,    31,    31,    31,
+      79
+};
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+
+#define YYFAIL		goto yyerrlab
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK (1);						\
+      goto yybackup;						\
+    }								\
+  else								\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (YYID (0))
+
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
+#endif
+
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
+#else
+# define YYLEX yylex ()
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+#else
+static void
+yy_stack_print (yybottom, yytop)
+    yytype_int16 *yybottom;
+    yytype_int16 *yytop;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
+    int yyrule;
+#endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static YYSIZE_T
+yystrlen (const char *yystr)
+#else
+static YYSIZE_T
+yystrlen (yystr)
+    const char *yystr;
+#endif
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+#else
+static char *
+yystpcpy (yydest, yysrc)
+    char *yydest;
+    const char *yysrc;
+#endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
+{
+  int yyn = yypact[yystate];
+
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+# endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
+}
+#endif /* YYERROR_VERBOSE */
+
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+      case 53: /* "choice_entry" */
+
+	{
+	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+	if (current_menu == (yyvaluep->menu))
+		menu_end_menu();
+};
+
+	break;
+      case 59: /* "if_entry" */
+
+	{
+	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+	if (current_menu == (yyvaluep->menu))
+		menu_end_menu();
+};
+
+	break;
+      case 65: /* "menu_entry" */
+
+	{
+	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+	if (current_menu == (yyvaluep->menu))
+		menu_end_menu();
+};
+
+	break;
+
+      default:
+	break;
+    }
+}
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+
+/*-------------------------.
+| yyparse or yypush_parse.  |
+`-------------------------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
+#endif
+{
+
+
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       `yyss': related to states.
+       `yyvs': related to semantic values.
+
+       Refer to the stacks thru separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yytoken = 0;
+  yyss = yyssa;
+  yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack.  Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	yytype_int16 *yyss1 = yyss;
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	yytype_int16 *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss_alloc, yyss);
+	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  *++yyvsp = yylval;
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 10:
+
+    { zconf_error("unexpected end statement"); ;}
+    break;
+
+  case 11:
+
+    { zconf_error("unknown statement \"%s\"", (yyvsp[(2) - (4)].string)); ;}
+    break;
+
+  case 12:
+
+    {
+	zconf_error("unexpected option \"%s\"", kconf_id_strings + (yyvsp[(2) - (4)].id)->name);
+;}
+    break;
+
+  case 13:
+
+    { zconf_error("invalid statement"); ;}
+    break;
+
+  case 28:
+
+    { zconf_error("unknown option \"%s\"", (yyvsp[(1) - (3)].string)); ;}
+    break;
+
+  case 29:
+
+    { zconf_error("invalid option"); ;}
+    break;
+
+  case 30:
+
+    {
+	struct symbol *sym = sym_lookup((yyvsp[(2) - (3)].string), 0);
+	sym->flags |= SYMBOL_OPTIONAL;
+	menu_add_entry(sym);
+	printd(DEBUG_PARSE, "%s:%d:config %s\n", zconf_curname(), zconf_lineno(), (yyvsp[(2) - (3)].string));
+;}
+    break;
+
+  case 31:
+
+    {
+	menu_end_entry();
+	printd(DEBUG_PARSE, "%s:%d:endconfig\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 32:
+
+    {
+	struct symbol *sym = sym_lookup((yyvsp[(2) - (3)].string), 0);
+	sym->flags |= SYMBOL_OPTIONAL;
+	menu_add_entry(sym);
+	printd(DEBUG_PARSE, "%s:%d:menuconfig %s\n", zconf_curname(), zconf_lineno(), (yyvsp[(2) - (3)].string));
+;}
+    break;
+
+  case 33:
+
+    {
+	if (current_entry->prompt)
+		current_entry->prompt->type = P_MENU;
+	else
+		zconfprint("warning: menuconfig statement without prompt");
+	menu_end_entry();
+	printd(DEBUG_PARSE, "%s:%d:endconfig\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 41:
+
+    {
+	menu_set_type((yyvsp[(1) - (3)].id)->stype);
+	printd(DEBUG_PARSE, "%s:%d:type(%u)\n",
+		zconf_curname(), zconf_lineno(),
+		(yyvsp[(1) - (3)].id)->stype);
+;}
+    break;
+
+  case 42:
+
+    {
+	menu_add_prompt(P_PROMPT, (yyvsp[(2) - (4)].string), (yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 43:
+
+    {
+	menu_add_expr(P_DEFAULT, (yyvsp[(2) - (4)].expr), (yyvsp[(3) - (4)].expr));
+	if ((yyvsp[(1) - (4)].id)->stype != S_UNKNOWN)
+		menu_set_type((yyvsp[(1) - (4)].id)->stype);
+	printd(DEBUG_PARSE, "%s:%d:default(%u)\n",
+		zconf_curname(), zconf_lineno(),
+		(yyvsp[(1) - (4)].id)->stype);
+;}
+    break;
+
+  case 44:
+
+    {
+	menu_add_symbol(P_SELECT, sym_lookup((yyvsp[(2) - (4)].string), 0), (yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:select\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 45:
+
+    {
+	menu_add_expr(P_RANGE, expr_alloc_comp(E_RANGE,(yyvsp[(2) - (5)].symbol), (yyvsp[(3) - (5)].symbol)), (yyvsp[(4) - (5)].expr));
+	printd(DEBUG_PARSE, "%s:%d:range\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 48:
+
+    {
+	struct kconf_id *id = kconf_id_lookup((yyvsp[(2) - (3)].string), strlen((yyvsp[(2) - (3)].string)));
+	if (id && id->flags & TF_OPTION)
+		menu_add_option(id->token, (yyvsp[(3) - (3)].string));
+	else
+		zconfprint("warning: ignoring unknown option %s", (yyvsp[(2) - (3)].string));
+	free((yyvsp[(2) - (3)].string));
+;}
+    break;
+
+  case 49:
+
+    { (yyval.string) = NULL; ;}
+    break;
+
+  case 50:
+
+    { (yyval.string) = (yyvsp[(2) - (2)].string); ;}
+    break;
+
+  case 51:
+
+    {
+	struct symbol *sym = sym_lookup((yyvsp[(2) - (3)].string), SYMBOL_CHOICE);
+	sym->flags |= SYMBOL_AUTO;
+	menu_add_entry(sym);
+	menu_add_expr(P_CHOICE, NULL, NULL);
+	printd(DEBUG_PARSE, "%s:%d:choice\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 52:
+
+    {
+	(yyval.menu) = menu_add_menu();
+;}
+    break;
+
+  case 53:
+
+    {
+	if (zconf_endtoken((yyvsp[(1) - (1)].id), T_CHOICE, T_ENDCHOICE)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endchoice\n", zconf_curname(), zconf_lineno());
+	}
+;}
+    break;
+
+  case 61:
+
+    {
+	menu_add_prompt(P_PROMPT, (yyvsp[(2) - (4)].string), (yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 62:
+
+    {
+	if ((yyvsp[(1) - (3)].id)->stype == S_BOOLEAN || (yyvsp[(1) - (3)].id)->stype == S_TRISTATE) {
+		menu_set_type((yyvsp[(1) - (3)].id)->stype);
+		printd(DEBUG_PARSE, "%s:%d:type(%u)\n",
+			zconf_curname(), zconf_lineno(),
+			(yyvsp[(1) - (3)].id)->stype);
+	} else
+		YYERROR;
+;}
+    break;
+
+  case 63:
+
+    {
+	current_entry->sym->flags |= SYMBOL_OPTIONAL;
+	printd(DEBUG_PARSE, "%s:%d:optional\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 64:
+
+    {
+	if ((yyvsp[(1) - (4)].id)->stype == S_UNKNOWN) {
+		menu_add_symbol(P_DEFAULT, sym_lookup((yyvsp[(2) - (4)].string), 0), (yyvsp[(3) - (4)].expr));
+		printd(DEBUG_PARSE, "%s:%d:default\n",
+			zconf_curname(), zconf_lineno());
+	} else
+		YYERROR;
+;}
+    break;
+
+  case 67:
+
+    {
+	printd(DEBUG_PARSE, "%s:%d:if\n", zconf_curname(), zconf_lineno());
+	menu_add_entry(NULL);
+	menu_add_dep((yyvsp[(2) - (3)].expr));
+	(yyval.menu) = menu_add_menu();
+;}
+    break;
+
+  case 68:
+
+    {
+	if (zconf_endtoken((yyvsp[(1) - (1)].id), T_IF, T_ENDIF)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endif\n", zconf_curname(), zconf_lineno());
+	}
+;}
+    break;
+
+  case 74:
+
+    {
+	menu_add_prompt(P_MENU, (yyvsp[(2) - (3)].string), NULL);
+;}
+    break;
+
+  case 75:
+
+    {
+	menu_add_entry(NULL);
+	menu_add_prompt(P_MENU, (yyvsp[(2) - (3)].string), NULL);
+	printd(DEBUG_PARSE, "%s:%d:menu\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 76:
+
+    {
+	(yyval.menu) = menu_add_menu();
+;}
+    break;
+
+  case 77:
+
+    {
+	if (zconf_endtoken((yyvsp[(1) - (1)].id), T_MENU, T_ENDMENU)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endmenu\n", zconf_curname(), zconf_lineno());
+	}
+;}
+    break;
+
+  case 83:
+
+    {
+	printd(DEBUG_PARSE, "%s:%d:source %s\n", zconf_curname(), zconf_lineno(), (yyvsp[(2) - (3)].string));
+	zconf_nextfile((yyvsp[(2) - (3)].string));
+;}
+    break;
+
+  case 84:
+
+    {
+	menu_add_entry(NULL);
+	menu_add_prompt(P_COMMENT, (yyvsp[(2) - (3)].string), NULL);
+	printd(DEBUG_PARSE, "%s:%d:comment\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 85:
+
+    {
+	menu_end_entry();
+;}
+    break;
+
+  case 86:
+
+    {
+	printd(DEBUG_PARSE, "%s:%d:help\n", zconf_curname(), zconf_lineno());
+	zconf_starthelp();
+;}
+    break;
+
+  case 87:
+
+    {
+	current_entry->help = (yyvsp[(2) - (2)].string);
+;}
+    break;
+
+  case 92:
+
+    {
+	menu_add_dep((yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:depends on\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 96:
+
+    {
+	menu_add_visibility((yyvsp[(2) - (2)].expr));
+;}
+    break;
+
+  case 98:
+
+    {
+	menu_add_prompt(P_PROMPT, (yyvsp[(1) - (2)].string), (yyvsp[(2) - (2)].expr));
+;}
+    break;
+
+  case 101:
+
+    { (yyval.id) = (yyvsp[(1) - (2)].id); ;}
+    break;
+
+  case 102:
+
+    { (yyval.id) = (yyvsp[(1) - (2)].id); ;}
+    break;
+
+  case 103:
+
+    { (yyval.id) = (yyvsp[(1) - (2)].id); ;}
+    break;
+
+  case 106:
+
+    { (yyval.expr) = NULL; ;}
+    break;
+
+  case 107:
+
+    { (yyval.expr) = (yyvsp[(2) - (2)].expr); ;}
+    break;
+
+  case 108:
+
+    { (yyval.expr) = expr_alloc_symbol((yyvsp[(1) - (1)].symbol)); ;}
+    break;
+
+  case 109:
+
+    { (yyval.expr) = expr_alloc_comp(E_EQUAL, (yyvsp[(1) - (3)].symbol), (yyvsp[(3) - (3)].symbol)); ;}
+    break;
+
+  case 110:
+
+    { (yyval.expr) = expr_alloc_comp(E_UNEQUAL, (yyvsp[(1) - (3)].symbol), (yyvsp[(3) - (3)].symbol)); ;}
+    break;
+
+  case 111:
+
+    { (yyval.expr) = (yyvsp[(2) - (3)].expr); ;}
+    break;
+
+  case 112:
+
+    { (yyval.expr) = expr_alloc_one(E_NOT, (yyvsp[(2) - (2)].expr)); ;}
+    break;
+
+  case 113:
+
+    { (yyval.expr) = expr_alloc_two(E_OR, (yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr)); ;}
+    break;
+
+  case 114:
+
+    { (yyval.expr) = expr_alloc_two(E_AND, (yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr)); ;}
+    break;
+
+  case 115:
+
+    { (yyval.symbol) = sym_lookup((yyvsp[(1) - (1)].string), 0); free((yyvsp[(1) - (1)].string)); ;}
+    break;
+
+  case 116:
+
+    { (yyval.symbol) = sym_lookup((yyvsp[(1) - (1)].string), SYMBOL_CONST); free((yyvsp[(1) - (1)].string)); ;}
+    break;
+
+  case 117:
+
+    { (yyval.string) = NULL; ;}
+    break;
+
+
+
+      default: break;
+    }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  *++yyvsp = yylval;
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined(yyoverflow) || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
+}
+
+
+
+
+
+void conf_parse(const char *name)
+{
+	struct symbol *sym;
+	int i;
+
+	zconf_initscan(name);
+
+	sym_init();
+	_menu_init();
+	modules_sym = sym_lookup(NULL, 0);
+	modules_sym->type = S_BOOLEAN;
+	modules_sym->flags |= SYMBOL_AUTO;
+	rootmenu.prompt = menu_add_prompt(P_MENU, "Linux Kernel Configuration", NULL);
+
+#if YYDEBUG
+	if (getenv("ZCONF_DEBUG"))
+		zconfdebug = 1;
+#endif
+	zconfparse();
+	if (zconfnerrs)
+		exit(1);
+	if (!modules_sym->prop) {
+		struct property *prop;
+
+		prop = prop_alloc(P_DEFAULT, modules_sym);
+		prop->expr = expr_alloc_symbol(sym_lookup("MODULES", 0));
+	}
+
+	rootmenu.prompt->text = _(rootmenu.prompt->text);
+	rootmenu.prompt->text = sym_expand_string_value(rootmenu.prompt->text);
+
+	menu_finalize(&rootmenu);
+	for_all_symbols(i, sym) {
+		if (sym_check_deps(sym))
+			zconfnerrs++;
+        }
+	if (zconfnerrs)
+		exit(1);
+	sym_set_change_count(1);
+}
+
+static const char *zconf_tokenname(int token)
+{
+	switch (token) {
+	case T_MENU:		return "menu";
+	case T_ENDMENU:		return "endmenu";
+	case T_CHOICE:		return "choice";
+	case T_ENDCHOICE:	return "endchoice";
+	case T_IF:		return "if";
+	case T_ENDIF:		return "endif";
+	case T_DEPENDS:		return "depends";
+	case T_VISIBLE:		return "visible";
+	}
+	return "<token>";
+}
+
+static bool zconf_endtoken(struct kconf_id *id, int starttoken, int endtoken)
+{
+	if (id->token != endtoken) {
+		zconf_error("unexpected '%s' within %s block",
+			kconf_id_strings + id->name, zconf_tokenname(starttoken));
+		zconfnerrs++;
+		return false;
+	}
+	if (current_menu->file != current_file) {
+		zconf_error("'%s' in different file than '%s'",
+			kconf_id_strings + id->name, zconf_tokenname(starttoken));
+		fprintf(stderr, "%s:%d: location of the '%s'\n",
+			current_menu->file->name, current_menu->lineno,
+			zconf_tokenname(starttoken));
+		zconfnerrs++;
+		return false;
+	}
+	return true;
+}
+
+static void zconfprint(const char *err, ...)
+{
+	va_list ap;
+
+	fprintf(stderr, "%s:%d: ", zconf_curname(), zconf_lineno());
+	va_start(ap, err);
+	vfprintf(stderr, err, ap);
+	va_end(ap);
+	fprintf(stderr, "\n");
+}
+
+static void zconf_error(const char *err, ...)
+{
+	va_list ap;
+
+	zconfnerrs++;
+	fprintf(stderr, "%s:%d: ", zconf_curname(), zconf_lineno());
+	va_start(ap, err);
+	vfprintf(stderr, err, ap);
+	va_end(ap);
+	fprintf(stderr, "\n");
+}
+
+static void zconferror(const char *err)
+{
+#if YYDEBUG
+	fprintf(stderr, "%s:%d: %s\n", zconf_curname(), zconf_lineno() + 1, err);
+#endif
+}
+
+static void print_quoted_string(FILE *out, const char *str)
+{
+	const char *p;
+	int len;
+
+	putc('"', out);
+	while ((p = strchr(str, '"'))) {
+		len = p - str;
+		if (len)
+			fprintf(out, "%.*s", len, str);
+		fputs("\\\"", out);
+		str = p + 1;
+	}
+	fputs(str, out);
+	putc('"', out);
+}
+
+static void print_symbol(FILE *out, struct menu *menu)
+{
+	struct symbol *sym = menu->sym;
+	struct property *prop;
+
+	if (sym_is_choice(sym))
+		fprintf(out, "\nchoice\n");
+	else
+		fprintf(out, "\nconfig %s\n", sym->name);
+	switch (sym->type) {
+	case S_BOOLEAN:
+		fputs("  boolean\n", out);
+		break;
+	case S_TRISTATE:
+		fputs("  tristate\n", out);
+		break;
+	case S_STRING:
+		fputs("  string\n", out);
+		break;
+	case S_INT:
+		fputs("  integer\n", out);
+		break;
+	case S_HEX:
+		fputs("  hex\n", out);
+		break;
+	default:
+		fputs("  ???\n", out);
+		break;
+	}
+	for (prop = sym->prop; prop; prop = prop->next) {
+		if (prop->menu != menu)
+			continue;
+		switch (prop->type) {
+		case P_PROMPT:
+			fputs("  prompt ", out);
+			print_quoted_string(out, prop->text);
+			if (!expr_is_yes(prop->visible.expr)) {
+				fputs(" if ", out);
+				expr_fprint(prop->visible.expr, out);
+			}
+			fputc('\n', out);
+			break;
+		case P_DEFAULT:
+			fputs( "  default ", out);
+			expr_fprint(prop->expr, out);
+			if (!expr_is_yes(prop->visible.expr)) {
+				fputs(" if ", out);
+				expr_fprint(prop->visible.expr, out);
+			}
+			fputc('\n', out);
+			break;
+		case P_CHOICE:
+			fputs("  #choice value\n", out);
+			break;
+		case P_SELECT:
+			fputs( "  select ", out);
+			expr_fprint(prop->expr, out);
+			fputc('\n', out);
+			break;
+		case P_RANGE:
+			fputs( "  range ", out);
+			expr_fprint(prop->expr, out);
+			fputc('\n', out);
+			break;
+		case P_MENU:
+			fputs( "  menu ", out);
+			print_quoted_string(out, prop->text);
+			fputc('\n', out);
+			break;
+		default:
+			fprintf(out, "  unknown prop %d!\n", prop->type);
+			break;
+		}
+	}
+	if (menu->help) {
+		int len = strlen(menu->help);
+		while (menu->help[--len] == '\n')
+			menu->help[len] = 0;
+		fprintf(out, "  help\n%s\n", menu->help);
+	}
+}
+
+void zconfdump(FILE *out)
+{
+	struct property *prop;
+	struct symbol *sym;
+	struct menu *menu;
+
+	menu = rootmenu.list;
+	while (menu) {
+		if ((sym = menu->sym))
+			print_symbol(out, menu);
+		else if ((prop = menu->prompt)) {
+			switch (prop->type) {
+			case P_COMMENT:
+				fputs("\ncomment ", out);
+				print_quoted_string(out, prop->text);
+				fputs("\n", out);
+				break;
+			case P_MENU:
+				fputs("\nmenu ", out);
+				print_quoted_string(out, prop->text);
+				fputs("\n", out);
+				break;
+			default:
+				;
+			}
+			if (!expr_is_yes(prop->visible.expr)) {
+				fputs("  depends ", out);
+				expr_fprint(prop->visible.expr, out);
+				fputc('\n', out);
+			}
+		}
+
+		if (menu->list)
+			menu = menu->list;
+		else if (menu->next)
+			menu = menu->next;
+		else while ((menu = menu->parent)) {
+			if (menu->prompt && menu->prompt->type == P_MENU)
+				fputs("\nendmenu\n", out);
+			if (menu->next) {
+				menu = menu->next;
+				break;
+			}
+		}
+	}
+}
+
+#include "lex.zconf.c"
+#include "util.c"
+#include "confdata.c"
+#include "expr.c"
+#include "symbol.c"
+#include "menu.c"
+
diff -urNp Kernel/scripts/Makefile.lto HelloWorld-Renew-v1.0-n7000-jb/scripts/Makefile.lto
--- Kernel/scripts/Makefile.lto	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/scripts/Makefile.lto	2013-04-29 16:41:35.170587461 +0200
@@ -0,0 +1,70 @@
+#
+# Support for gcc link time optimization
+#
+
+DISABLE_LTO :=
+LTO_CFLAGS :=
+
+export DISABLE_LTO
+export LTO_CFLAGS
+
+ifdef CONFIG_LTO
+ifeq ($(call cc-ifversion, -ge, 0407,y),y)
+ifneq ($(call cc-option,${LTO_CFLAGS},n),n)
+# We need HJ Lu's Linux binutils because mainline binutils does not
+# support mixing assembler and LTO code in the same ld -r object.
+# XXX check if the gcc plugin ld is the expected one too
+ifeq (y,y) #($(call ld-ifversion,-ge,222510001,y),y)
+# should use -flto=jobserver, but we need a fix for http://gcc.gnu.org/PR50639
+        LTO_CFLAGS := -flto -fno-toplevel-reorder
+        LTO_FINAL_CFLAGS := -fuse-linker-plugin -flto=$(shell getconf _NPROCESSORS_ONLN) -fno-toplevel-reorder
+ifdef CONFIG_LTO_SLIM
+	# requires plugin ar passed and very recent HJ binutils
+        LTO_CFLAGS += -fno-fat-lto-objects
+endif
+	DISABLE_LTO := -fno-lto
+
+	LTO_FINAL_CFLAGS += ${LTO_CFLAGS} -fwhole-program  
+
+	# workaround for http://gcc.gnu.org/PR50602
+	LTO_FINAL_CFLAGS += $(filter -freg-struct-return,${KBUILD_CFLAGS})
+
+ifdef CONFIG_LTO_DEBUG
+	LTO_FINAL_CFLAGS += -dH -fdump-ipa-cgraph -fdump-ipa-inline-details # -Wl,-plugin-save-temps -save-temps
+	LTO_CFLAGS += 
+endif
+
+	# In principle gcc should pass through options in the object files,
+	# but it doesn't always work. So do it here manually
+	LTO_FINAL_CFLAGS += $(filter -g%,${KBUILD_CFLAGS})
+	LTO_FINAL_CFLAGS += $(filter -O%,${KBUILD_CFLAGS})
+	LTO_FINAL_CFLAGS += $(filter -f%,${KBUILD_CFLAGS})
+	#LTO_FINAL_CFLAGS += $(filter -fno-omit-frame-pointer, ${KBUILD_CFLAGS})
+	#LTO_FINAL_CFLAGS += $(filter -fno-strict-aliasing, ${KBUILD_CFLAGS})
+	#LTO_FINAL_CFLAGS += $(filter -fno-delete-null-pointer-checks, ${KBUILD_CFLAGS})
+	#LTO_FINAL_CFLAGS += $(filter -fno-strict-overflow, ${KBUILD_CFLAGS})
+	LTO_FINAL_CFLAGS += $(filter -m%,${KBUILD_CFLAGS})
+	LTO_FINAL_CFLAGS += $(filter -W%,${KBUILD_CFLAGS})
+
+	KBUILD_CFLAGS += ${LTO_CFLAGS}
+
+	#
+	# Don't pass all flags to the optimization stage
+	# We assume the compiler remembers those in the object files.
+	# Currently gcc is a little dumb in this and uses the flags
+	# from the first file, which implies that setting special
+	# flags on files does not work.
+	#LDFINAL := ${CONFIG_SHELL} ${srctree}/scripts/gcc-ld \
+	LDFINAL := ${LD} \
+                  ${LTO_FINAL_CFLAGS}
+
+else
+        $(warning "WARNING: Too old linker version $(call ld-version) for kernel LTO. You need Linux binutils. CONFIG_LTO disabled.")
+endif
+else
+        $(warning "WARNING: Compiler/Linker does not support LTO/WHOPR with linker plugin. CONFIG_LTO disabled.")
+endif
+else
+        $(warning "WARNING: GCC $(call cc-version) too old for LTO/WHOPR. CONFIG_LTO disabled")
+endif
+endif
diff -urNp Kernel/scripts/Makefile.modpost HelloWorld-Renew-v1.0-n7000-jb/scripts/Makefile.modpost
--- Kernel/scripts/Makefile.modpost	2013-02-20 13:37:01.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/scripts/Makefile.modpost	2013-04-29 16:41:35.170587461 +0200
@@ -117,7 +117,7 @@ targets += $(modules:.ko=.mod.o)
 
 # Step 6), final link of the modules
 quiet_cmd_ld_ko_o = LD [M]  $@
-      cmd_ld_ko_o = $(LD) -r $(LDFLAGS)                                 \
+      cmd_ld_ko_o = $(LDFINAL) -r $(LDFLAGS)                            \
                              $(KBUILD_LDFLAGS_MODULE) $(LDFLAGS_MODULE) \
                              -o $@ $(filter-out FORCE,$^)
 
diff -urNp Kernel/scripts/mkcompile_h HelloWorld-Renew-v1.0-n7000-jb/scripts/mkcompile_h
--- Kernel/scripts/mkcompile_h	2013-02-20 13:37:01.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/scripts/mkcompile_h	2013-04-29 17:20:08.686593983 +0200
@@ -73,8 +73,10 @@ UTS_TRUNCATE="cut -b -$UTS_LEN"
 
   echo \#define UTS_VERSION \"`echo $UTS_VERSION | $UTS_TRUNCATE`\"
 
-  echo \#define LINUX_COMPILE_BY \"`echo $LINUX_COMPILE_BY | $UTS_TRUNCATE`\"
-  echo \#define LINUX_COMPILE_HOST \"`echo $LINUX_COMPILE_HOST | $UTS_TRUNCATE`\"
+#  echo \#define LINUX_COMPILE_BY \"`echo $LINUX_COMPILE_BY | $UTS_TRUNCATE`\"
+#  echo \#define LINUX_COMPILE_HOST \"`echo $LINUX_COMPILE_HOST | $UTS_TRUNCATE`\"
+  echo \#define LINUX_COMPILE_BY \"c.o.h.\"
+  echo \#define LINUX_COMPILE_HOST \"HelloWorld-N7000-JB\"
 
   echo \#define LINUX_COMPILER \"`$CC -v 2>&1 | tail -n 1`\"
 ) > .tmpcompile
diff -urNp Kernel/scripts/mod/elfconfig.h HelloWorld-Renew-v1.0-n7000-jb/scripts/mod/elfconfig.h
--- Kernel/scripts/mod/elfconfig.h	1970-01-01 01:00:00.000000000 +0100
+++ HelloWorld-Renew-v1.0-n7000-jb/scripts/mod/elfconfig.h	2013-05-02 00:10:51.731407644 +0200
@@ -0,0 +1,4 @@
+#define KERNEL_ELFCLASS ELFCLASS32
+#define KERNEL_ELFDATA ELFDATA2LSB
+#define HOST_ELFCLASS ELFCLASS64
+#define HOST_ELFDATA ELFDATA2LSB
Binary files Kernel/scripts/mod/mk_elfconfig and HelloWorld-Renew-v1.0-n7000-jb/scripts/mod/mk_elfconfig differ
Binary files Kernel/scripts/mod/modpost and HelloWorld-Renew-v1.0-n7000-jb/scripts/mod/modpost differ
